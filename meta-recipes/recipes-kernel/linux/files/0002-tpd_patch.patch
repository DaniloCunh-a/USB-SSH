diff --git a/.gitignore b/.gitignore
index 7afd412da..412ee8a3e 100644
--- a/.gitignore
+++ b/.gitignore
@@ -10,6 +10,7 @@
 #
 # Normal rules (sorted alphabetically)
 #
+.vscode/
 .*
 *.a
 *.asn1.[ch]
@@ -161,3 +162,8 @@ x509.genkey
 
 # Documentation toolchain
 sphinx_*/
+
+update-img.sh
+build.sh
+rebuild.sh
+update_kernel.sh
\ No newline at end of file
diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index 09460432d..de6b78f2a 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -1,6 +1,8 @@
 # SPDX-License-Identifier: GPL-2.0
 
 # board-specific dtc flags
+DTC_FLAGS_stm32mp157f-dn-som += -@
+DTC_FLAGS_stm32mp151c-dn-som += -@
 DTC_FLAGS_stm32mp157c-dk2 += -@
 DTC_FLAGS_stm32f429-disco += -@
 DTC_FLAGS_stm32f469-disco += -@
@@ -1141,6 +1143,8 @@ dtb-$(CONFIG_ARCH_STI) += \
 	stih418-b2199.dtb \
 	stih418-b2264.dtb
 dtb-$(CONFIG_ARCH_STM32) += \
+	stm32mp157f-dn-som.dtb \
+	stm32mp151c-dn-som.dtb \
 	stm32f429-disco.dtb \
 	stm32f469-disco.dtb \
 	stm32f746-disco.dtb \
diff --git a/arch/arm/boot/dts/dn-som.dts b/arch/arm/boot/dts/dn-som.dts
new file mode 100644
index 000000000..9fbb07e86
--- /dev/null
+++ b/arch/arm/boot/dts/dn-som.dts
@@ -0,0 +1,923 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: STM32CubeMX code generation for STMicroelectronics.
+ */
+
+/* For more information on Device Tree configuration, please refer to
+ * https://wiki.st.com/stm32mpu/wiki/Category:Device_tree_configuration
+ */
+
+/dts-v1/;
+#include <dt-bindings/pinctrl/stm32-pinfunc.h>
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xf.dtsi"
+#include "stm32mp15xxac-pinctrl.dtsi"
+#include "stm32mp15-m4-srm.dtsi"
+
+/* USER CODE BEGIN includes */
+/* USER CODE END includes */
+
+/ {
+	model = "STMicroelectronics custom STM32CubeMX board - openstlinux-5.15-yocto-kirkstone-mp1-v22.06.15";
+	compatible = "st,stm32mp157f-dn-som-stm32mp1-mx", "st,stm32mp157";
+
+	memory@c0000000 {
+		device_type = "memory";
+		reg = <0xc0000000 0x20000000>;
+
+		/* USER CODE BEGIN memory */
+		/* USER CODE END memory */
+	};
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		/* USER CODE BEGIN reserved-memory */
+		/* USER CODE END reserved-memory */
+	};
+
+	/* USER CODE BEGIN root */
+	/* USER CODE END root */
+
+	clocks {
+		/* USER CODE BEGIN clocks */
+		/* USER CODE END clocks */
+
+	};
+
+}; /*root*/
+
+&pinctrl {
+
+	adc_pins_mx: adc_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, ANALOG)>, /* ADC1_INP13 */
+					 <STM32_PINMUX('F', 12, ANALOG)>, /* ADC1_INP6 */
+					 <STM32_PINMUX('F', 13, ANALOG)>, /* ADC2_INP2 */
+					 <STM32_PINMUX('F', 14, ANALOG)>; /* ADC2_INP6 */
+		};
+	};
+
+	adc_sleep_pins_mx: adc_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, ANALOG)>, /* ADC1_INP13 */
+					 <STM32_PINMUX('F', 12, ANALOG)>, /* ADC1_INP6 */
+					 <STM32_PINMUX('F', 13, ANALOG)>, /* ADC2_INP2 */
+					 <STM32_PINMUX('F', 14, ANALOG)>; /* ADC2_INP6 */
+		};
+	};
+
+	dac1_pins_mx: dac1_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 5, ANALOG)>; /* DAC1_OUT2 */
+		};
+	};
+
+	dac1_sleep_pins_mx: dac1_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 5, ANALOG)>; /* DAC1_OUT2 */
+		};
+	};
+
+	eth1_pins_mx: eth1_mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 1, AF11)>, /* ETH1_RX_CLK */
+					 <STM32_PINMUX('A', 7, AF11)>, /* ETH1_RX_CTL */
+					 <STM32_PINMUX('B', 0, AF11)>, /* ETH1_RXD2 */
+					 <STM32_PINMUX('B', 1, AF11)>, /* ETH1_RXD3 */
+					 <STM32_PINMUX('C', 4, AF11)>, /* ETH1_RXD0 */
+					 <STM32_PINMUX('C', 5, AF11)>; /* ETH1_RXD1 */
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('A', 2, AF11)>; /* ETH1_MDIO */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('B', 11, AF11)>, /* ETH1_TX_CTL */
+					 <STM32_PINMUX('C', 1, AF11)>, /* ETH1_MDC */
+					 <STM32_PINMUX('C', 2, AF11)>, /* ETH1_TXD2 */
+					 <STM32_PINMUX('E', 2, AF11)>, /* ETH1_TXD3 */
+					 <STM32_PINMUX('G', 4, AF11)>, /* ETH1_GTX_CLK */
+					 <STM32_PINMUX('G', 5, AF11)>, /* ETH1_CLK125 */
+					 <STM32_PINMUX('G', 13, AF11)>, /* ETH1_TXD0 */
+					 <STM32_PINMUX('G', 14, AF11)>; /* ETH1_TXD1 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+		pins4 {
+			pinmux = <STM32_PINMUX('B', 5, AF0)>; /* ETH1_CLK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+	};
+
+	eth1_sleep_pins_mx: eth1_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 1, ANALOG)>, /* ETH1_RX_CLK */
+					 <STM32_PINMUX('A', 2, ANALOG)>, /* ETH1_MDIO */
+					 <STM32_PINMUX('A', 7, ANALOG)>, /* ETH1_RX_CTL */
+					 <STM32_PINMUX('B', 0, ANALOG)>, /* ETH1_RXD2 */
+					 <STM32_PINMUX('B', 1, ANALOG)>, /* ETH1_RXD3 */
+					 <STM32_PINMUX('B', 5, ANALOG)>, /* ETH1_CLK */
+					 <STM32_PINMUX('B', 11, ANALOG)>, /* ETH1_TX_CTL */
+					 <STM32_PINMUX('C', 1, ANALOG)>, /* ETH1_MDC */
+					 <STM32_PINMUX('C', 2, ANALOG)>, /* ETH1_TXD2 */
+					 <STM32_PINMUX('C', 4, ANALOG)>, /* ETH1_RXD0 */
+					 <STM32_PINMUX('C', 5, ANALOG)>, /* ETH1_RXD1 */
+					 <STM32_PINMUX('E', 2, ANALOG)>, /* ETH1_TXD3 */
+					 <STM32_PINMUX('G', 4, ANALOG)>, /* ETH1_GTX_CLK */
+					 <STM32_PINMUX('G', 5, ANALOG)>, /* ETH1_CLK125 */
+					 <STM32_PINMUX('G', 13, ANALOG)>, /* ETH1_TXD0 */
+					 <STM32_PINMUX('G', 14, ANALOG)>; /* ETH1_TXD1 */
+		};
+	};
+
+	fdcan1_pins_mx: fdcan1_mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('D', 0, AF9)>; /* FDCAN1_RX */
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('D', 1, AF9)>; /* FDCAN1_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	fdcan1_sleep_pins_mx: fdcan1_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 0, ANALOG)>, /* FDCAN1_RX */
+					 <STM32_PINMUX('D', 1, ANALOG)>; /* FDCAN1_TX */
+		};
+	};
+
+	hdmi_cec_pins_mx: hdmi_cec_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 6, AF5)>; /* CEC */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	hdmi_cec_sleep_pins_mx: hdmi_cec_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 6, ANALOG)>; /* CEC */
+		};
+	};
+
+	i2c1_pins_mx: i2c1_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 12, AF5)>, /* I2C1_SCL */
+					 <STM32_PINMUX('F', 15, AF5)>; /* I2C1_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	i2c1_sleep_pins_mx: i2c1_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 12, ANALOG)>, /* I2C1_SCL */
+					 <STM32_PINMUX('F', 15, ANALOG)>; /* I2C1_SDA */
+		};
+	};
+
+	i2c5_pins_mx: i2c5_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 11, AF4)>, /* I2C5_SCL */
+					 <STM32_PINMUX('A', 12, AF4)>; /* I2C5_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	i2c5_sleep_pins_mx: i2c5_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 11, ANALOG)>, /* I2C5_SCL */
+					 <STM32_PINMUX('A', 12, ANALOG)>; /* I2C5_SDA */
+		};
+	};
+
+	i2s2_pins_mx: i2s2_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 9, AF5)>, /* I2S2_CK */
+					 <STM32_PINMUX('B', 9, AF5)>, /* I2S2_WS */
+					 <STM32_PINMUX('I', 3, AF5)>; /* I2S2_SDO */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+	};
+
+	i2s2_sleep_pins_mx: i2s2_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 9, ANALOG)>, /* I2S2_CK */
+					 <STM32_PINMUX('B', 9, ANALOG)>, /* I2S2_WS */
+					 <STM32_PINMUX('I', 3, ANALOG)>; /* I2S2_SDO */
+		};
+	};
+
+	ltdc_pins_mx: ltdc_mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 3, AF14)>, /* LTDC_B5 */
+					 <STM32_PINMUX('B', 8, AF14)>, /* LTDC_B6 */
+					 <STM32_PINMUX('C', 0, AF14)>, /* LTDC_R5 */
+					 <STM32_PINMUX('D', 8, AF14)>, /* LTDC_B7 */
+					 <STM32_PINMUX('D', 9, AF14)>, /* LTDC_B0 */
+					 <STM32_PINMUX('D', 10, AF14)>, /* LTDC_B3 */
+					 <STM32_PINMUX('E', 5, AF14)>, /* LTDC_G0 */
+					 <STM32_PINMUX('E', 6, AF14)>, /* LTDC_G1 */
+					 <STM32_PINMUX('E', 15, AF14)>, /* LTDC_R7 */
+					 <STM32_PINMUX('F', 10, AF14)>, /* LTDC_DE */
+					 <STM32_PINMUX('G', 10, AF14)>, /* LTDC_B2 */
+					 <STM32_PINMUX('G', 12, AF14)>, /* LTDC_B1 */
+					 <STM32_PINMUX('H', 2, AF14)>, /* LTDC_R0 */
+					 <STM32_PINMUX('H', 3, AF14)>, /* LTDC_R1 */
+					 <STM32_PINMUX('H', 8, AF14)>, /* LTDC_R2 */
+					 <STM32_PINMUX('H', 9, AF14)>, /* LTDC_R3 */
+					 <STM32_PINMUX('H', 10, AF14)>, /* LTDC_R4 */
+					 <STM32_PINMUX('H', 12, AF14)>, /* LTDC_R6 */
+					 <STM32_PINMUX('H', 13, AF14)>, /* LTDC_G2 */
+					 <STM32_PINMUX('H', 14, AF14)>, /* LTDC_G3 */
+					 <STM32_PINMUX('H', 15, AF14)>, /* LTDC_G4 */
+					 <STM32_PINMUX('I', 0, AF14)>, /* LTDC_G5 */
+					 <STM32_PINMUX('I', 1, AF14)>, /* LTDC_G6 */
+					 <STM32_PINMUX('I', 2, AF14)>, /* LTDC_G7 */
+					 <STM32_PINMUX('I', 4, AF14)>, /* LTDC_B4 */
+					 <STM32_PINMUX('I', 9, AF14)>, /* LTDC_VSYNC */
+					 <STM32_PINMUX('I', 10, AF14)>; /* LTDC_HSYNC */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('G', 7, AF14)>; /* LTDC_CLK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+	};
+
+	ltdc_sleep_pins_mx: ltdc_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 3, ANALOG)>, /* LTDC_B5 */
+					 <STM32_PINMUX('B', 8, ANALOG)>, /* LTDC_B6 */
+					 <STM32_PINMUX('C', 0, ANALOG)>, /* LTDC_R5 */
+					 <STM32_PINMUX('D', 8, ANALOG)>, /* LTDC_B7 */
+					 <STM32_PINMUX('D', 9, ANALOG)>, /* LTDC_B0 */
+					 <STM32_PINMUX('D', 10, ANALOG)>, /* LTDC_B3 */
+					 <STM32_PINMUX('E', 5, ANALOG)>, /* LTDC_G0 */
+					 <STM32_PINMUX('E', 6, ANALOG)>, /* LTDC_G1 */
+					 <STM32_PINMUX('E', 15, ANALOG)>, /* LTDC_R7 */
+					 <STM32_PINMUX('F', 10, ANALOG)>, /* LTDC_DE */
+					 <STM32_PINMUX('G', 7, ANALOG)>, /* LTDC_CLK */
+					 <STM32_PINMUX('G', 10, ANALOG)>, /* LTDC_B2 */
+					 <STM32_PINMUX('G', 12, ANALOG)>, /* LTDC_B1 */
+					 <STM32_PINMUX('H', 2, ANALOG)>, /* LTDC_R0 */
+					 <STM32_PINMUX('H', 3, ANALOG)>, /* LTDC_R1 */
+					 <STM32_PINMUX('H', 8, ANALOG)>, /* LTDC_R2 */
+					 <STM32_PINMUX('H', 9, ANALOG)>, /* LTDC_R3 */
+					 <STM32_PINMUX('H', 10, ANALOG)>, /* LTDC_R4 */
+					 <STM32_PINMUX('H', 12, ANALOG)>, /* LTDC_R6 */
+					 <STM32_PINMUX('H', 13, ANALOG)>, /* LTDC_G2 */
+					 <STM32_PINMUX('H', 14, ANALOG)>, /* LTDC_G3 */
+					 <STM32_PINMUX('H', 15, ANALOG)>, /* LTDC_G4 */
+					 <STM32_PINMUX('I', 0, ANALOG)>, /* LTDC_G5 */
+					 <STM32_PINMUX('I', 1, ANALOG)>, /* LTDC_G6 */
+					 <STM32_PINMUX('I', 2, ANALOG)>, /* LTDC_G7 */
+					 <STM32_PINMUX('I', 4, ANALOG)>, /* LTDC_B4 */
+					 <STM32_PINMUX('I', 9, ANALOG)>, /* LTDC_VSYNC */
+					 <STM32_PINMUX('I', 10, ANALOG)>; /* LTDC_HSYNC */
+		};
+	};
+
+	sai2a_pins_mx: sai2a_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 0, AF10)>, /* SAI2_MCLK_A */
+					 <STM32_PINMUX('I', 5, AF10)>, /* SAI2_SCK_A */
+					 <STM32_PINMUX('I', 6, AF10)>, /* SAI2_SD_A */
+					 <STM32_PINMUX('I', 7, AF10)>; /* SAI2_FS_A */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	sai2a_sleep_pins_mx: sai2a_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 0, ANALOG)>, /* SAI2_MCLK_A */
+					 <STM32_PINMUX('I', 5, ANALOG)>, /* SAI2_SCK_A */
+					 <STM32_PINMUX('I', 6, ANALOG)>, /* SAI2_SD_A */
+					 <STM32_PINMUX('I', 7, ANALOG)>; /* SAI2_FS_A */
+		};
+	};
+
+	sdmmc1_pins_mx: sdmmc1_mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
+					 <STM32_PINMUX('C', 9, AF12)>, /* SDMMC1_D1 */
+					 <STM32_PINMUX('C', 10, AF12)>, /* SDMMC1_D2 */
+					 <STM32_PINMUX('C', 11, AF12)>, /* SDMMC1_D3 */
+					 <STM32_PINMUX('D', 2, AF12)>; /* SDMMC1_CMD */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('C', 12, AF12)>; /* SDMMC1_CK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+		};
+	};
+
+	sdmmc1_opendrain_pins_mx: sdmmc1_opendrain_mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
+					 <STM32_PINMUX('C', 9, AF12)>, /* SDMMC1_D1 */
+					 <STM32_PINMUX('C', 10, AF12)>, /* SDMMC1_D2 */
+					 <STM32_PINMUX('C', 11, AF12)>; /* SDMMC1_D3 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('C', 12, AF12)>; /* SDMMC1_CK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('D', 2, AF12)>; /* SDMMC1_CMD */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <1>;
+		};
+	};
+
+	sdmmc1_sleep_pins_mx: sdmmc1_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 8, ANALOG)>, /* SDMMC1_D0 */
+					 <STM32_PINMUX('C', 9, ANALOG)>, /* SDMMC1_D1 */
+					 <STM32_PINMUX('C', 10, ANALOG)>, /* SDMMC1_D2 */
+					 <STM32_PINMUX('C', 11, ANALOG)>, /* SDMMC1_D3 */
+					 <STM32_PINMUX('C', 12, ANALOG)>, /* SDMMC1_CK */
+					 <STM32_PINMUX('D', 2, ANALOG)>; /* SDMMC1_CMD */
+		};
+	};
+
+	sdmmc2_pins_mx: sdmmc2_mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 8, AF9)>, /* SDMMC2_D4 */
+					 <STM32_PINMUX('A', 15, AF9)>, /* SDMMC2_D5 */
+					 <STM32_PINMUX('B', 3, AF9)>, /* SDMMC2_D2 */
+					 <STM32_PINMUX('B', 4, AF9)>, /* SDMMC2_D3 */
+					 <STM32_PINMUX('B', 14, AF9)>, /* SDMMC2_D0 */
+					 <STM32_PINMUX('B', 15, AF9)>, /* SDMMC2_D1 */
+					 <STM32_PINMUX('C', 6, AF10)>, /* SDMMC2_D6 */
+					 <STM32_PINMUX('D', 3, AF9)>, /* SDMMC2_D7 */
+					 <STM32_PINMUX('G', 6, AF10)>; /* SDMMC2_CMD */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 3, AF9)>; /* SDMMC2_CK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+		};
+	};
+
+	sdmmc2_opendrain_pins_mx: sdmmc2_opendrain_mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 8, AF9)>, /* SDMMC2_D4 */
+					 <STM32_PINMUX('A', 15, AF9)>, /* SDMMC2_D5 */
+					 <STM32_PINMUX('B', 3, AF9)>, /* SDMMC2_D2 */
+					 <STM32_PINMUX('B', 4, AF9)>, /* SDMMC2_D3 */
+					 <STM32_PINMUX('B', 14, AF9)>, /* SDMMC2_D0 */
+					 <STM32_PINMUX('B', 15, AF9)>, /* SDMMC2_D1 */
+					 <STM32_PINMUX('C', 6, AF10)>, /* SDMMC2_D6 */
+					 <STM32_PINMUX('D', 3, AF9)>; /* SDMMC2_D7 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 3, AF9)>; /* SDMMC2_CK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('G', 6, AF10)>; /* SDMMC2_CMD */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <1>;
+		};
+	};
+
+	sdmmc2_sleep_pins_mx: sdmmc2_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 8, ANALOG)>, /* SDMMC2_D4 */
+					 <STM32_PINMUX('A', 15, ANALOG)>, /* SDMMC2_D5 */
+					 <STM32_PINMUX('B', 3, ANALOG)>, /* SDMMC2_D2 */
+					 <STM32_PINMUX('B', 4, ANALOG)>, /* SDMMC2_D3 */
+					 <STM32_PINMUX('B', 14, ANALOG)>, /* SDMMC2_D0 */
+					 <STM32_PINMUX('B', 15, ANALOG)>, /* SDMMC2_D1 */
+					 <STM32_PINMUX('C', 6, ANALOG)>, /* SDMMC2_D6 */
+					 <STM32_PINMUX('D', 3, ANALOG)>, /* SDMMC2_D7 */
+					 <STM32_PINMUX('E', 3, ANALOG)>, /* SDMMC2_CK */
+					 <STM32_PINMUX('G', 6, ANALOG)>; /* SDMMC2_CMD */
+		};
+	};
+
+	tim3_pwm_pins_mx: tim3_pwm_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 7, AF2)>; /* TIM3_CH2 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	tim3_pwm_sleep_pins_mx: tim3_pwm_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 7, ANALOG)>; /* TIM3_CH2 */
+		};
+	};
+
+	tim5_pwm_pins_mx: tim5_pwm_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 11, AF2)>; /* TIM5_CH2 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	tim5_pwm_sleep_pins_mx: tim5_pwm_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 11, ANALOG)>; /* TIM5_CH2 */
+		};
+	};
+
+	usart2_pins_mx: usart2_mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('D', 5, AF7)>; /* USART2_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('D', 6, AF7)>; /* USART2_RX */
+			bias-disable;
+		};
+	};
+
+	usart2_sleep_pins_mx: usart2_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 5, ANALOG)>, /* USART2_TX */
+					 <STM32_PINMUX('D', 6, ANALOG)>; /* USART2_RX */
+		};
+	};
+
+	usart3_pins_mx: usart3_mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 10, AF7)>, /* USART3_TX */
+					 <STM32_PINMUX('G', 8, AF8)>; /* USART3_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 12, AF8)>, /* USART3_RX */
+					 <STM32_PINMUX('B', 13, AF7)>; /* USART3_CTS */
+			bias-disable;
+		};
+	};
+
+	usart3_sleep_pins_mx: usart3_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 10, ANALOG)>, /* USART3_TX */
+					 <STM32_PINMUX('B', 12, ANALOG)>, /* USART3_RX */
+					 <STM32_PINMUX('B', 13, ANALOG)>, /* USART3_CTS */
+					 <STM32_PINMUX('G', 8, ANALOG)>; /* USART3_RTS */
+		};
+	};
+
+	usb_otg_hs_pins_mx: usb_otg_hs_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 10, ANALOG)>; /* USB_OTG_HS_ID */
+		};
+	};
+
+	usb_otg_hs_sleep_pins_mx: usb_otg_hs_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 10, ANALOG)>; /* USB_OTG_HS_ID */
+		};
+	};
+
+	/* USER CODE BEGIN pinctrl */
+	/* USER CODE END pinctrl */
+};
+
+&pinctrl_z {
+
+	i2c4_pins_z_mx: i2c4_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 4, AF6)>, /* I2C4_SCL */
+					 <STM32_PINMUX('Z', 5, AF6)>; /* I2C4_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	i2c4_sleep_pins_z_mx: i2c4_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 4, ANALOG)>, /* I2C4_SCL */
+					 <STM32_PINMUX('Z', 5, ANALOG)>; /* I2C4_SDA */
+		};
+	};
+
+	spi1_pins_z_mx: spi1_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 0, AF5)>, /* SPI1_SCK */
+					 <STM32_PINMUX('Z', 1, AF5)>, /* SPI1_MISO */
+					 <STM32_PINMUX('Z', 2, AF5)>; /* SPI1_MOSI */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+	};
+
+	spi1_sleep_pins_z_mx: spi1_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 0, ANALOG)>, /* SPI1_SCK */
+					 <STM32_PINMUX('Z', 1, ANALOG)>, /* SPI1_MISO */
+					 <STM32_PINMUX('Z', 2, ANALOG)>; /* SPI1_MOSI */
+		};
+	};
+
+	/* USER CODE BEGIN pinctrl_z */
+	/* USER CODE END pinctrl_z */
+};
+
+&m4_rproc{
+	status = "okay";
+
+	/* USER CODE BEGIN m4_rproc */
+	/* USER CODE END m4_rproc */
+
+	m4_system_resources{
+		status = "okay";
+
+		/* USER CODE BEGIN m4_system_resources */
+		/* USER CODE END m4_system_resources */
+	};
+};
+
+&adc{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&adc_pins_mx>;
+	pinctrl-1 = <&adc_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN adc */
+	/* USER CODE END adc */
+};
+
+&bsec{
+	status = "okay";
+
+	/* USER CODE BEGIN bsec */
+	/* USER CODE END bsec */
+};
+
+&cec{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&hdmi_cec_pins_mx>;
+	pinctrl-1 = <&hdmi_cec_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN cec */
+	/* USER CODE END cec */
+};
+
+&dac{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dac1_pins_mx>;
+	pinctrl-1 = <&dac1_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN dac */
+	/* USER CODE END dac */
+};
+
+&dma1{
+	status = "okay";
+
+	/* USER CODE BEGIN dma1 */
+	/* USER CODE END dma1 */
+};
+
+&dma2{
+	status = "disabled";
+
+	/* USER CODE BEGIN dma2 */
+	/* USER CODE END dma2 */
+};
+
+&dmamux1{
+	status = "okay";
+
+	dma-masters = <&dma1>;
+	dma-channels = <8>;
+
+	/* USER CODE BEGIN dmamux1 */
+	/* USER CODE END dmamux1 */
+};
+
+&ethernet0{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&eth1_pins_mx>;
+	pinctrl-1 = <&eth1_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN ethernet0 */
+	/* USER CODE END ethernet0 */
+};
+
+&hsem{
+	status = "okay";
+
+	/* USER CODE BEGIN hsem */
+	/* USER CODE END hsem */
+};
+
+&i2c1{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c1_pins_mx>;
+	pinctrl-1 = <&i2c1_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN i2c1 */
+	/* USER CODE END i2c1 */
+};
+
+&i2c4{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c4_pins_z_mx>;
+	pinctrl-1 = <&i2c4_sleep_pins_z_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN i2c4 */
+	/* USER CODE END i2c4 */
+};
+
+&i2c5{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c5_pins_mx>;
+	pinctrl-1 = <&i2c5_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN i2c5 */
+	/* USER CODE END i2c5 */
+};
+
+&i2s2{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2s2_pins_mx>;
+	pinctrl-1 = <&i2s2_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN i2s2 */
+	/* USER CODE END i2s2 */
+};
+
+&ltdc{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&ltdc_pins_mx>;
+	pinctrl-1 = <&ltdc_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN ltdc */
+	/* USER CODE END ltdc */
+};
+
+&m_can1{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&fdcan1_pins_mx>;
+	pinctrl-1 = <&fdcan1_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN m_can1 */
+	/* USER CODE END m_can1 */
+};
+
+&m4_dma2{
+	status = "okay";
+
+	/* USER CODE BEGIN m4_dma2 */
+	/* USER CODE END m4_dma2 */
+};
+
+&mdma1{
+	status = "okay";
+
+	/* USER CODE BEGIN mdma1 */
+	/* USER CODE END mdma1 */
+};
+
+&pwr_regulators{
+	status = "okay";
+
+	/* USER CODE BEGIN pwr_regulators */
+	/* USER CODE END pwr_regulators */
+};
+
+&rcc{
+	status = "okay";
+
+	/* USER CODE BEGIN rcc */
+	/* USER CODE END rcc */
+};
+
+&rtc{
+	status = "okay";
+
+	/* USER CODE BEGIN rtc */
+	/* USER CODE END rtc */
+};
+
+&sai2{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sai2a_pins_mx>;
+	pinctrl-1 = <&sai2a_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN sai2 */
+	/* USER CODE END sai2 */
+
+	sai2a:audio-controller@4400b004{
+		status = "okay";
+
+		/* USER CODE BEGIN sai2a */
+		/* USER CODE END sai2a */
+	};
+};
+
+&sdmmc1{
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_pins_mx>;
+	pinctrl-1 = <&sdmmc1_opendrain_pins_mx>;
+	pinctrl-2 = <&sdmmc1_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN sdmmc1 */
+	/* USER CODE END sdmmc1 */
+};
+
+&sdmmc2{
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_pins_mx>;
+	pinctrl-1 = <&sdmmc2_opendrain_pins_mx>;
+	pinctrl-2 = <&sdmmc2_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN sdmmc2 */
+	/* USER CODE END sdmmc2 */
+};
+
+&spi1{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi1_pins_z_mx>;
+	pinctrl-1 = <&spi1_sleep_pins_z_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN spi1 */
+	/* USER CODE END spi1 */
+};
+
+&tamp{
+	status = "okay";
+
+	/* USER CODE BEGIN tamp */
+	/* USER CODE END tamp */
+};
+
+&timers3{
+	status = "okay";
+
+	/* USER CODE BEGIN timers3 */
+	/* USER CODE END timers3 */
+
+	pwm{
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&tim3_pwm_pins_mx>;
+		pinctrl-1 = <&tim3_pwm_sleep_pins_mx>;
+		status = "okay";
+
+		/* USER CODE BEGIN timers3_pwm */
+		/* USER CODE END timers3_pwm */
+	};
+};
+
+&timers5{
+	status = "okay";
+
+	/* USER CODE BEGIN timers5 */
+	/* USER CODE END timers5 */
+
+	pwm{
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&tim5_pwm_pins_mx>;
+		pinctrl-1 = <&tim5_pwm_sleep_pins_mx>;
+		status = "okay";
+
+		/* USER CODE BEGIN timers5_pwm */
+		/* USER CODE END timers5_pwm */
+	};
+};
+
+&usart2{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&usart2_pins_mx>;
+	pinctrl-1 = <&usart2_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN usart2 */
+	/* USER CODE END usart2 */
+};
+
+&usart3{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&usart3_pins_mx>;
+	pinctrl-1 = <&usart3_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN usart3 */
+	/* USER CODE END usart3 */
+};
+
+&usbh_ehci{
+	status = "okay";
+
+	/* USER CODE BEGIN usbh_ehci */
+	/* USER CODE END usbh_ehci */
+};
+
+&usbh_ohci{
+	status = "okay";
+
+	/* USER CODE BEGIN usbh_ohci */
+	/* USER CODE END usbh_ohci */
+};
+
+&usbotg_hs{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&usb_otg_hs_pins_mx>;
+	pinctrl-1 = <&usb_otg_hs_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN usbotg_hs */
+	/* USER CODE END usbotg_hs */
+};
+
+&usbphyc{
+	status = "okay";
+
+	/* USER CODE BEGIN usbphyc */
+	/* USER CODE END usbphyc */
+};
+
+&usbphyc_port0{
+	status = "okay";
+
+	/* USER CODE BEGIN usbphyc_port0 */
+	/* USER CODE END usbphyc_port0 */
+};
+
+&usbphyc_port1{
+	status = "okay";
+
+	/* USER CODE BEGIN usbphyc_port1 */
+	/* USER CODE END usbphyc_port1 */
+};
+
+/* USER CODE BEGIN addons */
+/* USER CODE END addons */
+
diff --git a/arch/arm/boot/dts/stm32mp15-pinctrl.dtsi b/arch/arm/boot/dts/stm32mp15-pinctrl.dtsi
index d2f2cc8f3..a9b0f0269 100644
--- a/arch/arm/boot/dts/stm32mp15-pinctrl.dtsi
+++ b/arch/arm/boot/dts/stm32mp15-pinctrl.dtsi
@@ -190,7 +190,7 @@ pins {
 		};
 	};
 
-	ethernet0_rgmii_pins_a: rgmii-0 {
+	ethernet0_rgmii_pins_a: ethernet0-rgmii-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, AF11)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, AF11)>, /* ETH_RGMII_GTX_CLK */
@@ -199,7 +199,8 @@ pins1 {
 				 <STM32_PINMUX('C', 2, AF11)>, /* ETH_RGMII_TXD2 */
 				 <STM32_PINMUX('E', 2, AF11)>, /* ETH_RGMII_TXD3 */
 				 <STM32_PINMUX('B', 11, AF11)>, /* ETH_RGMII_TX_CTL */
-				 <STM32_PINMUX('C', 1, AF11)>; /* ETH_MDC */
+				 <STM32_PINMUX('C', 1, AF11)>, /* ETH_MDC */
+				 <STM32_PINMUX('B', 5, AF0)>; /* ETH_RGMII_ETHCK */
 			bias-disable;
 			drive-push-pull;
 			slew-rate = <2>;
@@ -221,7 +222,7 @@ pins3 {
 		};
 	};
 
-	ethernet0_rgmii_sleep_pins_a: rgmii-sleep-0 {
+	ethernet0_rgmii_sleep_pins_a: ethernet0-rgmii-sleep-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, ANALOG)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, ANALOG)>, /* ETH_RGMII_GTX_CLK */
@@ -241,7 +242,7 @@ pins1 {
 		};
 	};
 
-	ethernet0_rgmii_pins_b: rgmii-1 {
+	ethernet0_rgmii_pins_b: ethernet0-rgmii-1 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, AF11)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, AF11)>, /* ETH_RGMII_GTX_CLK */
@@ -272,7 +273,7 @@ pins3 {
 		};
 	};
 
-	ethernet0_rgmii_sleep_pins_b: rgmii-sleep-1 {
+	ethernet0_rgmii_sleep_pins_b: ethernet0-rgmii-sleep-1 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, ANALOG)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, ANALOG)>, /* ETH_RGMII_GTX_CLK */
@@ -292,7 +293,7 @@ pins1 {
 		 };
 	};
 
-	ethernet0_rgmii_pins_c: rgmii-2 {
+	ethernet0_rgmii_pins_c: ethernet0-rgmii-2 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, AF11)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, AF11)>, /* ETH_RGMII_GTX_CLK */
@@ -323,7 +324,7 @@ pins3 {
 		};
 	};
 
-	ethernet0_rgmii_sleep_pins_c: rgmii-sleep-2 {
+	ethernet0_rgmii_sleep_pins_c: ethernet0-rgmii-sleep-2 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, ANALOG)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, ANALOG)>, /* ETH_RGMII_GTX_CLK */
@@ -343,7 +344,7 @@ pins1 {
 		};
 	};
 
-	ethernet0_rmii_pins_a: rmii-0 {
+	ethernet0_rmii_pins_a: ethernet0-rmii-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 13, AF11)>, /* ETH1_RMII_TXD0 */
 				 <STM32_PINMUX('G', 14, AF11)>, /* ETH1_RMII_TXD1 */
@@ -363,7 +364,7 @@ pins2 {
 		};
 	};
 
-	ethernet0_rmii_sleep_pins_a: rmii-sleep-0 {
+	ethernet0_rmii_sleep_pins_a: ethernet0-rmii-sleep-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 13, ANALOG)>, /* ETH1_RMII_TXD0 */
 				 <STM32_PINMUX('G', 14, ANALOG)>, /* ETH1_RMII_TXD1 */
@@ -934,22 +935,22 @@ pins {
 
 	m_can1_pins_a: m-can1-0 {
 		pins1 {
-			pinmux = <STM32_PINMUX('H', 13, AF9)>; /* CAN1_TX */
-			slew-rate = <1>;
+			pinmux = <STM32_PINMUX('D', 1, AF9)>; /* CAN1_TX */
+			slew-rate = <0>;
 			drive-push-pull;
 			bias-disable;
 		};
 		pins2 {
-			pinmux = <STM32_PINMUX('I', 9, AF9)>; /* CAN1_RX */
+			pinmux = <STM32_PINMUX('D', 0, AF9)>; /* CAN1_RX */
 			bias-disable;
 		};
 	};
 
-	m_can1_sleep_pins_a: m_can1-sleep-0 {
+	m_can1_sleep_pins_a: m-can1-sleep-0 {
 		pins {
-			pinmux = <STM32_PINMUX('H', 13, ANALOG)>, /* CAN1_TX */
-				 <STM32_PINMUX('I', 9, ANALOG)>; /* CAN1_RX */
-		};
+			pinmux = <STM32_PINMUX('D', 1, ANALOG)>, /* CAN1_TX */
+				 <STM32_PINMUX('D', 0, ANALOG)>; /* CAN1_RX */
+		};	
 	};
 
 	m_can1_pins_b: m-can1-1 {
@@ -965,7 +966,7 @@ pins2 {
 		};
 	};
 
-	m_can1_sleep_pins_b: m_can1-sleep-1 {
+	m_can1_sleep_pins_b: m-can1-sleep-1 {
 		pins {
 			pinmux = <STM32_PINMUX('A', 12, ANALOG)>, /* CAN1_TX */
 				 <STM32_PINMUX('A', 11, ANALOG)>; /* CAN1_RX */
@@ -985,7 +986,7 @@ pins2 {
 		};
 	};
 
-	m_can2_sleep_pins_a: m_can2-sleep-0 {
+	m_can2_sleep_pins_a: m-can2-sleep-0 {
 		pins {
 			pinmux = <STM32_PINMUX('B', 13, ANALOG)>, /* CAN2_TX */
 				 <STM32_PINMUX('B', 5, ANALOG)>; /* CAN2_RX */
@@ -1152,23 +1153,8 @@ pins {
 		};
 	};
 
-	qspi_clk_pins_a: qspi-clk-0 {
-		pins {
-			pinmux = <STM32_PINMUX('F', 10, AF9)>; /* QSPI_CLK */
-			bias-disable;
-			drive-push-pull;
-			slew-rate = <3>;
-		};
-	};
-
-	qspi_clk_sleep_pins_a: qspi-clk-sleep-0 {
-		pins {
-			pinmux = <STM32_PINMUX('F', 10, ANALOG)>; /* QSPI_CLK */
-		};
-	};
-
 	qspi_bk1_pins_a: qspi-bk1-0 {
-		pins1 {
+		pins {
 			pinmux = <STM32_PINMUX('F', 8, AF10)>, /* QSPI_BK1_IO0 */
 				 <STM32_PINMUX('F', 9, AF10)>, /* QSPI_BK1_IO1 */
 				 <STM32_PINMUX('F', 7, AF9)>, /* QSPI_BK1_IO2 */
@@ -1177,12 +1163,6 @@ pins1 {
 			drive-push-pull;
 			slew-rate = <1>;
 		};
-		pins2 {
-			pinmux = <STM32_PINMUX('B', 6, AF10)>; /* QSPI_BK1_NCS */
-			bias-pull-up;
-			drive-push-pull;
-			slew-rate = <1>;
-		};
 	};
 
 	qspi_bk1_sleep_pins_a: qspi-bk1-sleep-0 {
@@ -1190,13 +1170,12 @@ pins {
 			pinmux = <STM32_PINMUX('F', 8, ANALOG)>, /* QSPI_BK1_IO0 */
 				 <STM32_PINMUX('F', 9, ANALOG)>, /* QSPI_BK1_IO1 */
 				 <STM32_PINMUX('F', 7, ANALOG)>, /* QSPI_BK1_IO2 */
-				 <STM32_PINMUX('F', 6, ANALOG)>, /* QSPI_BK1_IO3 */
-				 <STM32_PINMUX('B', 6, ANALOG)>; /* QSPI_BK1_NCS */
+				 <STM32_PINMUX('F', 6, ANALOG)>; /* QSPI_BK1_IO3 */
 		};
 	};
 
 	qspi_bk2_pins_a: qspi-bk2-0 {
-		pins1 {
+		pins {
 			pinmux = <STM32_PINMUX('H', 2, AF9)>, /* QSPI_BK2_IO0 */
 				 <STM32_PINMUX('H', 3, AF9)>, /* QSPI_BK2_IO1 */
 				 <STM32_PINMUX('G', 10, AF11)>, /* QSPI_BK2_IO2 */
@@ -1205,7 +1184,49 @@ pins1 {
 			drive-push-pull;
 			slew-rate = <1>;
 		};
-		pins2 {
+	};
+
+	qspi_bk2_sleep_pins_a: qspi-bk2-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 2, ANALOG)>, /* QSPI_BK2_IO0 */
+				 <STM32_PINMUX('H', 3, ANALOG)>, /* QSPI_BK2_IO1 */
+				 <STM32_PINMUX('G', 10, ANALOG)>, /* QSPI_BK2_IO2 */
+				 <STM32_PINMUX('G', 7, ANALOG)>; /* QSPI_BK2_IO3 */
+		};
+	};
+
+	qspi_clk_pins_a: qspi-clk-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 10, AF9)>; /* QSPI_CLK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+		};
+	};
+
+	qspi_clk_sleep_pins_a: qspi-clk-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 10, ANALOG)>; /* QSPI_CLK */
+		};
+	};
+
+	qspi_cs1_pins_a: qspi-cs1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 6, AF10)>; /* QSPI_BK1_NCS */
+			bias-pull-up;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+	};
+
+	qspi_cs1_sleep_pins_a: qspi-cs1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 6, ANALOG)>; /* QSPI_BK1_NCS */
+		};
+	};
+
+	qspi_cs2_pins_a: qspi-cs2-0 {
+		pins {
 			pinmux = <STM32_PINMUX('C', 0, AF10)>; /* QSPI_BK2_NCS */
 			bias-pull-up;
 			drive-push-pull;
@@ -1213,13 +1234,15 @@ pins2 {
 		};
 	};
 
-	qspi_bk2_sleep_pins_a: qspi-bk2-sleep-0 {
+	qspi_cs2_sleep_pins_a: qspi-cs2-sleep-0 {
 		pins {
-			pinmux = <STM32_PINMUX('H', 2, ANALOG)>, /* QSPI_BK2_IO0 */
-				 <STM32_PINMUX('H', 3, ANALOG)>, /* QSPI_BK2_IO1 */
-				 <STM32_PINMUX('G', 10, ANALOG)>, /* QSPI_BK2_IO2 */
-				 <STM32_PINMUX('G', 7, ANALOG)>, /* QSPI_BK2_IO3 */
-				 <STM32_PINMUX('C', 0, ANALOG)>; /* QSPI_BK2_NCS */
+			pinmux = <STM32_PINMUX('C', 0, ANALOG)>; /* QSPI_BK2_NCS */
+		};
+	};
+
+	rtc_out1_pins_a: rtc-out1-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 13, ANALOG)>; /* RTC_OUT1 */
 		};
 	};
 
@@ -1232,9 +1255,9 @@ pins {
 	sai2a_pins_a: sai2a-0 {
 		pins {
 			pinmux = <STM32_PINMUX('I', 5, AF10)>, /* SAI2_SCK_A */
-				 <STM32_PINMUX('I', 6, AF10)>, /* SAI2_SD_A */
-				 <STM32_PINMUX('I', 7, AF10)>, /* SAI2_FS_A */
-				 <STM32_PINMUX('E', 0, AF10)>; /* SAI2_MCLK_A */
+				 <STM32_PINMUX('I', 6, AF10)>, /* SAI2_SD_A dout*/
+				 <STM32_PINMUX('I', 7, AF10)>, /* SAI2_FS_A  lrcl*/
+				 <STM32_PINMUX('E', 0, AF10)>; /* SAI2_MCLK_A mclk*/ 
 			slew-rate = <0>;
 			drive-push-pull;
 			bias-disable;
@@ -1280,7 +1303,7 @@ pins {
 		};
 	};
 
-	sai2a_sleep_pins_c: sai2a-2 {
+	sai2a_sleep_pins_c: sai2a-sleep-2 {
 		pins {
 			pinmux = <STM32_PINMUX('D', 13, ANALOG)>, /* SAI2_SCK_A */
 				 <STM32_PINMUX('D', 11, ANALOG)>, /* SAI2_SD_A */
@@ -1314,9 +1337,9 @@ pins {
 
 	sai2b_pins_b: sai2b-1 {
 		pins {
-			pinmux = <STM32_PINMUX('F', 11, AF10)>; /* SAI2_SD_B */
+			pinmux = <STM32_PINMUX('F', 11, AF10)>; /* SAI2_SD_B Dout*/
 			bias-disable;
-		};
+		};	
 	};
 
 	sai2b_sleep_pins_b: sai2b-sleep-1 {
@@ -1372,6 +1395,18 @@ pins2 {
 		};
 	};
 
+	sdmmc1_b4_init_pins_a: sdmmc1-b4-init-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('C', 9, AF12)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('C', 10, AF12)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('C', 11, AF12)>; /* SDMMC1_D3 */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
 	sdmmc1_b4_od_pins_a: sdmmc1-b4-od-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
@@ -1396,18 +1431,6 @@ pins3 {
 		};
 	};
 
-	sdmmc1_b4_init_pins_a: sdmmc1-b4-init-0 {
-		pins1 {
-			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
-				 <STM32_PINMUX('C', 9, AF12)>, /* SDMMC1_D1 */
-				 <STM32_PINMUX('C', 10, AF12)>, /* SDMMC1_D2 */
-				 <STM32_PINMUX('C', 11, AF12)>; /* SDMMC1_D3 */
-			slew-rate = <1>;
-			drive-push-pull;
-			bias-disable;
-		};
-	};
-
 	sdmmc1_b4_sleep_pins_a: sdmmc1-b4-sleep-0 {
 		pins {
 			pinmux = <STM32_PINMUX('C', 8, ANALOG)>, /* SDMMC1_D0 */
@@ -1578,8 +1601,8 @@ pins3 {
 	sdmmc2_d47_pins_a: sdmmc2-d47-0 {
 		pins {
 			pinmux = <STM32_PINMUX('A', 8, AF9)>, /* SDMMC2_D4 */
-				 <STM32_PINMUX('A', 9, AF10)>, /* SDMMC2_D5 */
-				 <STM32_PINMUX('E', 5, AF9)>, /* SDMMC2_D6 */
+				 <STM32_PINMUX('A', 15, AF10)>, /* SDMMC2_D5 */
+				 <STM32_PINMUX('C', 6, AF9)>, /* SDMMC2_D6 */
 				 <STM32_PINMUX('D', 3, AF9)>; /* SDMMC2_D7 */
 			slew-rate = <1>;
 			drive-push-pull;
@@ -1590,8 +1613,8 @@ pins {
 	sdmmc2_d47_sleep_pins_a: sdmmc2-d47-sleep-0 {
 		pins {
 			pinmux = <STM32_PINMUX('A', 8, ANALOG)>, /* SDMMC2_D4 */
-				 <STM32_PINMUX('A', 9, ANALOG)>, /* SDMMC2_D5 */
-				 <STM32_PINMUX('E', 5, ANALOG)>, /* SDMMC2_D6 */
+				 <STM32_PINMUX('A', 15, ANALOG)>, /* SDMMC2_D5 */
+				 <STM32_PINMUX('C', 6, ANALOG)>, /* SDMMC2_D6 */
 				 <STM32_PINMUX('D', 3, ANALOG)>; /* SDMMC2_D7 */
 		};
 	};
@@ -1986,7 +2009,7 @@ pins2 {
 		};
 	};
 
-	uart8_rtscts_pins_a: uart8rtscts-0 {
+	uart8_rtscts_pins_a: uart8-rtscts-0 {
 		pins {
 			pinmux = <STM32_PINMUX('G', 7, AF8)>, /* UART8_RTS */
 				 <STM32_PINMUX('G', 10, AF8)>; /* UART8_CTS */
@@ -2044,31 +2067,23 @@ pins {
 
 	usart2_pins_c: usart2-2 {
 		pins1 {
-			pinmux = <STM32_PINMUX('D', 5, AF7)>, /* USART2_TX */
-				 <STM32_PINMUX('D', 4, AF7)>; /* USART2_RTS */
+			pinmux = <STM32_PINMUX('D', 5, AF7)>; /* USART2_TX */
 			bias-disable;
 			drive-push-pull;
 			slew-rate = <0>;
 		};
 		pins2 {
-			pinmux = <STM32_PINMUX('D', 6, AF7)>, /* USART2_RX */
-				 <STM32_PINMUX('D', 3, AF7)>; /* USART2_CTS_NSS */
+			pinmux = <STM32_PINMUX('D', 6, AF7)>; /* USART2_RX */
 			bias-disable;
 		};
 	};
 
 	usart2_idle_pins_c: usart2-idle-2 {
 		pins1 {
-			pinmux = <STM32_PINMUX('D', 5, ANALOG)>, /* USART2_TX */
-				 <STM32_PINMUX('D', 3, ANALOG)>; /* USART2_CTS_NSS */
+			pinmux = <STM32_PINMUX('D', 5, ANALOG)>; /* USART2_TX */
 		};
+
 		pins2 {
-			pinmux = <STM32_PINMUX('D', 4, AF7)>; /* USART2_RTS */
-			bias-disable;
-			drive-push-pull;
-			slew-rate = <0>;
-		};
-		pins3 {
 			pinmux = <STM32_PINMUX('D', 6, AF7)>; /* USART2_RX */
 			bias-disable;
 		};
@@ -2077,9 +2092,7 @@ pins3 {
 	usart2_sleep_pins_c: usart2-sleep-2 {
 		pins {
 			pinmux = <STM32_PINMUX('D', 5, ANALOG)>, /* USART2_TX */
-				 <STM32_PINMUX('D', 4, ANALOG)>, /* USART2_RTS */
-				 <STM32_PINMUX('D', 6, ANALOG)>, /* USART2_RX */
-				 <STM32_PINMUX('D', 3, ANALOG)>; /* USART2_CTS_NSS */
+				 <STM32_PINMUX('D', 6, ANALOG)>; /* USART2_RX */
 		};
 	};
 
@@ -2139,15 +2152,15 @@ pins {
 
 	usart3_pins_c: usart3-2 {
 		pins1 {
-			pinmux = <STM32_PINMUX('B', 10, AF7)>, /* USART3_TX */
-				 <STM32_PINMUX('G', 8, AF8)>; /* USART3_RTS */
+			pinmux = <STM32_PINMUX('B', 10, AF7)>; /* USART3_TX */
+				/* <STM32_PINMUX('G', 8, AF8)>; USART3_RTS */
 			bias-disable;
 			drive-push-pull;
 			slew-rate = <0>;
 		};
 		pins2 {
-			pinmux = <STM32_PINMUX('B', 12, AF8)>, /* USART3_RX */
-				 <STM32_PINMUX('B', 13, AF7)>; /* USART3_CTS_NSS */
+			pinmux = <STM32_PINMUX('B', 12, AF8)>; /* USART3_RX */
+				 /* <STM32_PINMUX('B', 13, AF7)>;  USART3_CTS_NSS */
 			bias-pull-up;
 		};
 	};
@@ -2178,16 +2191,16 @@ pins {
 		};
 	};
 
-	usbotg_hs_pins_a: usbotg-hs-0 {
+	usbotg_fs_dp_dm_pins_a: usbotg-fs-dp-dm-0 {
 		pins {
-			pinmux = <STM32_PINMUX('A', 10, ANALOG)>; /* OTG_ID */
+			pinmux = <STM32_PINMUX('A', 11, ANALOG)>, /* OTG_FS_DM */
+				 <STM32_PINMUX('A', 12, ANALOG)>; /* OTG_FS_DP */
 		};
 	};
 
-	usbotg_fs_dp_dm_pins_a: usbotg-fs-dp-dm-0 {
+	usbotg_hs_pins_a: usbotg-hs-0 {
 		pins {
-			pinmux = <STM32_PINMUX('A', 11, ANALOG)>, /* OTG_FS_DM */
-				 <STM32_PINMUX('A', 12, ANALOG)>; /* OTG_FS_DP */
+			pinmux = <STM32_PINMUX('A', 10, ANALOG)>; /* OTG_ID */
 		};
 	};
 };
@@ -2264,4 +2277,24 @@ pins {
 				 <STM32_PINMUX('Z', 2, ANALOG)>; /* SPI1_MOSI */
 		};
 	};
+
+		usart1_pins_a: usart1-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('Z', 7, AF7)>; /* USART1_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('Z', 6, AF7)>; /* USART1_RX */
+			bias-disable;
+		};
+	};
+
+	usart1_sleep_pins_a: usart1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 7, ANALOG)>, /* USART2_TX */
+				 <STM32_PINMUX('Z', 6, ANALOG)>; /* USART2_RX */
+		};
+	};
 };
diff --git a/arch/arm/boot/dts/stm32mp151c-dn-som.dts b/arch/arm/boot/dts/stm32mp151c-dn-som.dts
new file mode 100644
index 000000000..c055aad50
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp151c-dn-som.dts
@@ -0,0 +1,942 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Mateus Pantoja and Matheus Assunção for HUB-LSE, Diebold
+ */
+
+/* For more information on Device Tree configuration, please refer to
+ * https://wiki.st.com/stm32mpu/wiki/Category:Device_tree_configuration
+ */
+
+/dts-v1/;
+
+#include "stm32mp151.dtsi" 
+#include "stm32mp15xc.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxac-pinctrl.dtsi"
+#include "stm32mp15-m4-srm.dtsi"
+#include "stm32mp15-m4-srm-pinctrl.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/mfd/st,stpmic1.h>
+#include <dt-bindings/rtc/rtc-stm32.h>
+
+
+
+/ {
+	model = "DN-SOM by LSE 2023";
+	compatible = "lse,stm32mp151c-dn-som", "lse,stm32mp151";
+
+	aliases {
+		ethernet0 = &ethernet0;
+		serial0 = &uart4;
+		serial1 = &usart2;
+		serial2 = &usart3;
+		//serial3 = &usart1;
+	};
+
+	clocks {
+		clk8M: clk8M {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <8000000>;
+		};
+	};
+
+	sph0645: sph0645@1 {
+		 	compatible = "st,stm32mp1-audio-sph0645";
+			model = "sph0645-audio";
+			cpu-dai = <&sai2>;
+			status = "okay";
+	};
+
+	// sound {
+	// 	compatible = "simple-audio-card";
+	// 	simple-audio-card,name = "sph0645";
+	// 	// simple-audio-card,format = "i2s";
+	// 	// simple-audio-card,bit-format = "s32_be";
+	// 	// simple-audio-card,bitclock-master = <&dailink_master2>;
+	// 	// simple-audio-card,frame-master = <&dailink_master2>;
+
+		
+	// 	simple-audio-card,dai-link@0 {
+	// 		/* DAC */
+	// 		format = "i2s";
+	// 		dai-tdm-slot-width = <32>;
+	// 		cpu {
+	// 			sound-dai = <&sai2a>;
+	// 		};
+
+	// 		codec {
+	// 			sound-dai = <&sph0645>;
+	// 		};
+	// 	};
+
+
+    // };
+
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebbs=1M conv=fdatasync status=progressuffer";
+			clocks = <&rcc LTDC_PX>;
+			status = "disabled";
+		};
+	};
+
+	memory@c0000000 {
+		device_type = "memory";
+		reg = <0xc0000000 0x20000000>;
+
+	};
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		mcuram2: mcuram2@10000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10000000 0x40000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@10040000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10040000 0x1000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@10041000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10041000 0x1000>;
+			no-map;
+		};
+
+		vdev0buffer: vdev0buffer@10042000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10042000 0x4000>;
+			no-map;
+		};
+
+		mcu_rsc_table: mcu_rsc_table@10048000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10048000 0x8000>;
+			no-map;
+		};
+
+		mcuram: mcuram@30000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x30000000 0x40000>;
+			no-map;
+		};
+
+		retram: retram@38000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x38000000 0x10000>;
+			no-map;
+		};
+
+		// gpu_reserved: gpu@d4000000 {
+		// 	reg = <0xd4000000 0x4000000>;
+		// 	no-map;
+		// };
+
+		optee@de000000 {
+			reg = <0xde000000 0x2000000>;
+			no-map;
+		};
+	};
+
+	vin: vin {
+		compatible = "regulator-fixed";
+		regulator-name = "vin";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+	};
+
+	reg_3v3: regulator-3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "3.3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	reg_5v0: regulator-5v0 {
+		compatible = "regulator-fixed";
+		regulator-name = "5V";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+	};
+
+	panel_backlight: panel-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpioe 11 GPIO_ACTIVE_LOW>;
+		default-on;
+		status = "okay";
+	};
+
+}; 
+
+
+&adc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&adc12_ain_pins_a>;
+	vdd-supply = <&vdd>;
+	vdda-supply = <&vdd>;
+	vref-supply = <&vrefbuf>;
+	status = "okay";
+	
+	adc1: adc@0 {
+		compatible = "st,stm32mp1-adc";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		/* private resources for ADC1 */
+		/* Diferential channel*/
+		status = "okay";	/* Enable ADC1*/
+
+		channel@1 {
+			reg = <1>;			/* ADC1 inp1 and inn1 */
+			diff-channels = <1 0>;
+			st,min-sample-time-ns = <10000>;	/* 10us sampling time */
+		};
+
+	};
+
+	adc2: adc@100 {
+		compatible = "st,stm32mp1-adc";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		/* private resources for ADC2 */
+		status = "okay";	/* Enable ADC2*/
+
+		channel@2 {
+			reg = <2>;			/* ADC2 */
+			diff-channels = <2 1>;
+			st,min-sample-time-ns = <10000>;	/* 10us sampling time */
+		};
+		
+	};
+};
+
+&cec{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&cec_pins_b>;
+	pinctrl-1 = <&cec_sleep_pins_b>;
+	status = "okay";
+
+};
+
+&cpu0{
+	cpu-supply = <&vddcore>;
+};
+
+// &cpu1{
+// 	cpu-supply = <&vddcore>;
+// };
+
+&crc1 {
+	status = "okay";
+};
+
+&cryp1 {
+	status = "okay";
+};
+
+&dac{
+	pinctrl-names = "default";
+	pinctrl-0 = <&dac_ch2_pins_a>;
+	vref-supply = <&vrefbuf>; 
+	status = "okay";
+
+	dac2: dac@2 {
+		status = "okay"; /* Enable DAC2 */
+	};
+
+};
+
+&dma1{
+	sram = <&dma_pool>;
+
+};
+
+&dma2{
+	sram = <&dma_pool>;
+
+};
+
+// &dsi {
+// 	status = "okay";
+
+// 	ports {
+// 		port@0 {
+// 			reg = <0>;
+// 			dsi_in: endpoint {
+// 				remote-endpoint = <&ltdc_ep1_out>;
+// 			};
+// 		};
+
+// 		port@1 {
+// 			reg = <1>;
+// 			dsi_out: endpoint {
+// 				remote-endpoint = <&panel_in>;
+// 			};
+// 		};
+// 	};
+
+// 	panel_otm8009a: panel-otm8009a@0 {
+// 		compatible = "orisetech,otm8009a";
+// 		reg = <0>;
+// 		reset-gpios = <&gpioe 4 GPIO_ACTIVE_LOW>;
+// 		backlight = <&panel_backlight>;
+// 		power-supply = <&v3v3>;
+// 		status = "okay";
+
+// 		port {
+// 			panel_in: endpoint {
+// 				remote-endpoint = <&dsi_out>;
+// 			};
+// 		};
+// 	};
+// };
+
+&dts {
+	status = "okay";
+};
+
+&ethernet0{
+	status = "okay";
+	pinctrl-0 = <&ethernet0_rgmii_pins_a>;
+	pinctrl-1 = <&ethernet0_rgmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii-id";
+	max-speed = <1000>;
+	phy-handle = <&phy0>;
+	nvmem-cells = <&ethernet_mac_address>;
+	nvmem-cell-names = "mac-address";
+
+	mdio0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy0: ethernet-phy@0 {
+			reg = <0>;
+		};
+	};
+};
+
+// &gpu {
+// 	contiguous-area = <&gpu_reserved>;
+// };
+
+&hash1 {
+	status = "okay";
+};
+
+&i2c1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c1_pins_a>;
+	pinctrl-1 = <&i2c1_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <100>;
+	i2c-scl-falling-time-ns = <7>;
+	status = "okay";
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	// touchscreen@38 {
+	// 	compatible = "focaltech,ft6236";
+	// 	reg = <0x38>;
+	// 	interrupts = <2 2>;
+	// 	interrupt-parent = <&gpiof>;
+	// 	interrupt-controller;
+	// 	touchscreen-size-x = <480>;
+	// 	touchscreen-size-y = <800>;
+	// 	panel = <&panel_otm8009a>;
+	// 	vcc-supply = <&v3v3>;
+	// 	iovcc-supply = <&v3v3>;
+	// 	status = "okay";
+	// };
+
+	hdmi-transmitter@39 {
+		compatible = "sil,sii9022";
+		reg = <0x39>;
+		iovcc-supply = <&v3v3_hdmi>;
+		cvcc12-supply = <&v1v2_hdmi>;
+		reset-gpios = <&gpioa 10 GPIO_ACTIVE_LOW>;
+		interrupts = <1 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-parent = <&gpiog>;
+		#sound-dai-cells = <0>;
+		status = "okay";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				sii9022_in: endpoint {
+					remote-endpoint = <&ltdc_ep0_out>;
+				};
+			};
+
+			port@3 {
+				reg = <3>;
+				sii9022_tx_endpoint: endpoint {
+					remote-endpoint = <&i2s2_endpoint>;
+				};
+			};
+		};
+	};
+
+	usb2514b@2c {
+		compatible = "microchip,usb2514b";
+		reg = <0x2c>;
+		vendor-id = /bits/ 16 <0x000a>;
+		product-id = /bits/ 16 <0x0007>;
+		string-support;
+		manufacturer = "LSE";
+		product = "DN-SOM";
+		serial = "15121997MTP";
+		/* correct misplaced usb connectors on port 1,2 */
+		swap-dx-lanes = <1 2>;
+	};
+
+	// cs42l51: cs42l51@4a {
+	// 	compatible = "cirrus,cs42l51";
+	// 	reg = <0x4a>;
+	// 	#sound-dai-cells = <0>;
+	// 	VL-supply = <&v3v3>;
+	// 	VD-supply = <&v1v8_audio>;
+	// 	VA-supply = <&v1v8_audio>;
+	// 	VAHP-supply = <&v1v8_audio>;
+	// 	reset-gpios = <&gpiog 9 GPIO_ACTIVE_LOW>;
+	// 	clocks = <&sai2a>;
+	// 	clock-names = "MCLK";
+	// 	status = "disabled";
+
+	// 	cs42l51_port: port {
+	// 		#address-cells = <1>;
+	// 		#size-cells = <0>;
+
+	// 		cs42l51_tx_endpoint: endpoint@0 {
+	// 			reg = <0>;
+	// 			remote-endpoint = <&sai2a_endpoint>;
+	// 			frame-master = <&cs42l51_tx_endpoint>;
+	// 			bitclock-master = <&cs42l51_tx_endpoint>;
+	// 		};
+
+	// 		cs42l51_rx_endpoint: endpoint@1 {
+	// 			reg = <1>;
+	// 			remote-endpoint = <&sai2b_endpoint>;
+	// 			frame-master = <&cs42l51_rx_endpoint>;
+	// 			bitclock-master = <&cs42l51_rx_endpoint>;
+	// 		};
+	// 	};
+	// };
+
+
+
+};
+
+&i2c4 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c4_pins_a>;
+	pinctrl-1 = <&i2c4_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	clock-frequency = <400000>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	expansor-gpio@2a{
+		compatible = "expansor-gpio";
+		reg =<0x2a>;
+	};
+
+
+	pmic: stpmic@33 {
+		compatible = "st,stpmic1";
+		reg = <0x33>;
+		interrupts-extended = <&exti_pwr 55 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		status = "okay";
+
+		regulators {
+			compatible = "st,stpmic1-regulators";
+			buck1-supply = <&vin>;
+			buck2-supply = <&vin>;
+			buck3-supply = <&vin>;
+			buck4-supply = <&vin>;
+			ldo1-supply = <&v3v3>;
+			ldo2-supply = <&vin>;
+			ldo3-supply = <&vdd_ddr>;
+			ldo4-supply = <&vin>;
+			ldo5-supply = <&vin>;
+			ldo6-supply = <&v3v3>;
+			vref_ddr-supply = <&vin>;
+			boost-supply = <&vin>;
+			pwr_sw1-supply = <&bst_out>;
+			pwr_sw2-supply = <&bst_out>;
+
+			vddcore: buck1 {
+				regulator-name = "vddcore";
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd_ddr: buck2 {
+				regulator-name = "vdd_ddr";
+				regulator-min-microvolt = <1350000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd: buck3 {
+				regulator-name = "vdd";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				st,mask-reset;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			v3v3: buck4 {
+				regulator-name = "v3v3";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+				regulator-initial-mode = <0>;
+			};
+
+			v1v8_audio: ldo1 {
+				regulator-name = "v1v8_audio";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				interrupts = <IT_CURLIM_LDO1 0>;
+			};
+
+			v3v3_hdmi: ldo2 {
+				regulator-name = "v3v3_hdmi";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				interrupts = <IT_CURLIM_LDO2 0>;
+			};
+
+			vtt_ddr: ldo3 {
+				regulator-name = "vtt_ddr";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <750000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+			};
+
+			vdd_usb: ldo4 {
+				regulator-name = "vdd_usb";
+				interrupts = <IT_CURLIM_LDO4 0>;
+			};
+
+			vdda: ldo5 {
+				regulator-name = "vdda";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				interrupts = <IT_CURLIM_LDO5 0>;
+				regulator-boot-on;
+			};
+
+			v1v2_hdmi: ldo6 {
+				regulator-name = "v1v2_hdmi";
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <1200000>;
+				regulator-always-on;
+				interrupts = <IT_CURLIM_LDO6 0>;
+			};
+
+			vref_ddr: vref_ddr {
+				regulator-name = "vref_ddr";
+				regulator-always-on;
+			};
+
+			bst_out: boost {
+				regulator-name = "bst_out";
+				interrupts = <IT_OCP_BOOST 0>;
+			};
+
+			vbus_otg: pwr_sw1 {
+				regulator-name = "vbus_otg";
+				interrupts = <IT_OCP_OTG 0>;
+			};
+
+			vbus_sw: pwr_sw2 {
+				regulator-name = "vbus_sw";
+				interrupts = <IT_OCP_SWOUT 0>;
+				regulator-active-discharge = <1>;
+			};
+		};
+
+		onkey {
+			compatible = "st,stpmic1-onkey";
+			interrupts = <IT_PONKEY_F 0>, <IT_PONKEY_R 0>;
+			interrupt-names = "onkey-falling", "onkey-rising";
+			power-off-time-sec = <10>;
+			status = "okay";
+		};
+
+		watchdog {
+			compatible = "st,stpmic1-wdt";
+			status = "disabled";
+		};
+	};
+};
+
+&i2c5{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c5_pins_a>;
+	pinctrl-1 = <&i2c5_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <100>;
+	i2c-scl-falling-time-ns = <7>;
+	status = "okay";
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+};
+
+&ipcc {
+	status = "okay";
+};
+
+&iwdg2 {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&ltdc {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&ltdc_pins_a>;
+	pinctrl-1 = <&ltdc_sleep_pins_a>;
+	status = "okay";
+	
+	port {
+		ltdc_ep0_out: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&sii9022_in>;
+		};
+	};
+
+	// port {
+	// 	ltdc_ep1_out: endpoint@1 {
+	// 		reg = <1>;
+	// 		remote-endpoint = <&dsi_in>;
+	// 		};
+	// 	};
+};
+
+// &m_can1{
+// 	pinctrl-names = "default", "sleep";
+// 	pinctrl-0 = <&m_can1_pins_a>;
+// 	pinctrl-1 = <&m_can1_sleep_pins_a>;
+// 	status = "okay";
+
+// };
+
+&m4_rproc{
+	memory-region = <&retram>, <&mcuram>, <&mcuram2>, <&vdev0vring0>,
+			<&vdev0vring1>, <&vdev0buffer>, <&mcu_rsc_table>;
+	mboxes = <&ipcc 0>, <&ipcc 1>, <&ipcc 2>, <&ipcc 3>;
+	mbox-names = "vq0", "vq1", "shutdown", "detach";
+	interrupt-parent = <&exti>;
+	interrupts = <68 1>;
+	wakeup-source;
+	status = "okay";
+
+};
+
+&pwr_regulators{
+	vdd-supply = <&vdd>;
+	vdd_3v3_usbfs-supply = <&vdd_usb>;
+
+};
+
+
+&rtc {
+	st,lsco = <RTC_OUT2_RMP>;
+	pinctrl-0 = <&rtc_out2_rmp_pins_a>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&sdmmc1{
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_b4_pins_a>;
+	pinctrl-1 = <&sdmmc1_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a>;
+	cd-gpios = <&gpiob 7 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	disable-wp;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&v3v3>;
+	status = "okay";
+
+};
+
+
+&sdmmc2{
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a &sdmmc2_d47_sleep_pins_a>;
+	non-removable;                                        
+	no-sd;                                               
+	no-sdio;                                              
+	st,neg-edge;                                           
+	bus-width = <8>;                                    
+	vmmc-supply = <&v3v3>;                      
+	vqmmc-supply = <&vdd>;
+	mmc-ddr-3_3v;                                                              
+	status = "okay";
+
+};
+
+&spi1{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi1_pins_a>;
+	pinctrl-1 = <&spi1_sleep_pins_a>;
+	cs-gpios = <&gpioz 3 1>;
+	status = "okay";
+
+	spidev@0{
+		status = "disabled";
+        compatible = "linux,spidev";
+        reg = <0>;
+        spi-max-frequency = <4000000>;
+    };
+
+	can0: can@0 {
+		compatible = "microchip,mcp2515";
+		reg = <0>;
+		clocks = <&clk8M>;
+		interrupt-parent = <&gpiog>;
+		interrupts = <3 IRQ_TYPE_LEVEL_LOW>;
+		vdd-supply = <&reg_3v3>;
+		xceiver-supply = <&reg_5v0>;
+		spi-max-frequency = <10000000>;
+		status = "disabled";
+	};
+
+};
+
+&sram {
+	dma_pool: dma_pool@0 {
+		reg = <0x50000 0x10000>;
+		pool;
+	};
+};
+
+
+&timers3{
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+
+	pwm1: pwm{
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&pwm3_pins_a>;
+		pinctrl-1 = <&pwm3_sleep_pins_a>;
+		status = "okay";
+
+	};
+
+};
+
+&timers5{
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+
+	pwm2:pwm {
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&pwm5_pins_a>;
+		pinctrl-1 = <&pwm5_sleep_pins_a>;
+		status = "okay";
+
+	};
+
+};
+
+&uart4 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&uart4_pins_a>;
+	pinctrl-1 = <&uart4_sleep_pins_a>;
+	pinctrl-2 = <&uart4_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&usart1{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&usart1_pins_a>;
+	pinctrl-1 = <&usart1_sleep_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+
+};
+
+&usart2{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&usart2_pins_c>;
+	pinctrl-1 = <&usart2_sleep_pins_c>;
+	status = "okay";
+
+};
+
+&usart3{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&usart3_pins_c>;
+	pinctrl-1 = <&usart3_sleep_pins_c>;
+	uart-has-rtscts;
+	status = "okay";
+
+};
+
+&usbh_ehci {
+	phys = <&usbphyc_port0>;
+	status = "okay";
+};
+
+&usbotg_hs {
+	compatible = "st,stm32mp15-hsotg", "snps,dwc2";
+	phys = <&usbphyc_port1 0>;                                                /* 0: UTMI switch selects the OTG controller */
+	phy-names = "usb2-phy";
+	dr_mode = "peripheral";                                                   /* could be "host", see USB generic bindings [4] */
+	usb-role-switch;                                                          /* see USB generic bindings [4] */
+	role-switch-default-mode = "peripheral";                                  /* could be "host", see USB generic bindings [4] */
+	status = "okay";                                                          /* enable OTG */
+};
+
+&usbphyc {
+	status = "okay";
+};
+
+&usbphyc_port0 {
+	phy-supply = <&vdd_usb>;
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
+
+	/*
+	 * Hack to keep hub active until all connected devices are suspended
+	 * otherwise the hub will be powered off as soon as the v3v3 is disabled
+	 * and it can disturb connected devices.
+	 */
+	connector {
+		compatible = "usb-a-connector";
+		vbus-supply = <&v3v3>;
+	};
+};
+
+&usbphyc_port1 {
+	phy-supply = <&vdd_usb>;
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
+};
+
+&vrefbuf {
+	regulator-min-microvolt = <2500000>;
+	regulator-max-microvolt = <2500000>;
+	vdda-supply = <&vdd>;
+	status = "okay";
+};
+
+
+&i2s2 {
+	clocks = <&rcc SPI2>, <&rcc SPI2_K>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	clock-names = "pclk", "i2sclk", "x8k", "x11k";
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2s2_pins_a>;
+	pinctrl-1 = <&i2s2_sleep_pins_a>;
+	status = "okay";
+
+	i2s2_port: port {
+		i2s2_endpoint: endpoint {
+			remote-endpoint = <&sii9022_tx_endpoint>;
+			format = "i2s";
+			mclk-fs = <256>;
+		};
+	};
+};
+
+
+&sai2 {
+	clocks = <&rcc SAI2>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	clock-names = "pclk", "x8k", "x11k";
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sai2a_pins_a>; //<&sai2a_pins_a>, <&sai2b_pins_b>;
+	pinctrl-1 = <&sai2a_sleep_pins_a>; // <&sai2a_sleep_pins_a>, <&sai2b_sleep_pins_b>;
+	status = "okay";
+	
+
+	sai2a: audio-controller@4400b004 {
+		compatible = "st,stm32-sai-sub-a";
+		#clock-cells = <0>;
+		dma-names = "rx";
+		status = "okay";
+
+		// sai2a_port: port {
+		// 	sai2a_endpoint: endpoint {
+		// 		remote-endpoint = <&sph0645>;
+		// 		format = "i2s";
+		// 		mclk-fs = <256>;
+		// 		dai-tdm-slot-num = <2>;
+		// 		dai-tdm-slot-width = <32>;
+		// 	};
+		// };
+	};
+
+	// sai2b: audio-controller@4400b024 {
+	// 	dma-names = "rx";
+	// 	st,sync = <&sai2a 2>;
+	// 	clocks = <&rcc SAI2_K>, <&sai2a>;
+	// 	clock-names = "sai_ck", "MCLK";
+	// 	status = "okay";
+
+	// 	// sai2b_port: port {
+	// 	// 	sai2b_endpoint: endpoint {
+	// 	// 		remote-endpoint = <&cs42l51_rx_endpoint>;
+	// 	// 		format = "i2s";
+	// 	// 		mclk-fs = <256>;
+	// 	// 		dai-tdm-slot-num = <2>;
+	// 	// 		dai-tdm-slot-width = <32>;
+	// 	// 	};
+	// 	// };
+	// };
+};
\ No newline at end of file
diff --git a/arch/arm/boot/dts/stm32mp157f-dn-som.dts b/arch/arm/boot/dts/stm32mp157f-dn-som.dts
new file mode 100644
index 000000000..e0e3f9496
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157f-dn-som.dts
@@ -0,0 +1,986 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Mateus Pantoja and Matheus Assunção for HUB-LSE, Diebold
+ */
+
+/* For more information on Device Tree configuration, please refer to
+ * https://wiki.st.com/stm32mpu/wiki/Category:Device_tree_configuration
+ */
+
+/dts-v1/;
+
+#include "stm32mp157.dtsi" 
+#include "stm32mp15xf.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxac-pinctrl.dtsi"
+#include "stm32mp15-m4-srm.dtsi"
+#include "stm32mp15-m4-srm-pinctrl.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/mfd/st,stpmic1.h>
+#include <dt-bindings/rtc/rtc-stm32.h>
+
+
+
+/ {
+	model = "DN-SOM by LSE 2023";
+	compatible = "lse,stm32mp157f-dn-som", "lse,stm32mp157";
+
+	aliases {
+		ethernet0 = &ethernet0;
+		serial0 = &usart1; //Quando estamos usando a TPD
+		serial1 = &uart4; //Quanndo usado o Kit
+		serial2 = &usart2;
+		serial3 = &usart3;
+	};
+
+	clocks {
+		clk8M: clk8M {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <8000000>;
+		};
+
+		edp_refclk: edp-refclk {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <19200000>;
+		};
+	};
+
+
+	sph0645: sph0645@1 {
+		 	compatible = "st,stm32mp1-audio-sph0645";
+			model = "sph0645-audio";
+			cpu-dai = <&sai2>;
+			status = "okay";
+	};
+
+	// sound {
+	// 	compatible = "simple-audio-card";
+	// 	simple-audio-card,name = "sph0645";
+	// 	// simple-audio-card,format = "i2s";
+	// 	// simple-audio-card,bit-format = "s32_be";
+	// 	// simple-audio-card,bitclock-master = <&dailink_master2>;
+	// 	// simple-audio-card,frame-master = <&dailink_master2>;
+
+		
+	// 	simple-audio-card,dai-link@0 {
+	// 		/* DAC */
+	// 		format = "i2s";
+	// 		dai-tdm-slot-width = <32>;
+	// 		cpu {
+	// 			sound-dai = <&sai2a>;
+	// 		};
+
+	// 		codec {
+	// 			sound-dai = <&sph0645>;
+	// 		};
+	// 	};
+
+
+    // };
+
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebbs=1M conv=fdatasync status=progressuffer";
+			clocks = <&rcc LTDC_PX>;
+			status = "disabled";
+		};
+	};
+
+	memory@c0000000 {
+		device_type = "memory";
+		reg = <0xc0000000 0x20000000>;
+
+	};
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		mcuram2: mcuram2@10000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10000000 0x40000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@10040000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10040000 0x1000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@10041000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10041000 0x1000>;
+			no-map;
+		};
+
+		vdev0buffer: vdev0buffer@10042000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10042000 0x4000>;
+			no-map;
+		};
+
+		mcu_rsc_table: mcu_rsc_table@10048000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10048000 0x8000>;
+			no-map;
+		};
+
+		mcuram: mcuram@30000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x30000000 0x40000>;
+			no-map;
+		};
+
+		retram: retram@38000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x38000000 0x10000>;
+			no-map;
+		};
+
+		gpu_reserved: gpu@d4000000 {
+			reg = <0xd4000000 0x4000000>;
+			no-map;
+		};
+
+		optee@de000000 {
+			reg = <0xde000000 0x2000000>;
+			no-map;
+		};
+	};
+
+	vin: vin {
+		compatible = "regulator-fixed";
+		regulator-name = "vin";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+	};
+
+	reg_3v3: regulator-3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "3.3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	reg_1v2: regulator-1v2 {
+		compatible = "regulator-fixed";
+		regulator-name = "1.2V";
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+	};
+
+	reg_5v0: regulator-5v0 {
+		compatible = "regulator-fixed";
+		regulator-name = "5V";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+	};
+
+	panel_backlight: panel-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpioe 11 GPIO_ACTIVE_LOW>;
+		default-on;
+		status = "disabled";
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		onboard-led {
+			label = "Heartbeat";
+			gpios = <&gpiof 5 GPIO_ACTIVE_LOW>;
+			linux,default-trigger = "heartbeat";
+		};
+
+	};
+	
+}; 
+
+
+&adc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&adc12_ain_pins_a>;
+	vdd-supply = <&vdd>;
+	vdda-supply = <&vdd>;
+	vref-supply = <&vrefbuf>;
+	status = "disabled";
+	
+	adc1: adc@0 {
+		compatible = "st,stm32mp1-adc";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		/* private resources for ADC1 */
+		/* Diferential channel*/
+		status = "okay";	/* Enable ADC1*/
+
+		channel@1 {
+			reg = <1>;			/* ADC1 inp1 and inn1 */
+			diff-channels = <1 0>;
+			st,min-sample-time-ns = <10000>;	/* 10us sampling time */
+		};
+
+	};
+
+	adc2: adc@100 {
+		compatible = "st,stm32mp1-adc";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		/* private resources for ADC2 */
+		status = "okay";	/* Enable ADC2*/
+
+		channel@2 {
+			reg = <2>;			/* ADC2 */
+			diff-channels = <2 1>;
+			st,min-sample-time-ns = <10000>;	/* 10us sampling time */
+		};
+		
+	};
+};
+
+&cec{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&cec_pins_b>;
+	pinctrl-1 = <&cec_sleep_pins_b>;
+	status = "okay";
+
+};
+
+&cpu0{
+	cpu-supply = <&vddcore>;
+};
+
+&cpu1{
+	cpu-supply = <&vddcore>;
+};
+
+&crc1 {
+	status = "okay";
+};
+
+&cryp1 {
+	status = "okay";
+};
+
+&dac{
+	pinctrl-names = "default";
+	pinctrl-0 = <&dac_ch2_pins_a>;
+	vref-supply = <&vrefbuf>; 
+	status = "disabled";
+
+	dac2: dac@2 {
+		status = "okay"; /* Enable DAC2 */
+	};
+
+};
+
+&dma1{
+	sram = <&dma_pool>;
+
+};
+
+&dma2{
+	sram = <&dma_pool>;
+
+};
+
+&dsi {
+	status = "okay";
+
+	ports {
+		port@0 {
+			reg = <0>;
+			dsi_in: endpoint {
+				remote-endpoint = <&ltdc_ep1_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			dsi_out: endpoint {
+				remote-endpoint = <&panel_in>;
+			};
+		};
+	};
+
+	panel_otm8009a: panel-otm8009a@0 {
+		compatible = "orisetech,otm8009a";
+		reg = <0>;
+		reset-gpios = <&gpioe 4 GPIO_ACTIVE_LOW>;
+		power-supply = <&v3v3>;
+		status = "okay";
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+
+};
+
+&dts {
+	status = "okay";
+};
+
+&ethernet0{
+	status = "okay";
+	pinctrl-0 = <&ethernet0_rgmii_pins_a>;
+	pinctrl-1 = <&ethernet0_rgmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii-id";
+	max-speed = <1000>;
+	phy-handle = <&phy0>;
+	nvmem-cells = <&ethernet_mac_address>;
+	nvmem-cell-names = "mac-address";
+
+	mdio0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy0: ethernet-phy@0 {
+			reg = <0>;
+		};
+	};
+};
+
+&gpu {
+	contiguous-area = <&gpu_reserved>;
+};
+
+&hash1 {
+	status = "okay";
+};
+
+&i2c1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c1_pins_a>;
+	pinctrl-1 = <&i2c1_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <100>;
+	i2c-scl-falling-time-ns = <7>;
+	status = "okay";
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	// touchscreen@38 {
+	// 	compatible = "focaltech,ft6236";
+	// 	reg = <0x38>;
+	// 	interrupts = <2 2>;
+	// 	interrupt-parent = <&gpiof>;
+	// 	interrupt-controller;
+	// 	touchscreen-size-x = <480>;
+	// 	touchscreen-size-y = <800>;
+	// 	panel = <&panel_otm8009a>;
+	// 	vcc-supply = <&v3v3>;
+	// 	iovcc-supply = <&v3v3>;
+	// 	status = "disabled";
+	// };
+
+	hdmi-transmitter@39 {
+		compatible = "sil,sii9022";
+		reg = <0x39>;
+		iovcc-supply = <&v3v3_hdmi>;
+		cvcc12-supply = <&v1v2_hdmi>;
+		reset-gpios = <&gpioa 10 GPIO_ACTIVE_LOW>;
+		interrupts = <1 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-parent = <&gpiog>;
+		#sound-dai-cells = <0>;
+		status = "disabled";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				sii9022_in: endpoint {
+					remote-endpoint = <&ltdc_ep0_out>;
+				};
+			};
+
+			port@3 {
+				reg = <3>;
+				sii9022_tx_endpoint: endpoint {
+					remote-endpoint = <&i2s2_endpoint>;
+				};
+			};
+		};
+	};
+
+	usb2514b@2c {
+		compatible = "microchip,usb2514b";
+		reg = <0x2c>;
+		vendor-id = /bits/ 16 <0x000a>;
+		product-id = /bits/ 16 <0x0007>;
+		string-support;
+		manufacturer = "LSE";
+		product = "DN-SOM";
+		serial = "15121997MTP";
+		/* correct misplaced usb connectors on port 1,2 */
+		swap-dx-lanes = <1 2>;
+	};
+
+	// cs42l51: cs42l51@4a {
+	// 	compatible = "cirrus,cs42l51";
+	// 	reg = <0x4a>;
+	// 	#sound-dai-cells = <0>;
+	// 	VL-supply = <&v3v3>;
+	// 	VD-supply = <&v1v8_audio>;
+	// 	VA-supply = <&v1v8_audio>;
+	// 	VAHP-supply = <&v1v8_audio>;
+	// 	reset-gpios = <&gpiog 9 GPIO_ACTIVE_LOW>;
+	// 	clocks = <&sai2a>;
+	// 	clock-names = "MCLK";
+	// 	status = "disabled";
+
+	// 	cs42l51_port: port {
+	// 		#address-cells = <1>;
+	// 		#size-cells = <0>;
+
+	// 		cs42l51_tx_endpoint: endpoint@0 {
+	// 			reg = <0>;
+	// 			remote-endpoint = <&sai2a_endpoint>;
+	// 			frame-master = <&cs42l51_tx_endpoint>;
+	// 			bitclock-master = <&cs42l51_tx_endpoint>;
+	// 		};
+
+	// 		cs42l51_rx_endpoint: endpoint@1 {
+	// 			reg = <1>;
+	// 			remote-endpoint = <&sai2b_endpoint>;
+	// 			frame-master = <&cs42l51_rx_endpoint>;
+	// 			bitclock-master = <&cs42l51_rx_endpoint>;
+	// 		};
+	// 	};
+	// };
+
+
+
+};
+
+&i2c4 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c4_pins_a>;
+	pinctrl-1 = <&i2c4_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	clock-frequency = <400000>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	expansor-gpio@2a{
+		compatible = "expansor-gpio";
+		reg =<0x2a>;
+	};
+
+
+	pmic: stpmic@33 {
+		compatible = "st,stpmic1";
+		reg = <0x33>;
+		interrupts-extended = <&exti_pwr 55 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		status = "okay";
+
+		regulators {
+			compatible = "st,stpmic1-regulators";
+			buck1-supply = <&vin>;
+			buck2-supply = <&vin>;
+			buck3-supply = <&vin>;
+			buck4-supply = <&vin>;
+			ldo1-supply = <&v3v3>;
+			ldo2-supply = <&vin>;
+			ldo3-supply = <&vdd_ddr>;
+			ldo4-supply = <&vin>;
+			ldo5-supply = <&vin>;
+			ldo6-supply = <&v3v3>;
+			vref_ddr-supply = <&vin>;
+			boost-supply = <&vin>;
+			pwr_sw1-supply = <&bst_out>;
+			pwr_sw2-supply = <&bst_out>;
+
+			vddcore: buck1 {
+				regulator-name = "vddcore";
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd_ddr: buck2 {
+				regulator-name = "vdd_ddr";
+				regulator-min-microvolt = <1350000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd: buck3 {
+				regulator-name = "vdd";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				st,mask-reset;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			v3v3: buck4 {
+				regulator-name = "v3v3";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+				regulator-initial-mode = <0>;
+			};
+
+			v1v8_audio: ldo1 {
+				regulator-name = "v1v8_audio";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				interrupts = <IT_CURLIM_LDO1 0>;
+			};
+
+			v3v3_hdmi: ldo2 {
+				regulator-name = "v3v3_hdmi";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				interrupts = <IT_CURLIM_LDO2 0>;
+			};
+
+			vtt_ddr: ldo3 {
+				regulator-name = "vtt_ddr";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <750000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+			};
+
+			vdd_usb: ldo4 {
+				regulator-name = "vdd_usb";
+				interrupts = <IT_CURLIM_LDO4 0>;
+			};
+
+			vdda: ldo5 {
+				regulator-name = "vdda";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				interrupts = <IT_CURLIM_LDO5 0>;
+				regulator-boot-on;
+			};
+
+			v1v2_hdmi: ldo6 {
+				regulator-name = "v1v2_hdmi";
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <1200000>;
+				regulator-always-on;
+				interrupts = <IT_CURLIM_LDO6 0>;
+			};
+
+			vref_ddr: vref_ddr {
+				regulator-name = "vref_ddr";
+				regulator-always-on;
+			};
+
+			bst_out: boost {
+				regulator-name = "bst_out";
+				interrupts = <IT_OCP_BOOST 0>;
+			};
+
+			vbus_otg: pwr_sw1 {
+				regulator-name = "vbus_otg";
+				interrupts = <IT_OCP_OTG 0>;
+			};
+
+			vbus_sw: pwr_sw2 {
+				regulator-name = "vbus_sw";
+				interrupts = <IT_OCP_SWOUT 0>;
+				regulator-active-discharge = <1>;
+			};
+		};
+
+		onkey {
+			compatible = "st,stpmic1-onkey";
+			interrupts = <IT_PONKEY_F 0>, <IT_PONKEY_R 0>;
+			interrupt-names = "onkey-falling", "onkey-rising";
+			power-off-time-sec = <10>;
+			status = "okay";
+		};
+
+		watchdog {
+			compatible = "st,stpmic1-wdt";
+			status = "disabled";
+		};
+	};
+};
+
+&i2c5{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c5_pins_a>;
+	pinctrl-1 = <&i2c5_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <100>;
+	i2c-scl-falling-time-ns = <7>;
+	clock-frequency = <100000>;
+	status = "okay";
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	/* Teste 2 */
+	// bridge@f {
+	// 	compatible = "toshiba,tc358767";
+	// 	reg = <0x0f>;
+	// 	clock-names = "ref";
+    //     clocks = <&edp_refclk>;
+	// 	reset-gpios = <&gpioe 12 GPIO_ACTIVE_LOW>;
+	// 	status = "disabled";
+
+	// 	ports {
+	// 		#address-cells = <1>;
+	// 		#size-cells = <0>;
+
+	// 		port@0 {
+	// 			reg = <0>;
+	// 			tc358867_in: endpoint {
+	// 				remote-endpoint = <&dsi_out>;
+	// 			};
+	// 		};
+	// 	};
+	// };
+};
+
+&ipcc {
+	status = "okay";
+};
+
+&iwdg2 {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&ltdc {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&ltdc_pins_a>;
+	pinctrl-1 = <&ltdc_sleep_pins_a>;
+	status = "okay";
+	
+	port {
+		ltdc_ep0_out: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&sii9022_in>;
+		};
+	};
+
+	port {
+		ltdc_ep1_out: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&dsi_in>;
+			};
+		};
+};
+
+&m_can1{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&m_can1_pins_a>;
+	pinctrl-1 = <&m_can1_sleep_pins_a>;
+	status = "disabled";
+
+};
+
+&m4_rproc{
+	memory-region = <&retram>, <&mcuram>, <&mcuram2>, <&vdev0vring0>,
+			<&vdev0vring1>, <&vdev0buffer>, <&mcu_rsc_table>;
+	mboxes = <&ipcc 0>, <&ipcc 1>, <&ipcc 2>, <&ipcc 3>;
+	mbox-names = "vq0", "vq1", "shutdown", "detach";
+	interrupt-parent = <&exti>;
+	interrupts = <68 1>;
+	wakeup-source;
+	status = "okay";
+
+};
+
+&pwr_regulators{
+	vdd-supply = <&vdd>;
+	vdd_3v3_usbfs-supply = <&vdd_usb>;
+
+};
+
+
+&rtc {
+	st,lsco = <RTC_OUT2_RMP>;
+	pinctrl-0 = <&rtc_out2_rmp_pins_a>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&sdmmc1{
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_b4_pins_a>;
+	pinctrl-1 = <&sdmmc1_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a>;
+	cd-gpios = <&gpiob 7 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	disable-wp;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&v3v3>;
+	status = "okay";
+
+};
+
+
+&sdmmc2{
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a &sdmmc2_d47_sleep_pins_a>;
+	non-removable;                                        
+	no-sd;                                               
+	no-sdio;                                              
+	st,neg-edge;                                           
+	bus-width = <8>;                                    
+	vmmc-supply = <&v3v3>;                      
+	vqmmc-supply = <&vdd>;
+	mmc-ddr-3_3v;                                                              
+	status = "okay";
+
+};
+
+&spi1{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi1_pins_a>;
+	pinctrl-1 = <&spi1_sleep_pins_a>;
+	cs-gpios = <&gpioz 3 1>;
+	status = "okay";
+
+	spidev@0{
+		status = "okay";
+        compatible = "linux,spidev";
+        reg = <0>;
+        spi-max-frequency = <4000000>;
+    };
+
+	can0: can@0 {
+		compatible = "microchip,mcp2515";
+		reg = <0>;
+		clocks = <&clk8M>;
+		interrupt-parent = <&gpiog>;
+		interrupts = <3 IRQ_TYPE_LEVEL_LOW>;
+		vdd-supply = <&reg_3v3>;
+		xceiver-supply = <&reg_5v0>;
+		spi-max-frequency = <10000000>;
+		status = "disabled";
+	};
+
+};
+
+&sram {
+	dma_pool: dma_pool@0 {
+		reg = <0x50000 0x10000>;
+		pool;
+	};
+};
+
+
+&timers3{
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+
+	pwm1: pwm{
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&pwm3_pins_a>;
+		pinctrl-1 = <&pwm3_sleep_pins_a>;
+		status = "okay";
+
+	};
+
+};
+
+&timers5{
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+
+	pwm2:pwm {
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&pwm5_pins_a>;
+		pinctrl-1 = <&pwm5_sleep_pins_a>;
+		status = "okay";
+
+	};
+
+};
+
+&uart4 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&uart4_pins_a>;
+	pinctrl-1 = <&uart4_sleep_pins_a>;
+	pinctrl-2 = <&uart4_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&usart1{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&usart1_pins_a>;
+	pinctrl-1 = <&usart1_sleep_pins_a>;
+	status = "okay";
+
+};
+
+&usart2{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&usart2_pins_c>;
+	pinctrl-1 = <&usart2_sleep_pins_c>;
+	status = "okay";
+
+};
+
+&usart3{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&usart3_pins_c>;
+	pinctrl-1 = <&usart3_sleep_pins_c>;
+	// uart-has-rtscts;
+	status = "okay";
+
+};
+
+&usbh_ehci {
+	phys = <&usbphyc_port0>;
+	status = "okay";
+};
+
+&usbotg_hs {
+	compatible = "st,stm32mp15-hsotg", "snps,dwc2";
+	phys = <&usbphyc_port1 0>;                                                /* 0: UTMI switch selects the OTG controller */
+	phy-names = "usb2-phy";
+	dr_mode = "peripheral";                                                   /* could be "host", see USB generic bindings [4] */
+	usb-role-switch;                                                          /* see USB generic bindings [4] */
+	role-switch-default-mode = "peripheral";                                  /* could be "host", see USB generic bindings [4] */
+	status = "okay";                                                          /* enable OTG */
+};
+
+&usbphyc {
+	status = "okay";
+};
+
+&usbphyc_port0 {
+	phy-supply = <&vdd_usb>;
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
+
+	/*
+	 * Hack to keep hub active until all connected devices are suspended
+	 * otherwise the hub will be powered off as soon as the v3v3 is disabled
+	 * and it can disturb connected devices.
+	 */
+	connector {
+		compatible = "usb-a-connector";
+		vbus-supply = <&v3v3>;
+	};
+};
+
+&usbphyc_port1 {
+	phy-supply = <&vdd_usb>;
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
+};
+
+&vrefbuf {
+	regulator-min-microvolt = <2500000>;
+	regulator-max-microvolt = <2500000>;
+	vdda-supply = <&vdd>;
+	status = "okay";
+};
+
+
+&i2s2 {
+	clocks = <&rcc SPI2>, <&rcc SPI2_K>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	clock-names = "pclk", "i2sclk", "x8k", "x11k";
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2s2_pins_a>;
+	pinctrl-1 = <&i2s2_sleep_pins_a>;
+	status = "disabled";
+
+	i2s2_port: port {
+		i2s2_endpoint: endpoint {
+			remote-endpoint = <&sii9022_tx_endpoint>;
+			format = "i2s";
+			mclk-fs = <256>;
+		};
+	};
+};
+
+
+&sai2 {
+	clocks = <&rcc SAI2>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	clock-names = "pclk", "x8k", "x11k";
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sai2a_pins_a>; //<&sai2a_pins_a>, <&sai2b_pins_b>;
+	pinctrl-1 = <&sai2a_sleep_pins_a>; // <&sai2a_sleep_pins_a>, <&sai2b_sleep_pins_b>;
+	status = "disabled";
+	
+
+	sai2a: audio-controller@4400b004 {
+		compatible = "st,stm32-sai-sub-a";
+		#clock-cells = <0>;
+		dma-names = "rx";
+		status = "okay";
+
+		// sai2a_port: port {
+		// 	sai2a_endpoint: endpoint {
+		// 		remote-endpoint = <&sph0645>;
+		// 		format = "i2s";
+		// 		mclk-fs = <256>;
+		// 		dai-tdm-slot-num = <2>;
+		// 		dai-tdm-slot-width = <32>;
+		// 	};
+		// };
+	};
+
+	// sai2b: audio-controller@4400b024 {
+	// 	dma-names = "rx";
+	// 	st,sync = <&sai2a 2>;
+	// 	clocks = <&rcc SAI2_K>, <&sai2a>;
+	// 	clock-names = "sai_ck", "MCLK";
+	// 	status = "okay";
+
+	// 	// sai2b_port: port {
+	// 	// 	sai2b_endpoint: endpoint {
+	// 	// 		remote-endpoint = <&cs42l51_rx_endpoint>;
+	// 	// 		format = "i2s";
+	// 	// 		mclk-fs = <256>;
+	// 	// 		dai-tdm-slot-num = <2>;
+	// 	// 		dai-tdm-slot-width = <32>;
+	// 	// 	};
+	// 	// };
+	// };
+};
diff --git a/arch/arm/boot/dts/stm32mp157f-ev1.dts b/arch/arm/boot/dts/stm32mp157f-ev1.dts
index b831f0453..8384473fc 100644
--- a/arch/arm/boot/dts/stm32mp157f-ev1.dts
+++ b/arch/arm/boot/dts/stm32mp157f-ev1.dts
@@ -36,7 +36,7 @@ panel_backlight: panel-backlight {
 &dsi {
 	#address-cells = <1>;
 	#size-cells = <0>;
-	status = "okay";
+	status = "disabled";
 
 	ports {
 		#address-cells = <1>;
@@ -88,7 +88,7 @@ gt9147: goodix_ts@5d {
 };
 
 &ltdc {
-	status = "okay";
+	status = "disabled";
 
 	port {
 		ltdc_ep0_out: endpoint@0 {
diff --git a/arch/arm/boot/dts/stm32mp15xx-edx.dtsi b/arch/arm/boot/dts/stm32mp15xx-edx.dtsi
index db0f91135..e5f930187 100644
--- a/arch/arm/boot/dts/stm32mp15xx-edx.dtsi
+++ b/arch/arm/boot/dts/stm32mp15xx-edx.dtsi
@@ -137,7 +137,7 @@ &dac {
 	pinctrl-names = "default";
 	pinctrl-0 = <&dac_ch1_pins_a &dac_ch2_pins_a>;
 	vref-supply = <&vdda>;
-	status = "disabled";
+	status = "okay";
 	dac1: dac@1 {
 		status = "okay";
 	};
diff --git a/arch/arm/boot/dts/stm32mp15xx-evx.dtsi b/arch/arm/boot/dts/stm32mp15xx-evx.dtsi
index fa453817a..a95a0548d 100644
--- a/arch/arm/boot/dts/stm32mp15xx-evx.dtsi
+++ b/arch/arm/boot/dts/stm32mp15xx-evx.dtsi
@@ -156,7 +156,7 @@ &cec {
 };
 
 &dcmi {
-	status = "okay";
+	status = "disabled";
 	pinctrl-names = "default", "sleep";
 	pinctrl-0 = <&dcmi_pins_a>;
 	pinctrl-1 = <&dcmi_sleep_pins_a>;
@@ -304,10 +304,10 @@ &fmc {
 	pinctrl-names = "default", "sleep";
 	pinctrl-0 = <&fmc_pins_a>;
 	pinctrl-1 = <&fmc_sleep_pins_a>;
-	status = "okay";
+	status = "disabled";
 
 	nand-controller@4,0 {
-		status = "okay";
+		status = "disabled";
 
 		nand@0 {
 			reg = <0>;
@@ -548,6 +548,22 @@ sai4a_endpoint: endpoint {
 	};
 };
 
+&sdmmc2{
+	pinctrl-names = "default", "opendrain", "sleep";      
+	pinctrl-0 = <&sdmmc2_b4_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a>;             
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&v3v3>;
+	vqmmc-supply = <&vdd>;
+	mmc-ddr-3_3v;
+	status = "okay";
+};
+
 &sdmmc3 {
 	pinctrl-names = "default", "opendrain", "sleep";
 	pinctrl-0 = <&sdmmc3_b4_pins_a>;
diff --git a/arch/arm/configs/stm32_dn_som_defconfig b/arch/arm/configs/stm32_dn_som_defconfig
new file mode 100644
index 000000000..f5a9f14fe
--- /dev/null
+++ b/arch/arm/configs/stm32_dn_som_defconfig
@@ -0,0 +1,1156 @@
+CONFIG_COMPILE_TEST=y
+# CONFIG_WERROR is not set
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_USELIB=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_BPF_SYSCALL=y
+CONFIG_BPF_JIT=y
+CONFIG_PREEMPT=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_CGROUPS=y
+CONFIG_MEMCG=y
+CONFIG_BLK_CGROUP=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_BPF=y
+CONFIG_NAMESPACES=y
+CONFIG_USER_NS=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_EMBEDDED=y
+CONFIG_PROFILING=y
+CONFIG_ARCH_MILBEAUT=y
+CONFIG_ARCH_MILBEAUT_M10V=y
+CONFIG_ARCH_STM32=y
+CONFIG_ARM_THUMBEE=y
+# CONFIG_SOUND_SPH0645=y
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_ERRATA_430973=y
+CONFIG_ARM_ERRATA_720789=y
+CONFIG_ARM_ERRATA_754322=y
+CONFIG_ARM_ERRATA_775420=y
+CONFIG_SMP=y
+CONFIG_SCHED_MC=y
+CONFIG_HIGHMEM=y
+CONFIG_FORCE_MAX_ZONEORDER=12
+# CONFIG_ATAGS is not set
+CONFIG_ARM_APPENDED_DTB=y
+CONFIG_ARM_ATAG_DTB_COMPAT=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=m
+CONFIG_CPU_FREQ_GOV_USERSPACE=m
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=m
+CONFIG_ARM_SCMI_CPUFREQ=y
+CONFIG_CPU_IDLE=y
+CONFIG_ARM_STM32_CPUIDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_KERNEL_MODE_NEON=y
+CONFIG_ARM_CRYPTO=y
+CONFIG_CRYPTO_SHA1_ARM_NEON=m
+CONFIG_CRYPTO_SHA1_ARM_CE=m
+CONFIG_CRYPTO_SHA2_ARM_CE=m
+CONFIG_CRYPTO_SHA512_ARM=m
+CONFIG_CRYPTO_AES_ARM=m
+CONFIG_CRYPTO_AES_ARM_BS=m
+CONFIG_CRYPTO_AES_ARM_CE=m
+CONFIG_CRYPTO_GHASH_ARM_CE=m
+CONFIG_CRYPTO_CRC32_ARM_CE=m
+CONFIG_CRYPTO_CHACHA20_NEON=m
+CONFIG_KPROBES=y
+# CONFIG_GCC_PLUGINS is not set
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SIG=y
+CONFIG_MODULE_SIG_SHA256=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_CMDLINE_PARTITION=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=m
+CONFIG_TLS=m
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_FIB_TRIE_STATS=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_NET_IPIP=m
+CONFIG_NET_IPGRE_DEMUX=m
+CONFIG_NET_IPGRE=m
+CONFIG_NET_IPGRE_BROADCAST=y
+CONFIG_IP_MROUTE=y
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_NET_IPVTI=m
+CONFIG_NET_FOU_IP_TUNNELS=y
+CONFIG_INET_AH=m
+CONFIG_INET_ESP=m
+CONFIG_INET_ESP_OFFLOAD=m
+CONFIG_INET_IPCOMP=m
+CONFIG_INET_DIAG=m
+CONFIG_INET_UDP_DIAG=m
+CONFIG_INET_RAW_DIAG=m
+CONFIG_INET_DIAG_DESTROY=y
+CONFIG_TCP_CONG_ADVANCED=y
+CONFIG_TCP_MD5SIG=y
+CONFIG_IPV6=m
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_ESP_OFFLOAD=m
+CONFIG_INET6_IPCOMP=m
+CONFIG_IPV6_MIP6=m
+CONFIG_IPV6_VTI=m
+CONFIG_IPV6_SIT_6RD=y
+CONFIG_IPV6_GRE=m
+CONFIG_IPV6_SUBTREES=y
+CONFIG_IPV6_MROUTE=y
+CONFIG_IPV6_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IPV6_PIMSM_V2=y
+CONFIG_IPV6_SEG6_LWTUNNEL=y
+CONFIG_IPV6_SEG6_HMAC=y
+CONFIG_NETWORK_SECMARK=y
+CONFIG_NETWORK_PHY_TIMESTAMPING=y
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CONNTRACK_TIMEOUT=y
+CONFIG_NF_CONNTRACK_TIMESTAMP=y
+CONFIG_NF_CONNTRACK_AMANDA=m
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NF_CONNTRACK_H323=m
+CONFIG_NF_CONNTRACK_IRC=m
+CONFIG_NF_CONNTRACK_NETBIOS_NS=m
+CONFIG_NF_CONNTRACK_SNMP=m
+CONFIG_NF_CONNTRACK_PPTP=m
+CONFIG_NF_CONNTRACK_SIP=m
+CONFIG_NF_CONNTRACK_TFTP=m
+CONFIG_NF_CT_NETLINK=m
+CONFIG_NF_CT_NETLINK_TIMEOUT=m
+CONFIG_NF_CT_NETLINK_HELPER=m
+CONFIG_NETFILTER_NETLINK_GLUE_CT=y
+CONFIG_NF_TABLES=m
+CONFIG_NFT_NUMGEN=m
+CONFIG_NFT_CT=m
+CONFIG_NFT_COUNTER=m
+CONFIG_NFT_LOG=m
+CONFIG_NFT_LIMIT=m
+CONFIG_NFT_MASQ=m
+CONFIG_NFT_REDIR=m
+CONFIG_NFT_OBJREF=m
+CONFIG_NFT_QUEUE=m
+CONFIG_NFT_QUOTA=m
+CONFIG_NFT_REJECT=m
+CONFIG_NFT_HASH=m
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=m
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=m
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=m
+CONFIG_NETFILTER_XT_TARGET_HMARK=m
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=m
+CONFIG_NETFILTER_XT_TARGET_LED=m
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_TARGET_MARK=m
+CONFIG_NETFILTER_XT_TARGET_NFLOG=m
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=m
+CONFIG_NETFILTER_XT_TARGET_TEE=m
+CONFIG_NETFILTER_XT_TARGET_SECMARK=m
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
+CONFIG_NETFILTER_XT_MATCH_BPF=m
+CONFIG_NETFILTER_XT_MATCH_CGROUP=m
+CONFIG_NETFILTER_XT_MATCH_CLUSTER=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=m
+CONFIG_NETFILTER_XT_MATCH_CONNLABEL=m
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_CPU=m
+CONFIG_NETFILTER_XT_MATCH_DCCP=m
+CONFIG_NETFILTER_XT_MATCH_DEVGROUP=m
+CONFIG_NETFILTER_XT_MATCH_DSCP=m
+CONFIG_NETFILTER_XT_MATCH_ESP=m
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_HELPER=m
+CONFIG_NETFILTER_XT_MATCH_IPCOMP=m
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=m
+CONFIG_NETFILTER_XT_MATCH_LENGTH=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MARK=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_NFACCT=m
+CONFIG_NETFILTER_XT_MATCH_OSF=m
+CONFIG_NETFILTER_XT_MATCH_OWNER=m
+CONFIG_NETFILTER_XT_MATCH_POLICY=m
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA=m
+CONFIG_NETFILTER_XT_MATCH_RATEEST=m
+CONFIG_NETFILTER_XT_MATCH_REALM=m
+CONFIG_NETFILTER_XT_MATCH_RECENT=m
+CONFIG_NETFILTER_XT_MATCH_SCTP=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
+CONFIG_NETFILTER_XT_MATCH_STRING=m
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_TIME=m
+CONFIG_NETFILTER_XT_MATCH_U32=m
+CONFIG_IP_SET=m
+CONFIG_IP_VS=m
+CONFIG_NF_SOCKET_IPV4=m
+CONFIG_NF_LOG_ARP=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_AH=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_RPFILTER=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_SYNPROXY=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_CLUSTERIP=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_TTL=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+CONFIG_NF_SOCKET_IPV6=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_MATCH_AH=m
+CONFIG_IP6_NF_MATCH_EUI64=m
+CONFIG_IP6_NF_MATCH_FRAG=m
+CONFIG_IP6_NF_MATCH_OPTS=m
+CONFIG_IP6_NF_MATCH_HL=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_IP6_NF_MATCH_MH=m
+CONFIG_IP6_NF_MATCH_RPFILTER=m
+CONFIG_IP6_NF_MATCH_RT=m
+CONFIG_IP6_NF_TARGET_HL=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_TARGET_SYNPROXY=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_RAW=m
+CONFIG_IP6_NF_NAT=m
+CONFIG_IP6_NF_TARGET_MASQUERADE=m
+CONFIG_IP6_NF_TARGET_NPT=m
+CONFIG_NF_TABLES_BRIDGE=m
+CONFIG_NFT_BRIDGE_META=m
+CONFIG_NFT_BRIDGE_REJECT=m
+CONFIG_BRIDGE_NF_EBTABLES=m
+CONFIG_BRIDGE_EBT_BROUTE=m
+CONFIG_BRIDGE_EBT_T_FILTER=m
+CONFIG_BRIDGE_EBT_T_NAT=m
+CONFIG_BRIDGE_EBT_802_3=m
+CONFIG_BRIDGE_EBT_AMONG=m
+CONFIG_BRIDGE_EBT_ARP=m
+CONFIG_BRIDGE_EBT_IP=m
+CONFIG_BRIDGE_EBT_IP6=m
+CONFIG_BRIDGE_EBT_LIMIT=m
+CONFIG_BRIDGE_EBT_MARK=m
+CONFIG_BRIDGE_EBT_PKTTYPE=m
+CONFIG_BRIDGE_EBT_STP=m
+CONFIG_BRIDGE_EBT_VLAN=m
+CONFIG_BRIDGE_EBT_ARPREPLY=m
+CONFIG_BRIDGE_EBT_DNAT=m
+CONFIG_BRIDGE_EBT_MARK_T=m
+CONFIG_BRIDGE_EBT_REDIRECT=m
+CONFIG_BRIDGE_EBT_SNAT=m
+CONFIG_BRIDGE_EBT_LOG=m
+CONFIG_BRIDGE_EBT_NFLOG=m
+CONFIG_L2TP=m
+CONFIG_BRIDGE=m
+CONFIG_NET_DSA=m
+CONFIG_VLAN_8021Q=m
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_VLAN_8021Q_MVRP=y
+CONFIG_LLC2=m
+CONFIG_6LOWPAN=m
+CONFIG_6LOWPAN_DEBUGFS=y
+CONFIG_IEEE802154=m
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_CBQ=m
+CONFIG_NET_SCH_HTB=m
+CONFIG_NET_SCH_HFSC=m
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_MULTIQ=m
+CONFIG_NET_SCH_RED=m
+CONFIG_NET_SCH_SFB=m
+CONFIG_NET_SCH_SFQ=m
+CONFIG_NET_SCH_TEQL=m
+CONFIG_NET_SCH_TBF=m
+CONFIG_NET_SCH_GRED=m
+CONFIG_NET_SCH_DSMARK=m
+CONFIG_NET_SCH_NETEM=m
+CONFIG_NET_SCH_DRR=m
+CONFIG_NET_SCH_MQPRIO=m
+CONFIG_NET_SCH_CHOKE=m
+CONFIG_NET_SCH_QFQ=m
+CONFIG_NET_SCH_CODEL=m
+CONFIG_NET_SCH_FQ_CODEL=m
+CONFIG_NET_SCH_FQ=m
+CONFIG_NET_SCH_HHF=m
+CONFIG_NET_SCH_PIE=m
+CONFIG_NET_SCH_PLUG=m
+CONFIG_NET_SCH_DEFAULT=y
+CONFIG_NET_CLS_BASIC=m
+CONFIG_NET_CLS_TCINDEX=m
+CONFIG_NET_CLS_ROUTE4=m
+CONFIG_NET_CLS_FW=m
+CONFIG_NET_CLS_U32=m
+CONFIG_CLS_U32_PERF=y
+CONFIG_CLS_U32_MARK=y
+CONFIG_NET_CLS_RSVP=m
+CONFIG_NET_CLS_RSVP6=m
+CONFIG_NET_CLS_FLOW=m
+CONFIG_NET_CLS_CGROUP=m
+CONFIG_NET_CLS_BPF=m
+CONFIG_NET_CLS_FLOWER=m
+CONFIG_NET_CLS_MATCHALL=m
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_CMP=m
+CONFIG_NET_EMATCH_NBYTE=m
+CONFIG_NET_EMATCH_U32=m
+CONFIG_NET_EMATCH_META=m
+CONFIG_NET_EMATCH_TEXT=m
+CONFIG_NET_EMATCH_CANID=m
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=m
+CONFIG_NET_ACT_GACT=m
+CONFIG_GACT_PROB=y
+CONFIG_NET_ACT_MIRRED=m
+CONFIG_NET_ACT_SAMPLE=m
+CONFIG_NET_ACT_NAT=m
+CONFIG_NET_ACT_PEDIT=m
+CONFIG_NET_ACT_CSUM=m
+CONFIG_NET_ACT_VLAN=m
+CONFIG_NET_ACT_BPF=m
+CONFIG_NET_ACT_SKBMOD=m
+CONFIG_NET_ACT_IFE=m
+CONFIG_NET_ACT_TUNNEL_KEY=m
+CONFIG_NET_IFE_SKBMARK=m
+CONFIG_NET_IFE_SKBPRIO=m
+CONFIG_NET_IFE_SKBTCINDEX=m
+CONFIG_DCB=y
+CONFIG_BATMAN_ADV=m
+CONFIG_BATMAN_ADV_NC=y
+CONFIG_BATMAN_ADV_DEBUG=y
+CONFIG_OPENVSWITCH=m
+CONFIG_VSOCKETS=m
+CONFIG_VIRTIO_VSOCKETS=m
+CONFIG_NETLINK_DIAG=m
+CONFIG_HSR=m
+CONFIG_CGROUP_NET_PRIO=y
+CONFIG_CAN=y
+CONFIG_CAN_FLEXCAN=m
+CONFIG_CAN_M_CAN=y
+CONFIG_CAN_M_CAN_PLATFORM=y
+CONFIG_CAN_MCP251X=y
+CONFIG_BT=m
+CONFIG_BT_6LOWPAN=m
+CONFIG_BT_HCIUART=m
+CONFIG_BT_HCIUART_BCM=y
+CONFIG_BT_MRVL=m
+CONFIG_BT_MRVL_SDIO=m
+CONFIG_CFG80211=m
+CONFIG_MAC80211=m
+CONFIG_RFKILL=y
+CONFIG_RFKILL_INPUT=y
+CONFIG_RFKILL_GPIO=y
+CONFIG_NFC=m
+CONFIG_NFC_DIGITAL=m
+CONFIG_NFC_NCI=m
+CONFIG_NFC_NCI_SPI=m
+CONFIG_NFC_NCI_UART=m
+CONFIG_NFC_HCI=m
+CONFIG_NFC_SHDLC=y
+CONFIG_NFC_S3FWRN5_I2C=m
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_BRCMSTB_GISB_ARB=y
+CONFIG_VEXPRESS_CONFIG=y
+CONFIG_TRUSTED_FOUNDATIONS=y
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_OF=y
+CONFIG_MTD_MCHP23K256=m
+CONFIG_MTD_RAW_NAND=y
+CONFIG_MTD_NAND_DENALI_DT=y
+CONFIG_MTD_NAND_BRCMNAND=y
+CONFIG_MTD_NAND_STM32_FMC2=y
+CONFIG_MTD_SPI_NAND=y
+CONFIG_MTD_SPI_NOR=y
+# CONFIG_MTD_SPI_NOR_USE_4K_SECTORS is not set
+CONFIG_MTD_UBI=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=65536
+CONFIG_VIRTIO_BLK=y
+CONFIG_AD525X_DPOT=y
+CONFIG_AD525X_DPOT_I2C=y
+CONFIG_ICS932S401=y
+CONFIG_APDS9802ALS=y
+CONFIG_ISL29003=y
+CONFIG_SRAM=y
+CONFIG_EEPROM_AT24=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_BLK_DEV_SR=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_ATA=y
+CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_CRYPT=y
+CONFIG_NETDEVICES=y
+CONFIG_MACVLAN=m
+CONFIG_MACVTAP=m
+CONFIG_TUN=m
+CONFIG_TUN_VNET_CROSS_LE=y
+CONFIG_VETH=m
+CONFIG_VIRTIO_NET=y
+CONFIG_B53_SPI_DRIVER=m
+CONFIG_B53_MDIO_DRIVER=m
+CONFIG_B53_MMAP_DRIVER=m
+CONFIG_B53_SRAB_DRIVER=m
+CONFIG_B53_SERDES=m
+CONFIG_NET_DSA_BCM_SF2=m
+CONFIG_BCMGENET=m
+CONFIG_SYSTEMPORT=m
+CONFIG_MACB=y
+CONFIG_FTGMAC100=m
+CONFIG_HIX5HD2_GMAC=y
+CONFIG_MVMDIO=y
+CONFIG_KS8851=y
+CONFIG_SMSC911X=y
+CONFIG_STMMAC_ETH=y
+CONFIG_DWMAC_DWC_QOS_ETH=y
+CONFIG_XILINX_EMACLITE=y
+CONFIG_BROADCOM_PHY=y
+CONFIG_ICPLUS_PHY=y
+CONFIG_MARVELL_PHY=y
+CONFIG_AT803X_PHY=y
+CONFIG_REALTEK_PHY=y
+CONFIG_ROCKCHIP_PHY=y
+CONFIG_DP83867_PHY=y
+CONFIG_MDIO_BITBANG=y
+CONFIG_USB_PEGASUS=y
+CONFIG_USB_RTL8152=m
+CONFIG_USB_USBNET=y
+CONFIG_USB_NET_SMSC75XX=y
+CONFIG_USB_NET_SMSC95XX=y
+CONFIG_BRCMFMAC=m
+CONFIG_MWIFIEX=m
+CONFIG_MWIFIEX_SDIO=m
+CONFIG_RT2X00=m
+CONFIG_RT2800USB=m
+CONFIG_INPUT_JOYDEV=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_KEYBOARD_QT1070=m
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_SAMSUNG=m
+CONFIG_KEYBOARD_BCM=y
+CONFIG_MOUSE_PS2_ELANTECH=y
+CONFIG_MOUSE_CYAPA=m
+CONFIG_MOUSE_ELAN_I2C=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ADC=m
+CONFIG_TOUCHSCREEN_ATMEL_MXT=m
+CONFIG_TOUCHSCREEN_GOODIX=y
+CONFIG_TOUCHSCREEN_ELAN=m
+CONFIG_TOUCHSCREEN_MMS114=m
+CONFIG_TOUCHSCREEN_EDT_FT5X06=y
+CONFIG_TOUCHSCREEN_ST1232=m
+CONFIG_TOUCHSCREEN_STMPE=y
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_MAX77693_HAPTIC=m
+CONFIG_INPUT_MAX8997_HAPTIC=m
+CONFIG_INPUT_CPCAP_PWRBUTTON=m
+CONFIG_INPUT_AXP20X_PEK=m
+CONFIG_INPUT_UINPUT=m
+CONFIG_INPUT_DA9063_ONKEY=m
+CONFIG_INPUT_ADXL34X=m
+CONFIG_INPUT_STPMIC1_ONKEY=y
+CONFIG_SERIO_AMBAKMI=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_LEGACY_PTY_COUNT=8
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+CONFIG_SERIAL_STM32=y
+CONFIG_SERIAL_STM32_CONSOLE=y
+CONFIG_SERIAL_NONSTANDARD=y
+CONFIG_RPMSG_TTY=m
+CONFIG_SERIAL_DEV_BUS=y
+CONFIG_HW_RANDOM=y
+CONFIG_TCG_TPM=m
+CONFIG_TCG_TIS_I2C_INFINEON=m
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_ARB_GPIO_CHALLENGE=m
+CONFIG_I2C_MUX_PCA954x=y
+CONFIG_I2C_MUX_PINCTRL=y
+CONFIG_I2C_DEMUX_PINCTRL=y
+CONFIG_I2C_NOMADIK=y
+CONFIG_I2C_STM32F7=y
+CONFIG_SPI=y
+CONFIG_SPI_DEBUG=y
+CONFIG_SPI_CADENCE=y
+CONFIG_SPI_GPIO=m
+CONFIG_SPI_PL022=y
+CONFIG_SPI_ROCKCHIP=m
+CONFIG_SPI_STM32=y
+CONFIG_SPI_STM32_QSPI=y
+CONFIG_SPI_XILINX=y
+CONFIG_SPI_SPIDEV=y
+CONFIG_SPI_SLAVE=y
+CONFIG_SPMI=y
+CONFIG_PINCTRL_AS3722=y
+CONFIG_PINCTRL_MCP23S08=y
+CONFIG_PINCTRL_MCP_DN_SOM=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_PINCTRL_STMFX=y
+CONFIG_PINCTRL_PALMAS=y
+CONFIG_GPIO_DWAPB=y
+CONFIG_GPIO_PL061=y
+CONFIG_GPIO_SYSCON=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_XILINX=y
+CONFIG_GPIO_PALMAS=y
+CONFIG_GPIO_TPS6586X=y
+CONFIG_GPIO_TPS65910=y
+CONFIG_GPIO_TWL4030=y
+CONFIG_POWER_RESET=y
+CONFIG_POWER_RESET_AS3722=y
+CONFIG_POWER_RESET_BRCMKONA=y
+CONFIG_POWER_RESET_BRCMSTB=y
+CONFIG_POWER_RESET_GPIO=y
+CONFIG_POWER_RESET_GPIO_RESTART=y
+CONFIG_POWER_RESET_VEXPRESS=y
+CONFIG_POWER_RESET_SYSCON=y
+CONFIG_POWER_RESET_SYSCON_POWEROFF=y
+CONFIG_SYSCON_REBOOT_MODE=y
+CONFIG_BATTERY_ACT8945A=y
+CONFIG_BATTERY_CPCAP=m
+CONFIG_BATTERY_SBS=y
+CONFIG_BATTERY_BQ27XXX=m
+CONFIG_AXP20X_POWER=m
+CONFIG_BATTERY_MAX17040=m
+CONFIG_BATTERY_MAX17042=m
+CONFIG_CHARGER_GPIO=m
+CONFIG_CHARGER_MAX14577=m
+CONFIG_CHARGER_MAX77693=m
+CONFIG_CHARGER_MAX8997=m
+CONFIG_CHARGER_MAX8998=m
+CONFIG_CHARGER_TPS65090=y
+CONFIG_SENSORS_ARM_SCMI=y
+CONFIG_SENSORS_ASPEED=m
+CONFIG_SENSORS_IIO_HWMON=y
+CONFIG_SENSORS_LM90=y
+CONFIG_SENSORS_LM95245=y
+CONFIG_SENSORS_NTC_THERMISTOR=m
+CONFIG_SENSORS_PWM_FAN=m
+CONFIG_SENSORS_INA2XX=m
+CONFIG_CPU_THERMAL=y
+CONFIG_DEVFREQ_THERMAL=y
+CONFIG_ST_THERMAL_MEMMAP=y
+CONFIG_GENERIC_ADC_THERMAL=m
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+CONFIG_WATCHDOG_SYSFS=y
+CONFIG_DA9063_WATCHDOG=m
+CONFIG_XILINX_WATCHDOG=y
+CONFIG_ARM_SP805_WATCHDOG=y
+CONFIG_DW_WATCHDOG=y
+CONFIG_RN5T618_WATCHDOG=y
+CONFIG_STPMIC1_WATCHDOG=y
+CONFIG_BCMA=y
+CONFIG_BCMA_HOST_SOC=y
+CONFIG_BCMA_DRIVER_GMAC_CMN=y
+CONFIG_BCMA_DRIVER_GPIO=y
+CONFIG_MFD_ACT8945A=y
+CONFIG_MFD_AS3711=y
+CONFIG_MFD_AS3722=y
+CONFIG_MFD_ATMEL_FLEXCOM=y
+CONFIG_MFD_ATMEL_HLCDC=m
+CONFIG_MFD_BCM590XX=y
+CONFIG_MFD_AXP20X_I2C=y
+CONFIG_MFD_DA9063=m
+CONFIG_MFD_MAX14577=y
+CONFIG_MFD_MAX77686=y
+CONFIG_MFD_MAX77693=m
+CONFIG_MFD_MAX8907=y
+CONFIG_MFD_MAX8997=y
+CONFIG_MFD_MAX8998=y
+CONFIG_MFD_CPCAP=y
+CONFIG_MFD_PM8XXX=y
+CONFIG_MFD_RK808=y
+CONFIG_MFD_RN5T618=y
+CONFIG_MFD_SEC_CORE=y
+CONFIG_MFD_STMPE=y
+CONFIG_MFD_PALMAS=y
+CONFIG_MFD_TPS65090=y
+CONFIG_MFD_TPS65217=y
+CONFIG_MFD_TPS65218=y
+CONFIG_MFD_TPS6586X=y
+CONFIG_MFD_TPS65910=y
+CONFIG_TWL4030_CORE=y
+CONFIG_TWL4030_POWER=y
+CONFIG_MFD_WM8994=m
+CONFIG_MFD_STM32_LPTIMER=y
+CONFIG_MFD_STPMIC1=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_ACT8865=y
+CONFIG_REGULATOR_ACT8945A=y
+CONFIG_REGULATOR_ARM_SCMI=y
+CONFIG_REGULATOR_AS3711=y
+CONFIG_REGULATOR_AS3722=y
+CONFIG_REGULATOR_AXP20X=y
+CONFIG_REGULATOR_BCM590XX=y
+CONFIG_REGULATOR_CPCAP=y
+CONFIG_REGULATOR_DA9210=y
+CONFIG_REGULATOR_FAN53555=y
+CONFIG_REGULATOR_GPIO=y
+CONFIG_REGULATOR_LP872X=y
+CONFIG_REGULATOR_MAX14577=m
+CONFIG_REGULATOR_MAX8907=y
+CONFIG_REGULATOR_MAX8952=m
+CONFIG_REGULATOR_MAX8973=y
+CONFIG_REGULATOR_MAX8997=m
+CONFIG_REGULATOR_MAX8998=m
+CONFIG_REGULATOR_MAX77686=y
+CONFIG_REGULATOR_MAX77693=m
+CONFIG_REGULATOR_MAX77802=y
+CONFIG_REGULATOR_PALMAS=y
+CONFIG_REGULATOR_PWM=y
+CONFIG_REGULATOR_RK808=y
+CONFIG_REGULATOR_RN5T618=y
+CONFIG_REGULATOR_S2MPA01=m
+CONFIG_REGULATOR_S2MPS11=y
+CONFIG_REGULATOR_S5M8767=y
+CONFIG_REGULATOR_STM32_BOOSTER=m
+CONFIG_REGULATOR_STM32_VREFBUF=y
+CONFIG_REGULATOR_STM32_PWR=y
+CONFIG_REGULATOR_STPMIC1=y
+CONFIG_REGULATOR_TPS51632=y
+CONFIG_REGULATOR_TPS62360=y
+CONFIG_REGULATOR_TPS65090=y
+CONFIG_REGULATOR_TPS65217=y
+CONFIG_REGULATOR_TPS65218=y
+CONFIG_REGULATOR_TPS6586X=y
+CONFIG_REGULATOR_TPS65910=y
+CONFIG_REGULATOR_TWL4030=y
+CONFIG_REGULATOR_VEXPRESS=y
+CONFIG_CEC_STM32=m
+CONFIG_MEDIA_SUPPORT=m
+# CONFIG_DVB_NET is not set
+# CONFIG_DVB_DYNAMIC_MINORS is not set
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_VIDEO_ASPEED=m
+CONFIG_VIDEO_STM32_DCMI=m
+CONFIG_VIDEO_STM32_DCMIPP=m
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_V4L_TEST_DRIVERS=y
+CONFIG_VIDEO_VIVID=m
+CONFIG_VIDEO_ADV7180=m
+CONFIG_VIDEO_ADV7604=m
+CONFIG_VIDEO_ADV7604_CEC=y
+CONFIG_VIDEO_ML86V7667=m
+CONFIG_VIDEO_ST_MIPID02=m
+CONFIG_VIDEO_GC2145=m
+CONFIG_VIDEO_OV5640=m
+CONFIG_VIDEO_OV7670=m
+# CONFIG_CXD2880_SPI_DRV is not set
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA18250 is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5761 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_MSI001 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2063 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_MEDIA_TUNER_XC4000 is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
+# CONFIG_MEDIA_TUNER_MAX2165 is not set
+# CONFIG_MEDIA_TUNER_TDA18218 is not set
+# CONFIG_MEDIA_TUNER_FC0011 is not set
+# CONFIG_MEDIA_TUNER_FC0012 is not set
+# CONFIG_MEDIA_TUNER_FC0013 is not set
+# CONFIG_MEDIA_TUNER_TDA18212 is not set
+# CONFIG_MEDIA_TUNER_E4000 is not set
+# CONFIG_MEDIA_TUNER_FC2580 is not set
+# CONFIG_MEDIA_TUNER_M88RS6000T is not set
+# CONFIG_MEDIA_TUNER_TUA9001 is not set
+# CONFIG_MEDIA_TUNER_SI2157 is not set
+# CONFIG_MEDIA_TUNER_IT913X is not set
+# CONFIG_MEDIA_TUNER_R820T is not set
+# CONFIG_MEDIA_TUNER_MXL301RF is not set
+# CONFIG_MEDIA_TUNER_QM1D1C0042 is not set
+# CONFIG_MEDIA_TUNER_QM1D1B0004 is not set
+# CONFIG_DVB_STB0899 is not set
+# CONFIG_DVB_STB6100 is not set
+# CONFIG_DVB_STV090x is not set
+# CONFIG_DVB_STV0910 is not set
+# CONFIG_DVB_STV6110x is not set
+# CONFIG_DVB_STV6111 is not set
+# CONFIG_DVB_MXL5XX is not set
+# CONFIG_DVB_M88DS3103 is not set
+# CONFIG_DVB_DRXK is not set
+# CONFIG_DVB_TDA18271C2DD is not set
+# CONFIG_DVB_SI2165 is not set
+# CONFIG_DVB_MN88472 is not set
+# CONFIG_DVB_MN88473 is not set
+# CONFIG_DVB_CX24110 is not set
+# CONFIG_DVB_CX24123 is not set
+# CONFIG_DVB_MT312 is not set
+# CONFIG_DVB_ZL10036 is not set
+# CONFIG_DVB_ZL10039 is not set
+# CONFIG_DVB_S5H1420 is not set
+# CONFIG_DVB_STV0288 is not set
+# CONFIG_DVB_STB6000 is not set
+# CONFIG_DVB_STV0299 is not set
+# CONFIG_DVB_STV6110 is not set
+# CONFIG_DVB_STV0900 is not set
+# CONFIG_DVB_TDA8083 is not set
+# CONFIG_DVB_TDA10086 is not set
+# CONFIG_DVB_TDA8261 is not set
+# CONFIG_DVB_VES1X93 is not set
+# CONFIG_DVB_TUNER_ITD1000 is not set
+# CONFIG_DVB_TUNER_CX24113 is not set
+# CONFIG_DVB_TDA826X is not set
+# CONFIG_DVB_TUA6100 is not set
+# CONFIG_DVB_CX24116 is not set
+# CONFIG_DVB_CX24117 is not set
+# CONFIG_DVB_CX24120 is not set
+# CONFIG_DVB_SI21XX is not set
+# CONFIG_DVB_TS2020 is not set
+# CONFIG_DVB_DS3000 is not set
+# CONFIG_DVB_MB86A16 is not set
+# CONFIG_DVB_TDA10071 is not set
+# CONFIG_DVB_SP887X is not set
+# CONFIG_DVB_CX22700 is not set
+# CONFIG_DVB_CX22702 is not set
+# CONFIG_DVB_S5H1432 is not set
+# CONFIG_DVB_DRXD is not set
+# CONFIG_DVB_L64781 is not set
+# CONFIG_DVB_TDA1004X is not set
+# CONFIG_DVB_NXT6000 is not set
+# CONFIG_DVB_MT352 is not set
+# CONFIG_DVB_ZL10353 is not set
+# CONFIG_DVB_DIB3000MB is not set
+# CONFIG_DVB_DIB3000MC is not set
+# CONFIG_DVB_DIB7000M is not set
+# CONFIG_DVB_DIB7000P is not set
+# CONFIG_DVB_DIB9000 is not set
+# CONFIG_DVB_TDA10048 is not set
+# CONFIG_DVB_AF9013 is not set
+# CONFIG_DVB_EC100 is not set
+# CONFIG_DVB_STV0367 is not set
+# CONFIG_DVB_CXD2820R is not set
+# CONFIG_DVB_CXD2841ER is not set
+# CONFIG_DVB_RTL2830 is not set
+# CONFIG_DVB_RTL2832 is not set
+# CONFIG_DVB_RTL2832_SDR is not set
+# CONFIG_DVB_SI2168 is not set
+# CONFIG_DVB_ZD1301_DEMOD is not set
+# CONFIG_DVB_CXD2880 is not set
+# CONFIG_DVB_VES1820 is not set
+# CONFIG_DVB_TDA10021 is not set
+# CONFIG_DVB_TDA10023 is not set
+# CONFIG_DVB_STV0297 is not set
+# CONFIG_DVB_NXT200X is not set
+# CONFIG_DVB_OR51211 is not set
+# CONFIG_DVB_OR51132 is not set
+# CONFIG_DVB_BCM3510 is not set
+# CONFIG_DVB_LGDT330X is not set
+# CONFIG_DVB_LGDT3305 is not set
+# CONFIG_DVB_LGDT3306A is not set
+# CONFIG_DVB_LG2160 is not set
+# CONFIG_DVB_S5H1409 is not set
+# CONFIG_DVB_AU8522_DTV is not set
+# CONFIG_DVB_AU8522_V4L is not set
+# CONFIG_DVB_S5H1411 is not set
+# CONFIG_DVB_MXL692 is not set
+# CONFIG_DVB_S921 is not set
+# CONFIG_DVB_DIB8000 is not set
+# CONFIG_DVB_MB86A20S is not set
+# CONFIG_DVB_TC90522 is not set
+# CONFIG_DVB_MN88443X is not set
+# CONFIG_DVB_PLL is not set
+# CONFIG_DVB_TUNER_DIB0070 is not set
+# CONFIG_DVB_TUNER_DIB0090 is not set
+# CONFIG_DVB_DRX39XYJ is not set
+# CONFIG_DVB_LNBH25 is not set
+# CONFIG_DVB_LNBH29 is not set
+# CONFIG_DVB_LNBP21 is not set
+# CONFIG_DVB_LNBP22 is not set
+# CONFIG_DVB_ISL6405 is not set
+# CONFIG_DVB_ISL6421 is not set
+# CONFIG_DVB_ISL6423 is not set
+# CONFIG_DVB_A8293 is not set
+# CONFIG_DVB_LGS8GL5 is not set
+# CONFIG_DVB_LGS8GXX is not set
+# CONFIG_DVB_ATBM8830 is not set
+# CONFIG_DVB_TDA665x is not set
+# CONFIG_DVB_IX2505V is not set
+# CONFIG_DVB_M88RS2000 is not set
+# CONFIG_DVB_AF9033 is not set
+# CONFIG_DVB_HORUS3A is not set
+# CONFIG_DVB_ASCOT2E is not set
+# CONFIG_DVB_HELENE is not set
+# CONFIG_DVB_CXD2099 is not set
+# CONFIG_DVB_SP2 is not set
+CONFIG_IMX_IPUV3_CORE=m
+CONFIG_DRM=y
+# CONFIG_DRM_FBDEV_EMULATION is not set
+CONFIG_DRM_EXYNOS=m
+CONFIG_DRM_EXYNOS_FIMD=y
+CONFIG_DRM_EXYNOS_MIXER=y
+CONFIG_DRM_EXYNOS_DPI=y
+CONFIG_DRM_EXYNOS_DSI=y
+CONFIG_DRM_EXYNOS_HDMI=y
+CONFIG_DRM_ATMEL_HLCDC=m
+CONFIG_DRM_RCAR_LVDS=y
+CONFIG_DRM_FSL_DCU=m
+CONFIG_DRM_STM=y
+CONFIG_DRM_STM_DSI=y
+CONFIG_DRM_PANEL_SIMPLE=y
+CONFIG_DRM_PANEL_SAMSUNG_LD9040=m
+CONFIG_DRM_PANEL_ORISETECH_OTM8009A=n
+CONFIG_DRM_PANEL_DIEBOLD_OP7=y
+CONFIG_DRM_PANEL_RAYDIUM_RM68200=y
+CONFIG_DRM_PANEL_ROCKTECH_HX8394=y
+CONFIG_DRM_PANEL_SAMSUNG_S6E63J0X03=m
+CONFIG_DRM_PANEL_SAMSUNG_S6E8AA0=m
+CONFIG_DRM_NXP_PTN3460=m
+CONFIG_DRM_PARADE_PS8622=m
+CONFIG_DRM_SII902X=y
+CONFIG_DRM_SII9234=m
+CONFIG_DRM_SIMPLE_BRIDGE=m
+CONFIG_DRM_TOSHIBA_TC358764=m
+CONFIG_DRM_I2C_ADV7511=y
+CONFIG_DRM_I2C_ADV7511_AUDIO=y
+CONFIG_DRM_STI=m
+CONFIG_DRM_IMX=m
+CONFIG_DRM_IMX_PARALLEL_DISPLAY=m
+CONFIG_DRM_IMX_TVE=m
+CONFIG_DRM_IMX_LDB=m
+CONFIG_DRM_IMX_HDMI=m
+CONFIG_DRM_ETNAVIV=m
+CONFIG_DRM_MXSFB=m
+CONFIG_DRM_SIMPLEDRM=y
+CONFIG_DRM_PL111=m
+CONFIG_DRM_LIMA=m
+CONFIG_DRM_PANFROST=m
+CONFIG_DRM_LEGACY=y
+CONFIG_FB=y
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_BACKLIGHT_AS3711=y
+CONFIG_BACKLIGHT_GPIO=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_SND_VERBOSE_PRINTK=y
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_SOC=y
+CONFIG_SND_ATMEL_SOC=m
+CONFIG_SND_SOC_FSL_SAI=m
+CONFIG_SND_SOC_STM32_SAI=y
+CONFIG_SND_SOC_STM32_I2S=m
+CONFIG_SND_SOC_STM32_SPDIFRX=m
+CONFIG_SND_SOC_STM32_DFSDM=m
+CONFIG_SND_SOC_AK4642=m
+CONFIG_SND_SOC_CPCAP=m
+CONFIG_SND_SOC_CS42L51_I2C=m
+CONFIG_SND_SOC_RT5631=m
+CONFIG_SND_SOC_RT5640=m
+CONFIG_SND_SOC_SGTL5000=m
+CONFIG_SND_SOC_STI_SAS=m
+CONFIG_SND_SOC_TLV320AIC23_I2C=m
+CONFIG_SND_SOC_TS3A227E=m
+CONFIG_SND_SOC_WM8753=m
+CONFIG_SND_SOC_WM8903=m
+CONFIG_SND_SOC_WM8904=m
+CONFIG_SND_SOC_WM8978=m
+CONFIG_SND_SOC_WM8994=m
+CONFIG_SND_SIMPLE_CARD=m
+CONFIG_SND_AUDIO_GRAPH_CARD=m
+CONFIG_USB_CONN_GPIO=y
+CONFIG_USB=y
+CONFIG_USB_OTG=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_PLATFORM=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_HCD_PLATFORM=y
+CONFIG_USB_R8A66597_HCD=m
+CONFIG_USB_ACM=m
+CONFIG_USB_STORAGE=y
+CONFIG_USB_UAS=m
+CONFIG_USBIP_CORE=m
+CONFIG_USBIP_HOST=m
+CONFIG_USB_DWC2=y
+CONFIG_USB_CHIPIDEA=y
+CONFIG_USB_CHIPIDEA_UDC=y
+CONFIG_USB_CHIPIDEA_HOST=y
+CONFIG_USB_ISP1760=y
+CONFIG_USB_HSIC_USB3503=y
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_AM335X_PHY_USB=m
+CONFIG_USB_GPIO_VBUS=y
+CONFIG_USB_ISP1301=y
+CONFIG_USB_ULPI=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_SNP_UDC_PLAT=y
+CONFIG_USB_BDC_UDC=y
+CONFIG_USB_CONFIGFS=m
+CONFIG_USB_CONFIGFS_SERIAL=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_OBEX=y
+CONFIG_USB_CONFIGFS_NCM=y
+CONFIG_USB_CONFIGFS_ECM=y
+CONFIG_USB_CONFIGFS_ECM_SUBSET=y
+CONFIG_USB_CONFIGFS_RNDIS=y
+CONFIG_USB_CONFIGFS_EEM=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_F_LB_SS=y
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_CONFIGFS_F_UAC1=y
+CONFIG_USB_CONFIGFS_F_UAC1_LEGACY=y
+CONFIG_USB_CONFIGFS_F_UAC2=y
+CONFIG_USB_CONFIGFS_F_MIDI=y
+CONFIG_USB_CONFIGFS_F_HID=y
+CONFIG_USB_CONFIGFS_F_UVC=y
+CONFIG_USB_CONFIGFS_F_PRINTER=y
+CONFIG_USB_ETH=m
+CONFIG_TYPEC=m
+CONFIG_TYPEC_UCSI=m
+CONFIG_UCSI_STM32G0=m
+CONFIG_TYPEC_STUSB160X=m
+CONFIG_MMC=y
+CONFIG_MMC_BLOCK_MINORS=16
+CONFIG_MMC_ARMMMCI=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_OF_ARASAN=y
+CONFIG_MMC_SDHCI_OF_AT91=y
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_EXYNOS=y
+CONFIG_MMC_SDHCI_OMAP=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_CLASS_FLASH=m
+CONFIG_LEDS_CPCAP=m
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_PWM=y
+CONFIG_LEDS_MAX8997=m
+CONFIG_LEDS_MAX77693=m
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_ONESHOT=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_BACKLIGHT=y
+CONFIG_LEDS_TRIGGER_CPU=y
+CONFIG_LEDS_TRIGGER_GPIO=y
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+CONFIG_LEDS_TRIGGER_TRANSIENT=y
+CONFIG_LEDS_TRIGGER_CAMERA=y
+CONFIG_LEDS_TRIGGER_AUDIO=m
+CONFIG_EDAC=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_AS3722=y
+CONFIG_RTC_DRV_DS1307=y
+CONFIG_RTC_DRV_HYM8563=m
+CONFIG_RTC_DRV_MAX8907=y
+CONFIG_RTC_DRV_MAX8998=m
+CONFIG_RTC_DRV_MAX8997=m
+CONFIG_RTC_DRV_MAX77686=y
+CONFIG_RTC_DRV_RK808=m
+CONFIG_RTC_DRV_RS5C372=m
+CONFIG_RTC_DRV_PCF85363=m
+CONFIG_RTC_DRV_BQ32K=m
+CONFIG_RTC_DRV_TWL4030=y
+CONFIG_RTC_DRV_PALMAS=y
+CONFIG_RTC_DRV_TPS6586X=y
+CONFIG_RTC_DRV_TPS65910=y
+CONFIG_RTC_DRV_S35390A=m
+CONFIG_RTC_DRV_RX8581=m
+CONFIG_RTC_DRV_EM3027=y
+CONFIG_RTC_DRV_S5M=m
+CONFIG_RTC_DRV_DA9063=m
+CONFIG_RTC_DRV_PL031=y
+CONFIG_RTC_DRV_STM32=y
+CONFIG_RTC_DRV_CPCAP=m
+CONFIG_DMADEVICES=y
+CONFIG_FSL_EDMA=y
+CONFIG_PL330_DMA=y
+CONFIG_STM32_DMA=y
+CONFIG_STM32_DMAMUX=y
+CONFIG_STM32_MDMA=y
+CONFIG_DW_DMAC=y
+CONFIG_VIRTIO_MMIO=y
+CONFIG_ICST=y
+CONFIG_CLK_SP810=y
+CONFIG_CLK_VEXPRESS_OSC=y
+CONFIG_COMMON_CLK_MAX77686=y
+CONFIG_COMMON_CLK_RK808=m
+CONFIG_COMMON_CLK_S2MPS11=m
+CONFIG_HWSPINLOCK=y
+CONFIG_HWSPINLOCK_STM32=y
+CONFIG_CLKSRC_STM32_LP=y
+CONFIG_MICROCHIP_PIT64B=y
+CONFIG_PL320_MBOX=y
+CONFIG_STM32_IPCC=y
+CONFIG_REMOTEPROC=y
+CONFIG_REMOTEPROC_SRM_CORE=y
+CONFIG_REMOTEPROC_SRM_DEV=y
+CONFIG_STM32_RPROC=y
+CONFIG_RPMSG_VIRTIO=y
+CONFIG_DEVFREQ_GOV_PASSIVE=m
+CONFIG_PM_DEVFREQ_EVENT=y
+CONFIG_EXTCON_MAX14577=m
+CONFIG_EXTCON_MAX77693=m
+CONFIG_EXTCON_MAX8997=m
+CONFIG_MEMORY=y
+CONFIG_STM32_FMC2_EBI=y
+CONFIG_IIO=y
+CONFIG_IIO_SW_TRIGGER=y
+CONFIG_CPCAP_ADC=m
+CONFIG_SD_ADC_MODULATOR=y
+CONFIG_STM32_ADC_CORE=y
+CONFIG_STM32_ADC=y
+CONFIG_STM32_DFSDM_ADC=m
+CONFIG_STMPE_ADC=m
+CONFIG_VF610_ADC=m
+CONFIG_XILINX_XADC=y
+CONFIG_STM32_DAC=y
+CONFIG_MPU3050_I2C=y
+CONFIG_HTS221=y
+CONFIG_IIO_ST_LSM6DSX=m
+CONFIG_CM36651=m
+CONFIG_SENSORS_ISL29018=y
+CONFIG_SENSORS_ISL29028=y
+CONFIG_AK8975=y
+CONFIG_IIO_HRTIMER_TRIGGER=y
+CONFIG_IIO_STM32_LPTIMER_TRIGGER=y
+CONFIG_IIO_ST_PRESS=m
+CONFIG_PWM=y
+CONFIG_PWM_ATMEL_HLCDC_PWM=m
+CONFIG_PWM_FSL_FTM=m
+CONFIG_PWM_STM32=y
+CONFIG_PWM_STM32_LP=y
+CONFIG_PHY_CPCAP_USB=m
+CONFIG_PHY_SAMSUNG_USB2=m
+CONFIG_PHY_STM32_USBPHYC=y
+CONFIG_RAS=y
+CONFIG_NVMEM_STM32_ROMEM=y
+CONFIG_NVMEM_RMEM=m
+CONFIG_FSI=m
+CONFIG_FSI_MASTER_GPIO=m
+CONFIG_FSI_MASTER_HUB=m
+CONFIG_FSI_MASTER_ASPEED=m
+CONFIG_FSI_SCOM=m
+CONFIG_FSI_SBEFIFO=m
+CONFIG_FSI_OCC=m
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_COUNTER=y
+CONFIG_STM32_TIMER_CNT=y
+CONFIG_STM32_LPTIMER_CNT=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+CONFIG_OVERLAY_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_JFFS2_FS=y
+CONFIG_UBIFS_FS=y
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_LZO=y
+CONFIG_SQUASHFS_XZ=y
+CONFIG_PSTORE=y
+CONFIG_PSTORE_CONSOLE=y
+CONFIG_PSTORE_PMSG=y
+CONFIG_PSTORE_RAM=y
+CONFIG_SYSV_FS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_V4_2=y
+CONFIG_ROOT_NFS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_UTF8=y
+CONFIG_CRYPTO_USER=m
+CONFIG_CRYPTO_XTS=m
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_USER_API_HASH=y
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
+CONFIG_CRYPTO_USER_API_RNG=m
+CONFIG_CRYPTO_USER_API_AEAD=m
+CONFIG_CRYPTO_DEV_STM32_CRC=y
+CONFIG_CRYPTO_DEV_STM32_HASH=y
+CONFIG_CRYPTO_DEV_STM32_CRYP=y
+CONFIG_CRYPTO_DEV_AMLOGIC_GXL=m
+CONFIG_CMA_SIZE_MBYTES=128
+CONFIG_PRINTK_TIME=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_DEBUG_SECTION_MISMATCH=y
+# CONFIG_SECTION_MISMATCH_WARN_ONLY is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_FS=y
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_SAMPLES=y
+CONFIG_SAMPLE_RPMSG_CLIENT=m
diff --git a/copy_to_bootfs.sh b/copy_to_bootfs.sh
new file mode 100755
index 000000000..8cedb0b26
--- /dev/null
+++ b/copy_to_bootfs.sh
@@ -0,0 +1,10 @@
+#!/bin/sh
+
+sudo mount /home/assuncao/hub/som/git_lse/stm32mp-yocto/build_diebold/tmp/deploy/images/stm32mp1/st-image-bootfs-poky-stm32mp1.ext4 /mnt
+
+echo "Copiando arquivos para o boot"
+sudo cp ../build-kernel/install_artifact/boot/* /mnt
+sync
+
+echo "desmontando unidade"
+sudo umount /mnt
\ No newline at end of file
diff --git a/copy_to_rootfs.sh b/copy_to_rootfs.sh
new file mode 100755
index 000000000..e317b2d1f
--- /dev/null
+++ b/copy_to_rootfs.sh
@@ -0,0 +1,10 @@
+#!/bin/sh
+
+sudo mount /home/assuncao/hub/som/git_lse/stm32mp-yocto/build_diebold/tmp/deploy/images/stm32mp1/diebold-image-newiop-stm32mp1.ext4 /mnt
+
+echo "Copiando arquivos para o fs"
+sudo cp -r ../build-kernel/install_artifact/lib/modules/ /mnt/lib/
+sync
+
+echo "desmontando unidade"
+sudo umount /mnt
\ No newline at end of file
diff --git a/drivers/Kconfig b/drivers/Kconfig
index 0d399ddaa..086f91652 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -236,4 +236,8 @@ source "drivers/interconnect/Kconfig"
 source "drivers/counter/Kconfig"
 
 source "drivers/most/Kconfig"
+
+source "drivers/sound/Kconfig"
+
+#source "drivers/diebold/Kconfig"
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
index a110338c8..50bc7b082 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -14,6 +14,7 @@ obj-$(CONFIG_GENERIC_PHY)	+= phy/
 # GPIO must come after pinctrl as gpios may need to mux pins etc
 obj-$(CONFIG_PINCTRL)		+= pinctrl/
 obj-$(CONFIG_GPIOLIB)		+= gpio/
+obj-y				+= sound/
 obj-y				+= pwm/
 
 obj-y				+= pci/
@@ -187,3 +188,4 @@ obj-$(CONFIG_GNSS)		+= gnss/
 obj-$(CONFIG_INTERCONNECT)	+= interconnect/
 obj-$(CONFIG_COUNTER)		+= counter/
 obj-$(CONFIG_MOST)		+= most/
+obj-y					+= diebold/
diff --git a/drivers/diebold/Kconfig b/drivers/diebold/Kconfig
new file mode 100644
index 000000000..3dce8f22f
--- /dev/null
+++ b/drivers/diebold/Kconfig
@@ -0,0 +1,7 @@
+config DBDHIDDEVICE
+    tristate "dbdhiddevice"
+    default y
+
+config LINUX_DBDUSB
+    tristate "linux_dbdusb"
+    default y
diff --git a/drivers/diebold/Makefile b/drivers/diebold/Makefile
new file mode 100644
index 000000000..30407c25f
--- /dev/null
+++ b/drivers/diebold/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_DBDHIDDEVICE)  += dbdhiddevice/
+#obj-$(CONFIG_LINUX_DBDUSB)  += linux-dbdusb/
\ No newline at end of file
diff --git a/drivers/diebold/dbdhiddevice/COPYING b/drivers/diebold/dbdhiddevice/COPYING
new file mode 100755
index 000000000..33fc9aedc
--- /dev/null
+++ b/drivers/diebold/dbdhiddevice/COPYING
@@ -0,0 +1,63 @@
+Format: http://www.debian.org/doc/packaging-manuals/copyright-format/1.0/
+
+Files: *
+Copyright: 2000-2017 Diebold Nixdorf Inc.
+License: DieboldNixdorf-Proprietary
+
+License: DieboldNixdorf-Proprietary
+ IMPORTANT NOTICE
+ SOFTWARE LICENSE AGREEMENT
+ 
+ PLEASE READ THIS AGREEMENT CAREFULLY BEFORE INSTALLING OR USING THE SOFTWARE, OR OPERATING THE TERMINAL AND THE SOFTWARE THAT IS INSTALLED THEREON.  
+ 
+ THIS SOFTWARE CONSTITUTES THE CONFIDENTIAL, TRADE SECRET COPYRIGHTED PROPERTY OF DIEBOLD.  IF YOU DO NOT HAVE A WRITTEN SOFTWARE LICENSE AGREEMENT SIGNED BY A DULY AUTHORIZED REPRESENTATIVE OF DIEBOLD AND BY YOU, YOU ARE NOT AUTHORIZED AND IT IS ILLEGAL TO INSTALL, USE OR OPERATE THE SOFTWARE, EXCEPT TO OPERATE THE TERMINAL TO CARRY OUT A PERSONAL FINANCIAL TRANSACTION.  
+ 
+ IF YOU HAVE BEEN AUTHORIZED IN WRITING BY DIEBOLD TO INSTALL AND OPERATE THIS SOFTWARE ON THIS TERMINAL, AND UNLESS A WRITTEN SOFTWARE LICENSE AGREEMENT WITH DIFFERENT TERMS HAS BEEN SIGNED BY A DULY AUTHORIZED REPRESENTATIVE OF DIEBOLD AND BY YOU, THE FOLLOWING TERMS AND CONDITIONS APPLY TO THE POSSESSION, USE, AND OPERATION OF THIS SOFTWARE.  FOR PURPOSES OF THIS AGREEMENT, "YOU" MEANS YOU PERSONALLY AND ANY ENTITY ON WHOSE BEHALF YOU OPERATE THE SOFTWARE AS AN EMPLOYEE OR AGENT, WHICH ENTITY SHALL ALSO BE BOUND BY THE TERMS OF THIS AGREEMENT.  
+ 
+ BY USING OR OPERATING THIS SOFTWARE, YOU AGREE TO ABIDE BY THE TERMS AND CONDITIONS OF YOUR SIGNED WRITTEN LICENSE AGREEMENT FOR THIS SOFTWARE WITH DIEBOLD, OR IF YOU HAVE BEEN AUTHORIZED IN WRITING TO USE THE SOFTWARE BY DIEBOLD BUT HAVE NOT SIGNED A LICENSE AGREEMENT FOR THE SOFTWARE ON THIS TERMINAL STATING DIFFERENT TERMS, THE TERMS STATED HEREIN.  IF YOU DO NOT AGREE TO THE APPLICABLE TERMS AND CONDITIONS, DO NOT USE OR OPERATE THE SOFTWARE, AND CONTACT YOUR DIEBOLD REPRESENTATIVE TO ARRANGE FOR RETURN.
+   
+ Terms and Conditions of License
+ 
+ 1.	License to Use in One Terminal.  Upon payment to Diebold of the applicable license fees, and contingent upon timely payment of each of the applicable annual license fees as they come due, Diebold grants to you a nonexclusive, nontransferable license to operate the one copy of the Diebold produced software ("Software") installed on this terminal.  You are also authorized to operate the Diebold provided third party software (including applicable Mayfair Software) ("Third Party Software") installed in this terminal.  The applicable license terms for the Diebold Software and Third Party Software are as stated in the written license agreement that has been signed by you and Diebold.  However, in the absence of a signed written license agreement, and provided that Diebold has authorized your use in writing and the applicable license fees have at all times been timely paid for the Software, the applicable license terms for the Diebold Software stated herein and the license terms for Third Party Software posted at www.legaltermsatm.com on the date that you first operate this Software shall apply.  If media bearing the Diebold Software or the Third Party Software has been provided with the terminal, such media may be used only by you, provided you are the owner or lessee of the terminal, and only for backup and recovery purposes.  No rights are granted to you, other than those that are expressly granted by the applicable license agreements.  All other rights in the Diebold Software and Third Party Software are reserved to Diebold and the owners of the Third Party Software.  The rights granted to you in the Software extend only for so long as you abide by the applicable terms and as only long as any annual license fees that are required to be paid to keep the Software license in effect have been paid.
+ 
+ 2.	Restrictions on Use and Transfer.  You may not do any of the following:
+ 
+ a.	copy any portion of the Software, except to load it into the memory of this terminal, as expressly authorized in Paragraph 1, above;
+ 
+ b.	transfer any of the Software to anyone other than Diebold (with or without the terminal on which it is originally installed);
+ 
+ c.	rent, lease or loan any portion of the Software (with or without the terminal on which it is installed) to any person;
+ 
+ d.	transfer or make available any portion of the Software to any other person, through a LAN or other local or wide area network;
+ 
+ e.	disclose, reverse engineer, decompile or disassemble any portion of the Software (except to the extent such activity cannot be prohibited by applicable laws);
+ 
+ f.	modify or create any work derivative of the Software; 
+ 
+ g.	use the Software in the business operations of anyone but you; or
+ 
+ h.	operate terminal maintenance or service functions of the Software unless expressly authorized to operate such functions by Diebold in a separate signed written agreement.
+ 
+ You acknowledge and agree that the Diebold Software constitutes confidential trade secret information and copyrighted material which is owned exclusively by Diebold or its suppliers, and any actual or threatened violation of this Agreement shall result in irreparable harm to Diebold or its suppliers, and shall entitle Diebold and its suppliers to an injunction as well as other legal remedies.
+ 
+ 3.	No Warranty / Limited Liability.  UNLESS OTHERWISE EXPRESSLY PROVIDED IN A PREVIOUS WRITTEN AGREEMENT THAT HAS BEEN SIGNED BY BOTH YOU AND DIEBOLD, THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT WARRANTY.  DIEBOLD EXPRESSLY DISCLAIMS THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND NONINFRINGEMENT OF PROPRIETARY RIGHTS.  DIEBOLD'S ENTIRE LIABILITY AND YOUR EXCLUSIVE REMEDY RELATED TO ANY ALLEGED DEFECTS IN THE SOFTWARE ARE LIMITED TO REFUND BY DIEBOLD OF THE LICENSE FEES YOU PAID TO DIEBOLD FOR THE SOFTWARE COPY THAT IS ALLEGED TO BE DEFECTIVE.  NEITHER DIEBOLD NOR ANY OF ITS SUPPLIERS OR CONTRACTORS, DISTRIBUTORS, EMPLOYEES, AFFILIATES OR AGENTS, SHALL BE LIABLE FOR ANY DAMAGES YOU SUSTAIN, INCLUDING WITHOUT LIMITATION, LOSS OF FUNDS, REQUIREMENTS FOR ADDITIONAL EXPENDITURES, DELAYS, OR FOR ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES WHETHER FORESEEABLE OR NOT AND WHICH ARE ALLEGED TO ARISE FROM THE USE OF THE SOFTWARE.  THIS DISCLAIMER OF LIABILITY SHALL BE COMPLETE AND TOTAL TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAWS.
+ 
+ 4.	Miscellaneous Provisions.  
+ 
+ a.	Certain Software may include security features and functions which prevent its operation in certain circumstances, or under conditions in which it is determined that your obligations under the applicable software license terms are not being complied with.  You agree to accept any and all consequences that may result from these features and functions, and you further agree to indemnify Diebold against any claim or loss that may result from the operation of such features and functions, or from any unlicensed, improper or unauthorized use of the Software.
+ 
+ b.	This Agreement is governed by laws of the U.S., State of Ohio, without regard to any conflict of laws provisions thereof.  Any claim you may present against Diebold shall be presented only in a court located in Ohio, and you consent to personal jurisdiction of such courts, and waive any objection as to venue in such courts.
+ 
+ c.	Unless a written software license agreement for the Software on this terminal has been previously signed by a duly authorized representative of Diebold and you, the terms and conditions set forth herein (including the referenced web site terms) constitutes the entire agreement between Diebold and you regarding the Software.  This Agreement may only be modified in a written document that is signed by the duly authorized representatives of both you and Diebold, and the terms set forth in this Agreement shall control over any other agreement or understanding which has terms that are inconsistent with the terms hereof.  If any provision of this Agreement is held in a court or otherwise to be invalid, illegal or otherwise unenforceable, each and every other provision of this Agreement shall remain in full force and effect, except that Diebold shall have the right, at its option at any time upon written notice to you, to terminate all rights granted to you in Part 1 hereof, or otherwise to terminate all rights to use the Software, by giving you written notice.
+ 
+ d.	You certify that by operation or use of this Software indicating agreement to the terms hereof, you have authority to bind the owner and/or lessee responsible for the terminal on which the Software is installed to the terms and conditions of this Agreement.
+ 
+ 
+ MAYFAIR SOFTWARE LICENSE 
+ 
+ 1.    Third Party Software from Mayfair Software as referenced in part 1. above, is copyrighted by the respective authors and use of each program is governed by the respective author's terms posted at www.legaltermsatm.com on the date you first operate the software.  
+ 
+ 2.    Mayfair Software claims copyright in the compilation only.  THIS SOFTWARE IS PROVIDED AS IS AND WITHOUT WARRANTY OF ANY KIND.  The software may be pre- installed on the terminal or provided via other media.  Installation or use of this software or the terminal constitutes your agreement to be legally bound by these terms.  If you do not agree with these terms, do not use or install this software and contact Mayfair Software at www.mayfairsoftware.com to arrange for return of the software and a refund of the value of the media.
+ 
+ 3.    NEITHER MAYFAIR SOFTWARE DISTRIBUTION, INC., NOR ITS AGENTS, DISTRIBUTORS, AFFILIATES, SUPPLIERS OR CONTENT PROVIDERS, SHALL BE LIABLE FOR ANY VIOLATION OF INTELLECTUAL PROPERTY RIGHTS OR FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING FROM OR RELATING TO THE SOFTWARE ON THIS TERMINAL.  THE LIABILITY OF ANY SUCH ENTITIES IS LIMITED SOLELY AND EXCLUSIVELY TO REFUNDING THE VALUE OF THE CD MEDIA ON WHICH THE SOFTWARE MAY BE PROVIDED OR U.S. $5.00, WHICHEVER IS GREATER.
+ 
\ No newline at end of file
diff --git a/drivers/diebold/dbdhiddevice/Kconfig b/drivers/diebold/dbdhiddevice/Kconfig
new file mode 100644
index 000000000..ee6097f3b
--- /dev/null
+++ b/drivers/diebold/dbdhiddevice/Kconfig
@@ -0,0 +1,7 @@
+config dbdhiddevice
+    tristate "Driver diebold"
+    default m
+
+config f_hid
+    tristate "f_hid"
+    default m
\ No newline at end of file
diff --git a/drivers/diebold/dbdhiddevice/Makefile b/drivers/diebold/dbdhiddevice/Makefile
new file mode 100755
index 000000000..23af17e12
--- /dev/null
+++ b/drivers/diebold/dbdhiddevice/Makefile
@@ -0,0 +1,2 @@
+obj-m			+= dbdhiddevice.o
+obj-m			+= f_hid.o
diff --git a/drivers/diebold/dbdhiddevice/dbdhiddevice.c b/drivers/diebold/dbdhiddevice/dbdhiddevice.c
new file mode 100755
index 000000000..ab581496c
--- /dev/null
+++ b/drivers/diebold/dbdhiddevice/dbdhiddevice.c
@@ -0,0 +1,447 @@
+/*
+ * hid.c -- HID Composite driver
+ *
+ * Based on multi.c
+ *
+ * Copyright (C) 2010 Fabien Chouteau <fabien.chouteau@barco.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+
+
+#define VERBOSE_DEBUG
+
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/usb/composite.h>
+#include <linux/usb/g_hid.h>
+
+//#include "gadget_chips.h"
+
+#define DRIVER_DESC		"Diebold OSI Composite Gadget"
+#define DRIVER_VERSION	"2012/11/16"
+
+/*-------------------------------------------------------------------------*/
+
+#define OSIG_VENDOR_NUM		0x03f4	/* Diebold */
+#define OSIG_PRODUCT_NUM	0x1024	/* OSI */
+
+#define TPD_DEFAULT_PRODUC_ID 0x1234
+#define TPD_DEFAULT_VENDOR_ID 0x4567
+
+#include "u_hid.h"
+
+
+static int id_Product = TPD_DEFAULT_PRODUC_ID;
+static char *i_Product = DRIVER_DESC;
+static char *i_SerialNumber = "Z9999999991";
+
+//static int g_pid_tpd = idProduct;
+
+/* hid descriptor for a keyboard */
+static struct hidg_func_descriptor diebold_hid_data = {
+	.subclass		= 0, /* No subclass */
+	.protocol		= 0, /* No protocol */
+	.report_length		= 1024,  /* DYNAMIC: !!!! MUST BE 1024 (size of largest endpoint) !!!!              *
+                               * This value will be altered to match the endpoint size at hidg_set_alt,  *
+                               * but it is used to allocate buffer space for some variables. It should   *
+                               * only be altered if the endpoint size is also altered. In this case, it  *
+                               * might be also necessary to alter hidg_set_alt.                          */
+	.report_desc_length	= 66,
+	.report_desc		= {   /* ** WARNING ** IF this descriptor is modified, the defines       *
+                            * of the positions of all the "Report count" used in hidg_set_alt *
+                            * should be altered to match the modification                     */
+			0x06, 0x10, 0xFF, // Usage vendor page
+			0x09, 0x01,       // Usage reserved
+			0xA1, 0x01,       // Collection application
+			0x09, 0x01,       // Usage reserved
+			0xA1, 0x00,       // Collection physical
+
+			0x85, 0x17,       // Report ID 1
+			0x09, 0x02,       // HID usage
+			0x15, 0x00,       // Logical min
+			0x26, 0xFF, 0x00, // Logical max
+			0x75, 0x08,       // Report size
+			//0x95, 0x3F,       // Report count
+         0x96, 0xFF, 0x03, // Report count - DYNAMIC: This value will be altered to match the report length
+			0x82, 0x02, 0x01, // INPUT DATA|VARIABLE|ABSOLUTE
+
+			0x85, 0x17,       // Report ID 1
+			0x09, 0x04,       // HID usage
+			0x75, 0x08,       // Report size
+			//0x95, 0x3F,       // Report count
+         0x96, 0xFF, 0x03, // Report count - DYNAMIC: This value will be altered to match the report length
+			0x92, 0x02, 0x01, // OUTPUT DATA|VARIABLE|ABSOLUTE
+
+			0x85, 0x1E,       // Report ID 2
+			0x09, 0x05,       // HID usage
+//			0x15, 0x00,       // Logical min
+//			0x26, 0xFF, 0x00, // Logical max
+			0x75, 0x08,       // Report size
+			//0x95, 0x3F,       // Report count
+         0x96, 0xFF, 0x03, // Report count - DYNAMIC: This value will be altered to match the report length
+			0x82, 0x02, 0x01, // INPUT DATA|VARIABLE|ABSOLUTE
+
+			0x85, 0x1E,       // Report ID 2
+			0x09, 0x03,       // HID usage
+			0x75, 0x08,       // Report size
+			//0x95, 0x3F,       // Report count
+         0x96, 0xFF, 0x03, // Report count - DYNAMIC: This value will be altered to match the report length
+			0x92, 0x02, 0x01, // OUTPUT DATA|VARIABLE|ABSOLUTE
+
+			0xC0,
+
+			0xC0
+	}
+};
+
+static struct platform_device my_hid = {
+	.name			= "hidg",
+	.id			= 0,
+	.num_resources		= 0,
+	.resource		= 0,
+	.dev.platform_data	= &diebold_hid_data,
+};
+
+
+struct hidg_func_node {
+	struct usb_function_instance *fi;
+	struct usb_function *f;
+	struct list_head node;
+	struct hidg_func_descriptor *func;
+};
+
+static LIST_HEAD(hidg_func_list);
+
+/*-------------------------------------------------------------------------*/
+USB_GADGET_COMPOSITE_OPTIONS();
+
+static struct usb_device_descriptor tpd_device_desc = {
+	.bLength =		sizeof tpd_device_desc,
+	.bDescriptorType =	USB_DT_DEVICE,
+
+	.bcdUSB =		cpu_to_le16(0x0200),
+
+	/* .bDeviceClass =		USB_CLASS_COMM, */
+	/* .bDeviceSubClass =	0, */
+	/* .bDeviceProtocol =	0, */
+	.bDeviceClass =		0x00,
+	.bDeviceSubClass =	0,
+	.bDeviceProtocol =	0,
+	/* .bMaxPacketSize0 = f(hardware) */
+
+	/* Vendor and product id can be overridden by module parameters.  */
+	.idVendor =			cpu_to_le16(TPD_DEFAULT_VENDOR_ID),
+	.idProduct =		cpu_to_le16(TPD_DEFAULT_PRODUC_ID),
+	/* .bcdDevice = f(hardware) */
+	/* .iManufacturer = DYNAMIC */
+	/* .iProduct = DYNAMIC */
+	/* NO SERIAL NUMBER */
+	.bNumConfigurations =	1,
+};
+
+//static const struct usb_descriptor_header *otg_desc[2];
+static struct usb_descriptor_header *otg_desc[2];
+
+/* string IDs are assigned dynamically */
+static struct usb_string tpd_strings_dev[] = {
+	[USB_GADGET_MANUFACTURER_IDX].s = "Diebold Nixdorf Inc.",
+	//[USB_GADGET_PRODUCT_IDX].s = DRIVER_DESC,
+	//[USB_GADGET_SERIAL_IDX].s = "X9999999999",
+	{  } /* end of list */
+};
+
+static struct usb_gadget_strings stringtab_dev = {
+	.language	= 0x0409,	/* en-us */
+	.strings	= tpd_strings_dev,
+};
+
+static struct usb_gadget_strings *dev_strings[] = {
+	&stringtab_dev,
+	NULL,
+};
+
+module_param(id_Product, int, 0);
+MODULE_PARM_DESC(id_Product, "USB Product ID");
+
+module_param(i_Product, charp, 0);
+MODULE_PARM_DESC(i_Product, "USB Product string");
+
+module_param(i_SerialNumber, charp, 0);
+MODULE_PARM_DESC(i_SerialNumber, "Serial Number string");
+
+/****************************** Configurations ******************************/
+
+static int do_config(struct usb_configuration *c)
+{
+	struct hidg_func_node *e, *n;
+	int status = 0;
+
+	if (gadget_is_otg(c->cdev->gadget)) {
+		c->descriptors = (const struct usb_descriptor_header **)otg_desc;
+		c->bmAttributes |= USB_CONFIG_ATT_WAKEUP;
+	}
+
+	list_for_each_entry(e, &hidg_func_list, node) {
+		e->f = usb_get_function(e->fi);
+		if (IS_ERR(e->f))
+			goto put;
+		status = usb_add_function(c, e->f);
+		if (status < 0) {
+			usb_put_function(e->f);
+			goto put;
+		}
+	}
+
+	return 0;
+put:
+	list_for_each_entry(n, &hidg_func_list, node) {
+		if (n == e)
+			break;
+		usb_remove_function(c, n->f);
+		usb_put_function(n->f);
+	}
+	return status;
+}
+
+static struct usb_configuration config_driver = {
+	.label			= "HID Gadget",
+	.bConfigurationValue	= 1,
+	/* .iConfiguration = DYNAMIC */
+	.bmAttributes		= USB_CONFIG_ATT_SELFPOWER,
+};
+
+/****************************** Gadget Bind ******************************/
+
+static int hid_bind(struct usb_composite_dev *cdev)
+{
+	struct usb_gadget *gadget = cdev->gadget;
+	struct list_head *tmp;
+	struct hidg_func_node *n, *m;
+	struct f_hid_opts *hid_opts;
+	int status, funcs = 0;
+    //int *IDPRO = (int *)&cdev->driver->dev->idProduct;
+
+	list_for_each(tmp, &hidg_func_list)
+		funcs++;
+
+	if (!funcs)
+    {
+		return -ENODEV;
+    }
+
+	list_for_each_entry(n, &hidg_func_list, node)
+    {
+		n->fi = usb_get_function_instance("hid");
+		if (IS_ERR(n->fi))
+      {
+			status = PTR_ERR(n->fi);
+         printk("%s: usb_get_function_instance ERROR status=%d\n", __func__, status );
+			goto put;
+		}
+		hid_opts = container_of(n->fi, struct f_hid_opts, func_inst);
+		hid_opts->subclass = n->func->subclass;
+		hid_opts->protocol = n->func->protocol;
+		hid_opts->report_length = n->func->report_length;
+		hid_opts->report_desc_length = n->func->report_desc_length;
+		hid_opts->report_desc = n->func->report_desc;
+	}
+
+
+	/* Allocate string descriptor numbers ... note that string
+	 * contents can be overridden by the composite_dev glue.
+	 */
+
+	status = usb_string_ids_tab(cdev, tpd_strings_dev);
+	if (status < 0)
+    {
+		printk("%s: usb_string_ids_tab ERROR status=%d\n", __func__, status );
+		goto put;
+    }
+
+	tpd_device_desc.iManufacturer = tpd_strings_dev[USB_GADGET_MANUFACTURER_IDX].id;
+	tpd_device_desc.iProduct = tpd_strings_dev[USB_GADGET_PRODUCT_IDX].id;
+	tpd_device_desc.iSerialNumber = tpd_strings_dev[USB_GADGET_SERIAL_IDX].id;
+
+	if (gadget_is_otg(gadget) && !otg_desc[0])
+    {
+		struct usb_descriptor_header *usb_desc;
+      
+		printk("%s: gadget_is_otg && otg_desc[0]=%p\n", __func__, otg_desc[0] );
+
+		usb_desc = usb_otg_descriptor_alloc(gadget);
+		if (!usb_desc)
+        {
+			printk("%s: usb_otg_descriptor_alloc ERROR status=%d\n", __func__, status );
+			goto put;
+        }
+		usb_otg_descriptor_init(gadget, usb_desc);
+		otg_desc[0] = usb_desc;
+		otg_desc[1] = NULL;
+	}
+
+	/* register our configuration */
+	status = usb_add_config(cdev, &config_driver, do_config);
+	if (status < 0)
+    {
+		printk("%s: usb_add_config ERROR status=%d\n", __func__, status );
+		goto free_otg_desc;
+    }
+
+	usb_composite_overwrite_options(cdev, &coverwrite);
+	dev_info(&gadget->dev, DRIVER_DESC ", version: " DRIVER_VERSION "\n");
+	printk("O product em tpd_device_desc = %i e tpd_strings_dev = %s \n", tpd_device_desc.iProduct, tpd_strings_dev[USB_GADGET_PRODUCT_IDX].s);
+	return 0;
+
+free_otg_desc:
+	kfree(otg_desc[0]);
+	otg_desc[0] = NULL;
+put:
+	list_for_each_entry(m, &hidg_func_list, node)
+	{
+		if (m == n)
+			break;
+		usb_put_function_instance(m->fi);
+	}
+   
+	printk("%s: END status=%d\n", __func__, status );
+	return status;
+}
+
+static int hid_unbind(struct usb_composite_dev *cdev)
+{
+	struct hidg_func_node *n;
+   
+//   printk("%s: BEGIN\n", __func__ );
+
+	list_for_each_entry(n, &hidg_func_list, node) {
+		usb_put_function(n->f);
+		usb_put_function_instance(n->fi);
+	}
+
+	kfree(otg_desc[0]);
+	otg_desc[0] = NULL;
+   
+//	printk("%s: END\n", __func__ );
+
+	return 0;
+}
+
+static int hidg_plat_driver_probe(struct platform_device *pdev)
+{
+	struct hidg_func_descriptor *func = dev_get_platdata(&pdev->dev);
+	struct hidg_func_node *entry;
+
+	if (!func) {
+		dev_err(&pdev->dev, "Platform data missing\n");
+		return -ENODEV;
+	}
+
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	if (!entry)
+		return -ENOMEM;
+
+	entry->func = func;
+	list_add_tail(&entry->node, &hidg_func_list);
+
+	return 0;
+}
+
+static int hidg_plat_driver_remove(struct platform_device *pdev)
+{
+	struct hidg_func_node *e, *n;
+
+	list_for_each_entry_safe(e, n, &hidg_func_list, node) {
+		list_del(&e->node);
+		kfree(e);
+	}
+
+	return 0;
+}
+
+
+/****************************** Some noise ******************************/
+
+
+static struct usb_composite_driver hidg_driver = {
+	.name		= "g_dbdhiddevice",
+	.dev		= &tpd_device_desc,
+	.strings	= dev_strings,
+	.max_speed	= USB_SPEED_HIGH,
+	.bind		= hid_bind,
+	.unbind		= hid_unbind,
+};
+/*
+static struct platform_driver hidg_plat_driver = {
+	.remove		= hidg_plat_driver_remove,
+	.driver		= {
+		.name	= "hidg",
+	},
+};
+*/
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("Fabien Chouteau, Peter Korsgaard");
+MODULE_LICENSE("GPL");
+
+static int __init hidg_init(void)
+{
+	int status;
+
+//	printk("%s: BEGIN\n", __func__ );
+	printk("Valor de entrada: PID=%X sPID=%s sSN=%s\n", id_Product, i_Product, i_SerialNumber);
+	
+	if (id_Product == 0)
+		tpd_device_desc.idProduct =	cpu_to_le16(TPD_DEFAULT_PRODUC_ID);
+	else
+		tpd_device_desc.idProduct =	cpu_to_le16(id_Product);	
+	
+	status = strlen(i_Product);
+	if ((status <= 32) && (status > 0)){
+		//kfree((void *)tpd_strings_dev[USB_GADGET_PRODUCT_IDX].s);
+		tpd_strings_dev[USB_GADGET_PRODUCT_IDX].s = kmalloc(strlen(i_Product) + 1, GFP_KERNEL);
+		strcpy((char *)tpd_strings_dev[USB_GADGET_PRODUCT_IDX].s, i_Product);
+	}
+
+	status = strlen(i_SerialNumber);
+	if ((status <= 11) && (status > 0)){
+		//kfree((void *)tpd_strings_dev[USB_GADGET_SERIAL_IDX].s);
+		tpd_strings_dev[USB_GADGET_SERIAL_IDX].s = kmalloc(strlen(i_SerialNumber) + 1, GFP_KERNEL);
+		strcpy((char *)tpd_strings_dev[USB_GADGET_SERIAL_IDX].s, i_SerialNumber);
+	}
+
+	status = hidg_plat_driver_probe( &my_hid );
+	if(status < 0)
+	{
+		printk("%s: hidg_plat_driver_probe error %d\n", __func__, status );
+		return status;
+	}
+
+	status = usb_composite_probe(&hidg_driver);
+	if (status < 0)
+	{
+		printk("%s: usb_composite_probe error %d\n", __func__, status );
+	}
+
+//	printk("%s: END error %d\n", __func__, status );
+
+	return status;
+}
+module_init(hidg_init);
+
+static void __exit hidg_cleanup(void)
+{
+	usb_composite_unregister(&hidg_driver);
+	hidg_plat_driver_remove( &my_hid );
+	//platform_driver_unregister(&hidg_plat_driver);
+	kfree((void *)tpd_strings_dev[USB_GADGET_PRODUCT_IDX].s);
+    kfree((void *)tpd_strings_dev[USB_GADGET_SERIAL_IDX].s);
+}
+module_exit(hidg_cleanup);
diff --git a/drivers/diebold/dbdhiddevice/f_hid.c b/drivers/diebold/dbdhiddevice/f_hid.c
new file mode 100755
index 000000000..cad42d36f
--- /dev/null
+++ b/drivers/diebold/dbdhiddevice/f_hid.c
@@ -0,0 +1,1183 @@
+/*
+ * f_hid.c -- USB HID function driver
+ *
+ * Copyright (C) 2010 Fabien Chouteau <fabien.chouteau@barco.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/hid.h>
+#include <linux/idr.h>
+#include <linux/cdev.h>
+#include <linux/mutex.h>
+#include <linux/poll.h>
+#include <linux/uaccess.h>
+#include <linux/wait.h>
+//#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/device.h>
+#include <linux/usb/g_hid.h>
+#include <asm/io.h>
+
+#include <linux/usb/composite.h>
+
+#include "u_f.h"
+#include "u_hid.h"
+#include "g_tpd.h"
+
+#define HIDG_MINORS	4
+#define	UBS_UOG_OTGSC	0x53F801A4
+#define	UBS_UOG_1OTGSC  0x02184000 + 0x1A4
+#define	UBS_UOG_2OTGSC  0x02184000 + 0x1A4 + 512 
+#define USB_1PORTSC1	0x02184000 + 0x184
+#define USB_2PORTSC1	0x02184000 + 0x184 + 512
+
+#define TPD_DEFAULT_PRODUC_ID	0x2019	/* IOP     */
+
+static int major, minors;
+static struct class *hidg_class;
+static DEFINE_IDA(hidg_ida);
+static DEFINE_MUTEX(hidg_ida_lock); /* protects access to hidg_ida */
+//extern struct usb_device_descriptor tpd_device_desc;
+//extern struct usb_string tpd_strings_dev[];
+static int IDP_ORI = TPD_DEFAULT_PRODUC_ID;
+/*-------------------------------------------------------------------------*/
+/*                            HID gadget struct                            */
+
+struct mngr_dev {
+	atomic_t	in_use;
+	atomic_t	connected;
+	atomic_t	unbind_event;
+};
+
+//static struct mngr_dev *_mngr_dev;
+static struct mngr_dev _mngr_dev;
+
+u32 __iomem usgotgsc_addr;
+static struct usb_composite_overwrite coverwrite;
+struct usb_udc {
+	struct usb_gadget_driver	*driver;
+	struct usb_gadget		*gadget;
+	struct device			dev;
+	struct list_head		list;
+	bool				vbus;
+};
+
+struct f_hidg_req_list {
+	struct usb_request	*req;
+	unsigned int		pos;
+	struct list_head 	list;
+};
+
+struct f_hidg {
+	/* configuration */
+	unsigned char			bInterfaceSubClass;
+	unsigned char			bInterfaceProtocol;
+	unsigned short			report_desc_length;
+	char				*report_desc;
+	unsigned short			report_length;
+
+	/* recv report */
+	struct list_head		completed_out_req;
+	spinlock_t			spinlock;
+	wait_queue_head_t		read_queue;
+	unsigned int			qlen;
+
+	/* send report */
+	struct mutex			lock;
+	bool				write_pending;
+	wait_queue_head_t		write_queue;
+	struct usb_request		*req;
+
+	int				minor;
+	struct cdev			cdev;
+	struct usb_function		func;
+
+	struct usb_ep			*in_ep;
+	struct usb_ep			*out_ep;
+};
+
+static inline struct f_hidg *func_to_hidg(struct usb_function *f)
+{
+	return container_of(f, struct f_hidg, func);
+}
+
+/*-------------------------------------------------------------------------*/
+/*                           Static descriptors                            */
+
+static struct usb_interface_descriptor hidg_interface_desc = {
+	.bLength		= sizeof hidg_interface_desc,
+	.bDescriptorType	= USB_DT_INTERFACE,
+	/* .bInterfaceNumber	= DYNAMIC */
+	.bAlternateSetting	= 0,
+	.bNumEndpoints		= 2,
+	.bInterfaceClass	= USB_CLASS_HID,
+	/* .bInterfaceSubClass	= DYNAMIC */
+	/* .bInterfaceProtocol	= DYNAMIC */
+	/* .iInterface		= DYNAMIC */
+};
+
+static struct hid_descriptor hidg_desc = {
+	.bLength			= sizeof hidg_desc,
+	.bDescriptorType		= HID_DT_HID,
+	.bcdHID				= 0x0101,
+	.bCountryCode			= 0x00,
+	.bNumDescriptors		= 0x1,
+	/*.desc[0].bDescriptorType	= DYNAMIC */
+	/*.desc[0].wDescriptorLenght	= DYNAMIC */
+};
+
+/* High-Speed Support */
+
+static struct usb_endpoint_descriptor hidg_hs_in_ep_desc = {
+	.bLength		= USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType	= USB_DT_ENDPOINT,
+	.bEndpointAddress	= USB_DIR_IN,
+	.bmAttributes		= USB_ENDPOINT_XFER_INT,
+	/*.wMaxPacketSize	= DYNAMIC */
+	.bInterval		= 4, /* FIXME: Add this field in the
+				      * HID gadget configuration?
+				      * (struct hidg_func_descriptor)
+				      */
+};
+
+static struct usb_endpoint_descriptor hidg_hs_out_ep_desc = {
+	.bLength		= USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType	= USB_DT_ENDPOINT,
+	.bEndpointAddress	= USB_DIR_OUT,
+	.bmAttributes		= USB_ENDPOINT_XFER_INT,
+	/*.wMaxPacketSize	= DYNAMIC */
+	.bInterval		= 4, /* FIXME: Add this field in the
+				      * HID gadget configuration?
+				      * (struct hidg_func_descriptor)
+				      */
+};
+
+static struct usb_descriptor_header *hidg_hs_descriptors[] = {
+	(struct usb_descriptor_header *)&hidg_interface_desc,
+	(struct usb_descriptor_header *)&hidg_desc,
+	(struct usb_descriptor_header *)&hidg_hs_in_ep_desc,
+	(struct usb_descriptor_header *)&hidg_hs_out_ep_desc,
+	NULL,
+};
+
+/* Full-Speed Support */
+
+static struct usb_endpoint_descriptor hidg_fs_in_ep_desc = {
+	.bLength		= USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType	= USB_DT_ENDPOINT,
+	.bEndpointAddress	= USB_DIR_IN,
+	.bmAttributes		= USB_ENDPOINT_XFER_INT,
+	/*.wMaxPacketSize	= DYNAMIC */
+	.bInterval		= 10, /* FIXME: Add this field in the
+				       * HID gadget configuration?
+				       * (struct hidg_func_descriptor)
+				       */
+};
+
+static struct usb_endpoint_descriptor hidg_fs_out_ep_desc = {
+	.bLength		= USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType	= USB_DT_ENDPOINT,
+	.bEndpointAddress	= USB_DIR_OUT,
+	.bmAttributes		= USB_ENDPOINT_XFER_INT,
+	/*.wMaxPacketSize	= DYNAMIC */
+	.bInterval		= 10, /* FIXME: Add this field in the
+				       * HID gadget configuration?
+				       * (struct hidg_func_descriptor)
+				       */
+};
+
+static struct usb_descriptor_header *hidg_fs_descriptors[] = {
+	(struct usb_descriptor_header *)&hidg_interface_desc,
+	(struct usb_descriptor_header *)&hidg_desc,
+	(struct usb_descriptor_header *)&hidg_fs_in_ep_desc,
+	(struct usb_descriptor_header *)&hidg_fs_out_ep_desc,
+	NULL,
+};
+
+/*-------------------------------------------------------------------------*/
+/*                                 Strings                                 */
+
+#define CT_FUNC_HID_IDX	0
+
+static struct usb_string ct_func_string_defs[] = {
+	[CT_FUNC_HID_IDX].s	= "HID Interface",
+	{},			/* end of list */
+};
+
+static struct usb_gadget_strings ct_func_string_table = {
+	.language	= 0x0409,	/* en-US */
+	.strings	= ct_func_string_defs,
+};
+
+static struct usb_gadget_strings *ct_func_strings[] = {
+	&ct_func_string_table,
+	NULL,
+};
+
+/*-------------------------------------------------------------------------*/
+/*                              Char Device                                */
+
+static ssize_t f_hidg_read(struct file *file, char __user *buffer,
+			size_t count, loff_t *ptr)
+{
+	struct f_hidg *hidg = file->private_data;
+	struct f_hidg_req_list *list;
+	struct usb_request *req;
+	unsigned long flags;
+	int ret;
+
+	if (!count)
+		return 0;
+
+	if (!access_ok(buffer, count))
+		return -EFAULT;
+
+	spin_lock_irqsave(&hidg->spinlock, flags);
+
+#define READ_COND (!list_empty(&hidg->completed_out_req))
+
+	/* wait for at least one buffer to complete */
+	while (!READ_COND) {
+		spin_unlock_irqrestore(&hidg->spinlock, flags);
+		if (file->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+
+		if (wait_event_interruptible(hidg->read_queue, READ_COND))
+			return -ERESTARTSYS;
+
+		spin_lock_irqsave(&hidg->spinlock, flags);
+	}
+
+	/* pick the first one */
+	list = list_first_entry(&hidg->completed_out_req,
+				struct f_hidg_req_list, list);
+	req = list->req;
+	count = min_t(unsigned int, count, req->actual - list->pos);
+	spin_unlock_irqrestore(&hidg->spinlock, flags);
+
+	/* copy to user outside spinlock */
+	count -= copy_to_user(buffer, req->buf + list->pos, count);
+	list->pos += count;
+
+	/*
+	 * if this request is completely handled and transfered to
+	 * userspace, remove its entry from the list and requeue it
+	 * again. Otherwise, we will revisit it again upon the next
+	 * call, taking into account its current read position.
+	 */
+	if (list->pos == req->actual) {
+		spin_lock_irqsave(&hidg->spinlock, flags);
+		list_del(&list->list);
+		kfree(list);
+		spin_unlock_irqrestore(&hidg->spinlock, flags);
+
+		req->length = hidg->report_length;
+		ret = usb_ep_queue(hidg->out_ep, req, GFP_KERNEL);
+		if (ret < 0)
+			return ret;
+	}
+
+	return count;
+}
+
+static void f_hidg_req_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	struct f_hidg *hidg = (struct f_hidg *)ep->driver_data;
+
+	if (req->status != 0) {
+		ERROR(hidg->func.config->cdev,
+			"End Point Request ERROR: %d\n", req->status);
+	}
+
+	hidg->write_pending = 0;
+	wake_up(&hidg->write_queue);
+}
+
+static ssize_t f_hidg_write(struct file *file, const char __user *buffer,
+			    size_t count, loff_t *offp)
+{
+	struct f_hidg *hidg  = file->private_data;
+	ssize_t status = -ENOMEM;
+
+	if (!access_ok(buffer, count))
+		return -EFAULT;
+
+	mutex_lock(&hidg->lock);
+
+#define WRITE_COND (!hidg->write_pending)
+
+	/* write queue */
+	while (!WRITE_COND) {
+		mutex_unlock(&hidg->lock);
+		if (file->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+
+		if (wait_event_interruptible_exclusive(
+				hidg->write_queue, WRITE_COND))
+			return -ERESTARTSYS;
+
+		mutex_lock(&hidg->lock);
+	}
+
+	count  = min_t(unsigned, count, hidg->report_length);
+	status = copy_from_user(hidg->req->buf, buffer, count);
+
+	if (status != 0) {
+		ERROR(hidg->func.config->cdev,
+			"copy_from_user error\n");
+		mutex_unlock(&hidg->lock);
+		return -EINVAL;
+	}
+
+	hidg->req->status   = 0;
+	hidg->req->zero     = 0;
+	hidg->req->length   = count;
+	hidg->req->complete = f_hidg_req_complete;
+	hidg->req->context  = hidg;
+	hidg->write_pending = 1;
+
+	status = usb_ep_queue(hidg->in_ep, hidg->req, GFP_ATOMIC);
+	if (status < 0) {
+		ERROR(hidg->func.config->cdev,
+			"usb_ep_queue error on int endpoint %zd\n", status);
+		hidg->write_pending = 0;
+		wake_up(&hidg->write_queue);
+	} else {
+		status = count;
+	}
+
+	mutex_unlock(&hidg->lock);
+
+	return status;
+}
+
+static unsigned int f_hidg_poll(struct file *file, poll_table *wait)
+{
+	struct f_hidg	*hidg  = file->private_data;
+	unsigned int	ret = 0;
+
+	poll_wait(file, &hidg->read_queue, wait);
+	poll_wait(file, &hidg->write_queue, wait);
+
+	if (WRITE_COND)
+		ret |= POLLOUT | POLLWRNORM;
+
+	if (READ_COND)
+		ret |= POLLIN | POLLRDNORM;
+
+	return ret;
+}
+static long tpd_hidg_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long argp)
+{
+#define BUFF_SIZE	100
+	struct f_hidg	*hidg  = file->private_data;
+	struct usb_composite_dev		*cdev = hidg->func.config->cdev;
+	struct usb_composite_driver		*hid_driver = cdev->driver;
+	struct mngr_dev *mdev = &_mngr_dev;
+	u32 status;
+	volatile u32 reg;
+	volatile u32 reg2;
+	unsigned long __user *datap = (unsigned long __user *)argp;
+	char * buf_ioctl = (char *) argp;
+	u32 i_g_pid = argp;
+	int ret, len;
+	unsigned char buf_rec[BUFF_SIZE + 1];
+	int *IDP = (int *)&hid_driver->dev->idProduct;
+
+	memset(buf_rec, 0, sizeof(buf_rec));
+	memset(&coverwrite, 0, sizeof(coverwrite));
+
+	//printk("** %s: recebeu cmd: %d\n", __func__, cmd );
+
+	reg = hidg->func.config->cdev->gadget->state;
+
+	switch (cmd)
+	{
+		case GIIOC_CONNECT:
+			if ((atomic_read(&mdev->connected) == 0) && (0 != hidg->func.config->cdev->gadget->state))
+			{
+//				usb_gadget_vbus_connect (hidg->func.config->cdev->gadget);
+				usb_gadget_connect(hidg->func.config->cdev->gadget);
+				atomic_set(&mdev->connected, 1);
+			}
+			break;
+
+		case GIIOC_DISCONNECT:
+			if ( atomic_read(&mdev->connected) == 1)
+			{
+				atomic_set(&mdev->connected, 0);
+//				usb_gadget_vbus_disconnect(hidg->func.config->cdev->gadget);
+				usb_gadget_disconnect(hidg->func.config->cdev->gadget);
+			}
+			break;
+
+		case GIIOC_SETSN:
+			len = strlen(buf_ioctl);
+			copy_from_user(buf_rec, buf_ioctl, len);
+//			printk(KERN_INFO "** %s - Handled SN set call - (%d) %s\n", __func__, len, buf_rec);
+//			printk(KERN_INFO "** %s - Old SN %s\n", __func__, hid_driver->strings[0]->strings[USB_GADGET_SERIAL_IDX].s);
+			if ( len > 11 )
+			{
+				printk(KERN_ERR "** %s - serial number not set. Buffer is too long.\n", __func__);
+				return -1;
+			}
+			memset(hid_driver->strings[0]->strings[USB_GADGET_SERIAL_IDX].s, 0, 11 );              // Clear previous SN
+			memcpy(hid_driver->strings[0]->strings[USB_GADGET_SERIAL_IDX].s, buf_rec, len);    // Set new SN
+//			printk(KERN_INFO "** %s - New SN %s\n", __func__, hid_driver->strings[0]->strings[USB_GADGET_SERIAL_IDX].s);
+			return len;
+
+		case GIIOC_SETPN:
+			len = strlen(buf_ioctl);
+			copy_from_user(buf_rec, buf_ioctl, len);
+//			printk(KERN_INFO "** %s - Handled Product Name set call - (%d) %s\n", __func__, len, buf_rec);
+//			printk(KERN_INFO "** %s - Old Product Name: %s\n", __func__, hid_driver->strings[0]->strings[USB_GADGET_PRODUCT_IDX].s);
+			if ( len > 32 )
+			{
+				printk(KERN_ERR "** %s - Product Name not set. Buffer is too long.\n", __func__);
+				return -1;
+			}
+			memset(hid_driver->strings[0]->strings[USB_GADGET_PRODUCT_IDX].s, 0, 32 );
+			memcpy(hid_driver->strings[0]->strings[USB_GADGET_PRODUCT_IDX].s, buf_rec, len);
+//			printk(KERN_INFO "** %s - New Product Name %s\n", __func__, hid_driver->strings[0]->strings[USB_GADGET_PRODUCT_IDX].s);
+			return len;
+
+		case GIIOC_SETID:
+//			printk(KERN_INFO "** %s - Handled PID set call - old=%lx xxx\n", __func__, *IDP);
+//			printk(KERN_INFO "** new=%lx x\n", i_g_pid);
+			if (IDP_ORI != i_g_pid)
+			{
+				coverwrite.idProduct = cpu_to_le16(i_g_pid);
+				printk("**@ usb_composite_overwrite_options idProduct=%X\n", coverwrite.idProduct);
+				usb_composite_overwrite_options(cdev, &coverwrite);
+
+				IDP_ORI = i_g_pid;
+			}
+
+			break;
+
+		case GIIOC_GETSTATUS:
+			// D7 D6 D5 D4 D3 D2 D1 D0
+			//  |  |  |  |  \--\--\--\---- GADGET STATE
+			//  |  |  |  \---------------- GADGET DRIVER ACTIVE
+			//  \--\--\------------------- FURTHER USE
+
+
+			reg = 0;
+
+			reg = hidg->func.config->cdev->gadget->state;
+//			reg2 = hidg->func.config->cdev->gadget->udc->vbus;
+//			printk(KERN_INFO "** GETSTATUS d state=0x%X 0x%X\n", reg, reg2);
+
+			status = (reg & 0xff);	
+			
+			if ( atomic_read(&mdev->connected) )
+				status |= 0x10; //0x02;
+
+//			printk(KERN_INFO "** GETSTATUS z status=0x%X\n", status);
+			ret = put_user((unsigned long)status, datap);
+			break;
+
+		case GIIOC_GETENDPOINTLEN:
+//			printk(KERN_INFO "** GETENDPOINTLEN = %d\n", hidg->report_length);
+			return put_user( hidg->report_length, (unsigned int __user *)argp );
+         
+		default:
+			printk(KERN_ERR "** %s - unknown usbmngr cmd = %d\n", __func__, cmd);
+			return -ENOIOCTLCMD;
+	}
+
+	return 0;
+}
+
+#undef WRITE_COND
+#undef READ_COND
+
+static int f_hidg_release(struct inode *inode, struct file *fd)
+{
+	fd->private_data = NULL;
+	return 0;
+}
+
+static int f_hidg_open(struct inode *inode, struct file *fd)
+{
+	struct f_hidg *hidg =
+		container_of(inode->i_cdev, struct f_hidg, cdev);
+
+	fd->private_data = hidg;
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+/*                                usb_function                             */
+
+static inline struct usb_request *hidg_alloc_ep_req(struct usb_ep *ep,
+						    unsigned length)
+{
+	return alloc_ep_req(ep, length);
+}
+
+static void hidg_set_report_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	struct f_hidg *hidg = (struct f_hidg *) req->context;
+	struct f_hidg_req_list *req_list;
+	unsigned long flags;
+
+	req_list = kzalloc(sizeof(*req_list), GFP_ATOMIC);
+	if (!req_list)
+		return;
+
+	req_list->req = req;
+
+	spin_lock_irqsave(&hidg->spinlock, flags);
+	list_add_tail(&req_list->list, &hidg->completed_out_req);
+	spin_unlock_irqrestore(&hidg->spinlock, flags);
+
+	wake_up(&hidg->read_queue);
+}
+
+static int hidg_setup(struct usb_function *f,
+		const struct usb_ctrlrequest *ctrl)
+{
+	struct f_hidg			*hidg = func_to_hidg(f);
+	struct usb_composite_dev	*cdev = f->config->cdev;
+	struct usb_request		*req  = cdev->req;
+	struct mngr_dev *mdev = &_mngr_dev;
+	int status = 0;
+	__u16 value, length;
+
+	value	= __le16_to_cpu(ctrl->wValue);
+	length	= __le16_to_cpu(ctrl->wLength);
+
+	VDBG(cdev,
+	     "%s crtl_request : bRequestType:0x%x bRequest:0x%x Value:0x%x\n",
+	     __func__, ctrl->bRequestType, ctrl->bRequest, value);
+
+	switch ((ctrl->bRequestType << 8) | ctrl->bRequest) {
+	case ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8
+		  | HID_REQ_GET_REPORT):
+		VDBG(cdev, "get_report\n");
+		/* send an empty report */
+		length = min_t(unsigned, length, hidg->report_length);
+		memset(req->buf, 0x0, length);
+
+		goto respond;
+		break;
+
+	case ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8
+		  | HID_REQ_GET_PROTOCOL):
+		VDBG(cdev, "get_protocol\n");
+		goto stall;
+		break;
+
+	case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8
+		  | HID_REQ_SET_REPORT):
+		VDBG(cdev, "set_report | wLength=%d\n", ctrl->wLength);
+		goto stall;
+		break;
+
+	case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8
+		  | HID_REQ_SET_PROTOCOL):
+		VDBG(cdev, "set_protocol\n");
+		goto stall;
+		break;
+
+	case ((USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_INTERFACE) << 8
+		  | USB_REQ_GET_DESCRIPTOR):
+		switch (value >> 8) {
+		case HID_DT_HID:
+		{
+			struct hid_descriptor hidg_desc_copy = hidg_desc;
+
+			VDBG(cdev, "USB_REQ_GET_DESCRIPTOR: HID\n");
+			hidg_desc_copy.desc[0].bDescriptorType = HID_DT_REPORT;
+			hidg_desc_copy.desc[0].wDescriptorLength =
+				cpu_to_le16(hidg->report_desc_length);
+
+			length = min_t(unsigned short, length,
+						   hidg_desc_copy.bLength);
+			memcpy(req->buf, &hidg_desc_copy, length);
+			goto respond;
+			break;
+		}
+		case HID_DT_REPORT:
+			VDBG(cdev, "USB_REQ_GET_DESCRIPTOR: REPORT\n");
+			if (0 != hidg->func.config->cdev->gadget->state)
+			{
+//				printk("** %s - state ok\n", __func__);
+				atomic_set(&mdev->connected, 1);
+			}
+			length = min_t(unsigned short, length,
+						   hidg->report_desc_length);
+			memcpy(req->buf, hidg->report_desc, length);
+			goto respond;
+			break;
+
+		default:
+			VDBG(cdev, "Unknown descriptor request 0x%x\n",
+				 value >> 8);
+			goto stall;
+			break;
+		}
+		break;
+
+	default:
+		VDBG(cdev, "Unknown request 0x%x\n",
+			 ctrl->bRequest);
+		goto stall;
+		break;
+	}
+
+stall:
+	return -EOPNOTSUPP;
+
+respond:
+	req->zero = 0;
+	req->length = length;
+	status = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);
+	if (status < 0)
+		ERROR(cdev, "usb_ep_queue error on ep0 %d\n", value);
+	return status;
+}
+
+static void hidg_disable(struct usb_function *f)
+{
+	struct f_hidg *hidg = func_to_hidg(f);
+	struct f_hidg_req_list *list, *next;
+	struct mngr_dev *mdev = &_mngr_dev;
+
+	atomic_set(&mdev->connected, 0);
+
+	usb_ep_disable(hidg->in_ep);
+	hidg->in_ep->driver_data = NULL;
+
+	usb_ep_disable(hidg->out_ep);
+	hidg->out_ep->driver_data = NULL;
+
+	list_for_each_entry_safe(list, next, &hidg->completed_out_req, list) {
+		list_del(&list->list);
+		kfree(list);
+	}
+}
+
+static int hidg_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
+{
+	struct usb_composite_dev		*cdev = f->config->cdev;
+	struct f_hidg				*hidg = func_to_hidg(f);
+	int i, status = 0;
+
+	VDBG(cdev, "hidg_set_alt intf:%d alt:%d\n", intf, alt);
+
+	if (hidg->in_ep != NULL) {
+		/* restart endpoint */
+		if (hidg->in_ep->driver_data != NULL)
+			usb_ep_disable(hidg->in_ep);
+
+		status = config_ep_by_speed(f->config->cdev->gadget, f,
+					    hidg->in_ep);
+		if (status) {
+			ERROR(cdev, "config_ep_by_speed FAILED!\n");
+			goto fail;
+		}
+		status = usb_ep_enable(hidg->in_ep);
+		if (status < 0) {
+			ERROR(cdev, "Enable IN endpoint FAILED!\n");
+			goto fail;
+		}
+		hidg->in_ep->driver_data = hidg;
+	}
+
+
+	if (hidg->out_ep != NULL) {
+		/* restart endpoint */
+		if (hidg->out_ep->driver_data != NULL)
+			usb_ep_disable(hidg->out_ep);
+
+		status = config_ep_by_speed(f->config->cdev->gadget, f,
+					    hidg->out_ep);
+		if (status) {
+			ERROR(cdev, "config_ep_by_speed FAILED!\n");
+			goto fail;
+		}
+		status = usb_ep_enable(hidg->out_ep);
+		if (status < 0) {
+			ERROR(cdev, "Enable IN endpoint FAILED!\n");
+			goto fail;
+		}
+		hidg->out_ep->driver_data = hidg;
+
+		/*
+		 * allocate a bunch of read buffers and queue them all at once.
+		 */
+		for (i = 0; i < hidg->qlen && status == 0; i++) {
+			struct usb_request *req =
+					hidg_alloc_ep_req(hidg->out_ep,
+							  hidg->report_length);
+			if (req) {
+				req->complete = hidg_set_report_complete;
+				req->context  = hidg;
+				status = usb_ep_queue(hidg->out_ep, req,
+						      GFP_ATOMIC);
+				if (status)
+					ERROR(cdev, "%s queue req --> %d\n",
+						hidg->out_ep->name, status);
+			} else {
+				usb_ep_disable(hidg->out_ep);
+				hidg->out_ep->driver_data = NULL;
+				status = -ENOMEM;
+				goto fail;
+			}
+		}
+	}
+
+fail:
+	return status;
+}
+
+static const struct file_operations f_hidg_fops = {
+	.owner			= THIS_MODULE,
+	.open			= f_hidg_open,
+	.release		= f_hidg_release,
+	.write			= f_hidg_write,
+	.read			= f_hidg_read,
+    .unlocked_ioctl	= tpd_hidg_unlocked_ioctl,
+	.poll			= f_hidg_poll,
+	.llseek			= noop_llseek,
+};
+
+static int hidg_bind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct usb_ep		*ep;
+	struct f_hidg		*hidg = func_to_hidg(f);
+	struct usb_string	*us;
+	struct device		*device;
+	int	   status;
+	dev_t  dev;
+	struct mngr_dev *mdev = &_mngr_dev;
+
+	/* maybe allocate device-global string IDs, and patch descriptors */
+	us = usb_gstrings_attach(c->cdev, ct_func_strings,
+				 ARRAY_SIZE(ct_func_string_defs));
+	if (IS_ERR(us))
+		return PTR_ERR(us);
+	hidg_interface_desc.iInterface = us[CT_FUNC_HID_IDX].id;
+
+	/* allocate instance-specific interface IDs, and patch descriptors */
+	status = usb_interface_id(c, f);
+	if (status < 0)
+		goto fail;
+	hidg_interface_desc.bInterfaceNumber = status;
+
+	/* allocate instance-specific endpoints */
+	status = -ENODEV;
+	ep = usb_ep_autoconfig(c->cdev->gadget, &hidg_fs_in_ep_desc);
+	if (!ep)
+		goto fail;
+	ep->driver_data = c->cdev;	/* claim */
+	hidg->in_ep = ep;
+
+	ep = usb_ep_autoconfig(c->cdev->gadget, &hidg_fs_out_ep_desc);
+	if (!ep)
+		goto fail;
+	ep->driver_data = c->cdev;	/* claim */
+	hidg->out_ep = ep;
+
+	/* preallocate request and buffer */
+	status = -ENOMEM;
+	hidg->req = usb_ep_alloc_request(hidg->in_ep, GFP_KERNEL);
+	if (!hidg->req)
+		goto fail;
+
+	hidg->req->buf = kmalloc(hidg->report_length, GFP_KERNEL);
+	if (!hidg->req->buf)
+		goto fail;
+
+	/* set descriptor dynamic values */
+	hidg_interface_desc.bInterfaceSubClass = hidg->bInterfaceSubClass;
+	hidg_interface_desc.bInterfaceProtocol = hidg->bInterfaceProtocol;
+	hidg_hs_in_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);
+	hidg_fs_in_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);
+	hidg_hs_out_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);
+	hidg_fs_out_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);
+	/*
+	 * We can use hidg_desc struct here but we should not relay
+	 * that its content won't change after returning from this function.
+	 */
+	hidg_desc.desc[0].bDescriptorType = HID_DT_REPORT;
+	hidg_desc.desc[0].wDescriptorLength =
+		cpu_to_le16(hidg->report_desc_length);
+
+	hidg_hs_in_ep_desc.bEndpointAddress =
+		hidg_fs_in_ep_desc.bEndpointAddress;
+	hidg_hs_out_ep_desc.bEndpointAddress =
+		hidg_fs_out_ep_desc.bEndpointAddress;
+
+	status = usb_assign_descriptors(f, hidg_fs_descriptors,
+			hidg_hs_descriptors, NULL, NULL);
+	if (status)
+		goto fail;
+
+	mutex_init(&hidg->lock);
+	spin_lock_init(&hidg->spinlock);
+	init_waitqueue_head(&hidg->write_queue);
+	init_waitqueue_head(&hidg->read_queue);
+	INIT_LIST_HEAD(&hidg->completed_out_req);
+
+	/* create char device */
+	cdev_init(&hidg->cdev, &f_hidg_fops);
+	dev = MKDEV(major, hidg->minor);
+	status = cdev_add(&hidg->cdev, dev, 1);
+	if (status)
+		goto fail_free_descs;
+
+	device = device_create(hidg_class, NULL, dev, NULL,
+			       "%s%d", "hidg", hidg->minor);
+	if (IS_ERR(device)) {
+		status = PTR_ERR(device);
+		goto del;
+	}
+
+	if (0 != hidg->func.config->cdev->gadget->state)
+	{
+//		printk("** %s - state ok\n", __func__);
+		atomic_set(&mdev->connected, 1);
+	}
+	return 0;
+del:
+	cdev_del(&hidg->cdev);
+fail_free_descs:
+	usb_free_all_descriptors(f);
+fail:
+	ERROR(f->config->cdev, "hidg_bind FAILED\n");
+	if (hidg->req != NULL) {
+		kfree(hidg->req->buf);
+		if (hidg->in_ep != NULL)
+			usb_ep_free_request(hidg->in_ep, hidg->req);
+	}
+
+	return status;
+}
+
+static inline int hidg_get_minor(void)
+{
+	int ret;
+
+	ret = ida_simple_get(&hidg_ida, 0, 0, GFP_KERNEL);
+
+	return ret;
+}
+
+static inline struct f_hid_opts *to_f_hid_opts(struct config_item *item)
+{
+	return container_of(to_config_group(item), struct f_hid_opts,
+			    func_inst.group);
+}
+
+static void hid_attr_release(struct config_item *item)
+{
+	struct f_hid_opts *opts = to_f_hid_opts(item);
+
+	usb_put_function_instance(&opts->func_inst);
+}
+
+static struct configfs_item_operations hidg_item_ops = {
+	.release	= hid_attr_release,
+};
+
+#define F_HID_OPT(name, prec, limit)					\
+static ssize_t f_hid_opts_##name##_show(struct config_item *item, char *page)\
+{									\
+	struct f_hid_opts *opts = to_f_hid_opts(item);			\
+	int result;							\
+									\
+	mutex_lock(&opts->lock);					\
+	result = sprintf(page, "%d\n", opts->name);			\
+	mutex_unlock(&opts->lock);					\
+									\
+	return result;							\
+}									\
+									\
+static ssize_t f_hid_opts_##name##_store(struct config_item *item,	\
+					 const char *page, size_t len)	\
+{									\
+	struct f_hid_opts *opts = to_f_hid_opts(item);			\
+	int ret;							\
+	u##prec num;							\
+									\
+	mutex_lock(&opts->lock);					\
+	if (opts->refcnt) {						\
+		ret = -EBUSY;						\
+		goto end;						\
+	}								\
+									\
+	ret = kstrtou##prec(page, 0, &num);				\
+	if (ret)							\
+		goto end;						\
+									\
+	if (num > limit) {						\
+		ret = -EINVAL;						\
+		goto end;						\
+	}								\
+	opts->name = num;						\
+	ret = len;							\
+									\
+end:									\
+	mutex_unlock(&opts->lock);					\
+	return ret;							\
+}									\
+									\
+CONFIGFS_ATTR(f_hid_opts_, name)
+
+
+F_HID_OPT(subclass, 8, 255);
+F_HID_OPT(protocol, 8, 255);
+F_HID_OPT(report_length, 16, 65535);
+
+static ssize_t f_hid_opts_report_desc_show(struct config_item *item, char *page)
+{
+	struct f_hid_opts *opts = to_f_hid_opts(item);
+	int result;
+
+	mutex_lock(&opts->lock);
+	result = opts->report_desc_length;
+	memcpy(page, opts->report_desc, opts->report_desc_length);
+	mutex_unlock(&opts->lock);
+
+	return result;
+}
+
+static ssize_t f_hid_opts_report_desc_store(struct config_item *item,
+					    const char *page, size_t len)
+{
+	struct f_hid_opts *opts = to_f_hid_opts(item);
+	int ret = -EBUSY;
+	char *d;
+
+	mutex_lock(&opts->lock);
+
+	if (opts->refcnt)
+		goto end;
+	if (len > PAGE_SIZE) {
+		ret = -ENOSPC;
+		goto end;
+	}
+	d = kmemdup(page, len, GFP_KERNEL);
+	if (!d) {
+		ret = -ENOMEM;
+		goto end;
+	}
+	kfree(opts->report_desc);
+	opts->report_desc = d;
+	opts->report_desc_length = len;
+	opts->report_desc_alloc = true;
+	ret = len;
+end:
+	mutex_unlock(&opts->lock);
+	return ret;
+}
+
+CONFIGFS_ATTR(f_hid_opts_, report_desc);
+
+static struct configfs_attribute *hid_attrs[] = {
+	&f_hid_opts_attr_subclass,
+	&f_hid_opts_attr_protocol,
+	&f_hid_opts_attr_report_length,
+	&f_hid_opts_attr_report_desc,
+	NULL,
+};
+
+static struct config_item_type hid_func_type = {
+	.ct_item_ops	= &hidg_item_ops,
+	.ct_attrs	= hid_attrs,
+	.ct_owner	= THIS_MODULE,
+};
+
+static inline void hidg_put_minor(int minor)
+{
+	ida_simple_remove(&hidg_ida, minor);
+}
+
+static void hidg_free_inst(struct usb_function_instance *f)
+{
+	struct f_hid_opts *opts;
+
+	opts = container_of(f, struct f_hid_opts, func_inst);
+
+	mutex_lock(&hidg_ida_lock);
+
+	hidg_put_minor(opts->minor);
+	if (ida_is_empty(&hidg_ida))
+		ghid_cleanup();
+
+	mutex_unlock(&hidg_ida_lock);
+
+	if (opts->report_desc_alloc)
+		kfree(opts->report_desc);
+
+	kfree(opts);
+}
+
+static struct usb_function_instance *hidg_alloc_inst(void)
+{
+	struct f_hid_opts *opts;
+	struct usb_function_instance *ret;
+	int status = 0;
+
+	opts = kzalloc(sizeof(*opts), GFP_KERNEL);
+	if (!opts)
+		return ERR_PTR(-ENOMEM);
+	mutex_init(&opts->lock);
+	opts->func_inst.free_func_inst = hidg_free_inst;
+	ret = &opts->func_inst;
+
+	mutex_lock(&hidg_ida_lock);
+
+	if (ida_is_empty(&hidg_ida)) {
+		status = ghid_setup(NULL, HIDG_MINORS);
+		if (status)  {
+			ret = ERR_PTR(status);
+			kfree(opts);
+			goto unlock;
+		}
+	}
+
+	opts->minor = hidg_get_minor();
+	if (opts->minor < 0) {
+		ret = ERR_PTR(opts->minor);
+		kfree(opts);
+		if (ida_is_empty(&hidg_ida))
+			ghid_cleanup();
+		goto unlock;
+	}
+	config_group_init_type_name(&opts->func_inst.group, "", &hid_func_type);
+
+unlock:
+	mutex_unlock(&hidg_ida_lock);
+	return ret;
+}
+
+static void hidg_free(struct usb_function *f)
+{
+	struct f_hidg *hidg;
+	struct f_hid_opts *opts;
+
+	hidg = func_to_hidg(f);
+	opts = container_of(f->fi, struct f_hid_opts, func_inst);
+	kfree(hidg->report_desc);
+	kfree(hidg);
+	mutex_lock(&opts->lock);
+	--opts->refcnt;
+	mutex_unlock(&opts->lock);
+}
+
+static void hidg_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct f_hidg *hidg = func_to_hidg(f);
+
+	struct mngr_dev *mdev = &_mngr_dev;
+
+	atomic_set(&mdev->connected, 0);
+
+	device_destroy(hidg_class, MKDEV(major, hidg->minor));
+	cdev_del(&hidg->cdev);
+
+	/* disable/free request and end point */
+	usb_ep_disable(hidg->in_ep);
+	kfree(hidg->req->buf);
+	usb_ep_free_request(hidg->in_ep, hidg->req);
+
+	usb_free_all_descriptors(f);
+}
+
+static struct usb_function *hidg_alloc(struct usb_function_instance *fi)
+{
+	struct f_hidg *hidg;
+	struct f_hid_opts *opts;
+
+	/* allocate and initialize one new instance */
+	hidg = kzalloc(sizeof(*hidg), GFP_KERNEL);
+	if (!hidg)
+		return ERR_PTR(-ENOMEM);
+
+	opts = container_of(fi, struct f_hid_opts, func_inst);
+
+	mutex_lock(&opts->lock);
+	++opts->refcnt;
+
+	hidg->minor = opts->minor;
+	hidg->bInterfaceSubClass = opts->subclass;
+	hidg->bInterfaceProtocol = opts->protocol;
+	hidg->report_length = opts->report_length;
+	hidg->report_desc_length = opts->report_desc_length;
+	if (opts->report_desc) {
+		hidg->report_desc = kmemdup(opts->report_desc,
+					    opts->report_desc_length,
+					    GFP_KERNEL);
+		if (!hidg->report_desc) {
+			kfree(hidg);
+			mutex_unlock(&opts->lock);
+			return ERR_PTR(-ENOMEM);
+		}
+	}
+
+	mutex_unlock(&opts->lock);
+
+	hidg->func.name    = "hid";
+	hidg->func.bind    = hidg_bind;
+	hidg->func.unbind  = hidg_unbind;
+	hidg->func.set_alt = hidg_set_alt;
+	hidg->func.disable = hidg_disable;
+	hidg->func.setup   = hidg_setup;
+	hidg->func.free_func = hidg_free;
+
+	/* this could me made configurable at some point */
+	hidg->qlen	   = 4;
+
+	return &hidg->func;
+}
+
+DECLARE_USB_FUNCTION_INIT(hid, hidg_alloc_inst, hidg_alloc);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Fabien Chouteau");
+
+int ghid_setup(struct usb_gadget *g, int count)
+{
+	int status;
+	dev_t dev;
+
+	hidg_class = class_create(THIS_MODULE, "hidg");
+	if (IS_ERR(hidg_class)) {
+		status = PTR_ERR(hidg_class);
+		hidg_class = NULL;
+		return status;
+	}
+
+	status = alloc_chrdev_region(&dev, 0, count, "hidg");
+	if (status) {
+		class_destroy(hidg_class);
+		hidg_class = NULL;
+		return status;
+	}
+
+	major = MAJOR(dev);
+	minors = count;
+
+	return 0;
+}
+
+void ghid_cleanup(void)
+{
+	if (major) {
+		unregister_chrdev_region(MKDEV(major, 0), minors);
+		major = minors = 0;
+	}
+
+	class_destroy(hidg_class);
+	hidg_class = NULL;
+}
diff --git a/drivers/diebold/dbdhiddevice/g_tpd.h b/drivers/diebold/dbdhiddevice/g_tpd.h
new file mode 100755
index 000000000..47d2f1330
--- /dev/null
+++ b/drivers/diebold/dbdhiddevice/g_tpd.h
@@ -0,0 +1,14 @@
+#ifndef __G_TPD_H__
+#define __G_TPD_H__
+
+#define	GADGET_IOCTL_BASE    'g'
+
+#define	GIIOC_CONNECT			_IO (GADGET_IOCTL_BASE, 0x31)
+#define	GIIOC_DISCONNECT		_IO (GADGET_IOCTL_BASE, 0x32)
+#define	GIIOC_SETSN				_IOW(GADGET_IOCTL_BASE, 0x33, unsigned long)
+#define	GIIOC_SETPN				_IOW(GADGET_IOCTL_BASE, 0x34, unsigned long)
+#define	GIIOC_SETID				_IOW(GADGET_IOCTL_BASE, 0x35, unsigned long)
+#define	GIIOC_GETSTATUS			_IOR(GADGET_IOCTL_BASE, 0x36, unsigned long)
+#define	GIIOC_GETENDPOINTLEN	_IOR(GADGET_IOCTL_BASE, 0x37, unsigned long)
+
+#endif
diff --git a/drivers/diebold/dbdhiddevice/u_f.c b/drivers/diebold/dbdhiddevice/u_f.c
new file mode 100644
index 000000000..6aea1ecb3
--- /dev/null
+++ b/drivers/diebold/dbdhiddevice/u_f.c
@@ -0,0 +1,30 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * u_f.c -- USB function utilities for Gadget stack
+ *
+ * Copyright (c) 2013 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ *
+ * Author: Andrzej Pietrasiewicz <andrzejtp2010@gmail.com>
+ */
+
+#include "u_f.h"
+#include <linux/usb/ch9.h>
+
+struct usb_request *alloc_ep_req(struct usb_ep *ep, size_t len)
+{
+	struct usb_request      *req;
+
+	req = usb_ep_alloc_request(ep, GFP_ATOMIC);
+	if (req) {
+		req->length = usb_endpoint_dir_out(ep->desc) ?
+			usb_ep_align(ep, len) : len;
+		req->buf = kmalloc(req->length, GFP_ATOMIC);
+		if (!req->buf) {
+			usb_ep_free_request(ep, req);
+			req = NULL;
+		}
+	}
+	return req;
+}
+EXPORT_SYMBOL_GPL(alloc_ep_req);
diff --git a/drivers/diebold/dbdhiddevice/u_f.h b/drivers/diebold/dbdhiddevice/u_f.h
new file mode 100644
index 000000000..e313c3b8d
--- /dev/null
+++ b/drivers/diebold/dbdhiddevice/u_f.h
@@ -0,0 +1,86 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * u_f.h
+ *
+ * Utility definitions for USB functions
+ *
+ * Copyright (c) 2013 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ *
+ * Author: Andrzej Pietrasiewicz <andrzejtp2010@gmail.com>
+ */
+
+#ifndef __U_F_H__
+#define __U_F_H__
+
+#include <linux/usb/gadget.h>
+#include <linux/overflow.h>
+
+/* Variable Length Array Macros **********************************************/
+#define vla_group(groupname) size_t groupname##__next = 0
+#define vla_group_size(groupname) groupname##__next
+
+#define vla_item(groupname, type, name, n) \
+	size_t groupname##_##name##__offset = ({			       \
+		size_t offset = 0;					       \
+		if (groupname##__next != SIZE_MAX) {			       \
+			size_t align_mask = __alignof__(type) - 1;	       \
+			size_t size = array_size(n, sizeof(type));	       \
+			offset = (groupname##__next + align_mask) &	       \
+				  ~align_mask;				       \
+			if (check_add_overflow(offset, size,		       \
+					       &groupname##__next)) {          \
+				groupname##__next = SIZE_MAX;		       \
+				offset = 0;				       \
+			}						       \
+		}							       \
+		offset;							       \
+	})
+
+#define vla_item_with_sz(groupname, type, name, n) \
+	size_t groupname##_##name##__sz = array_size(n, sizeof(type));	        \
+	size_t groupname##_##name##__offset = ({			        \
+		size_t offset = 0;						\
+		if (groupname##__next != SIZE_MAX) {				\
+			size_t align_mask = __alignof__(type) - 1;		\
+			offset = (groupname##__next + align_mask) &		\
+				  ~align_mask;					\
+			if (check_add_overflow(offset, groupname##_##name##__sz,\
+							&groupname##__next)) {	\
+				groupname##__next = SIZE_MAX;			\
+				offset = 0;					\
+			}							\
+		}								\
+		offset;								\
+	})
+
+#define vla_ptr(ptr, groupname, name) \
+	((void *) ((char *)ptr + groupname##_##name##__offset))
+
+struct usb_ep;
+struct usb_request;
+
+/**
+ * alloc_ep_req - returns a usb_request allocated by the gadget driver and
+ * allocates the request's buffer.
+ *
+ * @ep: the endpoint to allocate a usb_request
+ * @len: usb_requests's buffer suggested size
+ *
+ * In case @ep direction is OUT, the @len will be aligned to ep's
+ * wMaxPacketSize. In order to avoid memory leaks or drops, *always* use
+ * usb_requests's length (req->length) to refer to the allocated buffer size.
+ * Requests allocated via alloc_ep_req() *must* be freed by free_ep_req().
+ */
+struct usb_request *alloc_ep_req(struct usb_ep *ep, size_t len);
+
+/* Frees a usb_request previously allocated by alloc_ep_req() */
+static inline void free_ep_req(struct usb_ep *ep, struct usb_request *req)
+{
+	WARN_ON(req->buf == NULL);
+	kfree(req->buf);
+	req->buf = NULL;
+	usb_ep_free_request(ep, req);
+}
+
+#endif /* __U_F_H__ */
diff --git a/drivers/diebold/dbdhiddevice/u_hid.h b/drivers/diebold/dbdhiddevice/u_hid.h
new file mode 100644
index 000000000..84bb70292
--- /dev/null
+++ b/drivers/diebold/dbdhiddevice/u_hid.h
@@ -0,0 +1,40 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * u_hid.h
+ *
+ * Utility definitions for the hid function
+ *
+ * Copyright (c) 2014 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ *
+ * Author: Andrzej Pietrasiewicz <andrzejtp2010@gmail.com>
+ */
+
+#ifndef U_HID_H
+#define U_HID_H
+
+#include <linux/usb/composite.h>
+
+struct f_hid_opts {
+	struct usb_function_instance	func_inst;
+	int				minor;
+	unsigned char			subclass;
+	unsigned char			protocol;
+	unsigned char			no_out_endpoint;
+	unsigned short			report_length;
+	unsigned short			report_desc_length;
+	unsigned char			*report_desc;
+	bool				report_desc_alloc;
+
+	/*
+	 * Protect the data form concurrent access by read/write
+	 * and create symlink/remove symlink.
+	 */
+	struct mutex			lock;
+	int				refcnt;
+};
+
+int ghid_setup(struct usb_gadget *g, int count);
+void ghid_cleanup(void);
+
+#endif /* U_HID_H */
diff --git a/drivers/diebold/linux-dbdusb/Makefile b/drivers/diebold/linux-dbdusb/Makefile
new file mode 100755
index 000000000..10c93e854
--- /dev/null
+++ b/drivers/diebold/linux-dbdusb/Makefile
@@ -0,0 +1,4 @@
+obj-m 		+= dbdmsg.o
+obj-m		+= dbdosi.o
+obj-m		+= epautoconf.o
+obj-m		+= f_dbdusb.o
\ No newline at end of file
diff --git a/drivers/diebold/linux-dbdusb/composite.c b/drivers/diebold/linux-dbdusb/composite.c
new file mode 100644
index 000000000..553382ce3
--- /dev/null
+++ b/drivers/diebold/linux-dbdusb/composite.c
@@ -0,0 +1,2592 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * composite.c - infrastructure for Composite USB Gadgets
+ *
+ * Copyright (C) 2006-2008 David Brownell
+ */
+
+/* #define VERBOSE_DEBUG */
+
+#include <linux/kallsyms.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/utsname.h>
+#include <linux/bitfield.h>
+
+#include <linux/usb/composite.h>
+#include <linux/usb/otg.h>
+#include <asm/unaligned.h>
+
+#include "u_os_desc.h"
+
+/**
+ * struct usb_os_string - represents OS String to be reported by a gadget
+ * @bLength: total length of the entire descritor, always 0x12
+ * @bDescriptorType: USB_DT_STRING
+ * @qwSignature: the OS String proper
+ * @bMS_VendorCode: code used by the host for subsequent requests
+ * @bPad: not used, must be zero
+ */
+struct usb_os_string {
+	__u8	bLength;
+	__u8	bDescriptorType;
+	__u8	qwSignature[OS_STRING_QW_SIGN_LEN];
+	__u8	bMS_VendorCode;
+	__u8	bPad;
+} __packed;
+
+/*
+ * The code in this file is utility code, used to build a gadget driver
+ * from one or more "function" drivers, one or more "configuration"
+ * objects, and a "usb_composite_driver" by gluing them together along
+ * with the relevant device-wide data.
+ */
+
+static struct usb_gadget_strings **get_containers_gs(
+		struct usb_gadget_string_container *uc)
+{
+	return (struct usb_gadget_strings **)uc->stash;
+}
+
+/**
+ * function_descriptors() - get function descriptors for speed
+ * @f: the function
+ * @speed: the speed
+ *
+ * Returns the descriptors or NULL if not set.
+ */
+static struct usb_descriptor_header **
+function_descriptors(struct usb_function *f,
+		     enum usb_device_speed speed)
+{
+	struct usb_descriptor_header **descriptors;
+
+	/*
+	 * NOTE: we try to help gadget drivers which might not be setting
+	 * max_speed appropriately.
+	 */
+
+	switch (speed) {
+	case USB_SPEED_SUPER_PLUS:
+		descriptors = f->ssp_descriptors;
+		if (descriptors)
+			break;
+		fallthrough;
+	case USB_SPEED_SUPER:
+		descriptors = f->ss_descriptors;
+		if (descriptors)
+			break;
+		fallthrough;
+	case USB_SPEED_HIGH:
+		descriptors = f->hs_descriptors;
+		if (descriptors)
+			break;
+		fallthrough;
+	default:
+		descriptors = f->fs_descriptors;
+	}
+
+	/*
+	 * if we can't find any descriptors at all, then this gadget deserves to
+	 * Oops with a NULL pointer dereference
+	 */
+
+	return descriptors;
+}
+
+/**
+ * next_desc() - advance to the next desc_type descriptor
+ * @t: currect pointer within descriptor array
+ * @desc_type: descriptor type
+ *
+ * Return: next desc_type descriptor or NULL
+ *
+ * Iterate over @t until either desc_type descriptor found or
+ * NULL (that indicates end of list) encountered
+ */
+static struct usb_descriptor_header**
+next_desc(struct usb_descriptor_header **t, u8 desc_type)
+{
+	for (; *t; t++) {
+		if ((*t)->bDescriptorType == desc_type)
+			return t;
+	}
+	return NULL;
+}
+
+/*
+ * for_each_desc() - iterate over desc_type descriptors in the
+ * descriptors list
+ * @start: pointer within descriptor array.
+ * @iter_desc: desc_type descriptor to use as the loop cursor
+ * @desc_type: wanted descriptr type
+ */
+#define for_each_desc(start, iter_desc, desc_type) \
+	for (iter_desc = next_desc(start, desc_type); \
+	     iter_desc; iter_desc = next_desc(iter_desc + 1, desc_type))
+
+/**
+ * config_ep_by_speed_and_alt() - configures the given endpoint
+ * according to gadget speed.
+ * @g: pointer to the gadget
+ * @f: usb function
+ * @_ep: the endpoint to configure
+ * @alt: alternate setting number
+ *
+ * Return: error code, 0 on success
+ *
+ * This function chooses the right descriptors for a given
+ * endpoint according to gadget speed and saves it in the
+ * endpoint desc field. If the endpoint already has a descriptor
+ * assigned to it - overwrites it with currently corresponding
+ * descriptor. The endpoint maxpacket field is updated according
+ * to the chosen descriptor.
+ * Note: the supplied function should hold all the descriptors
+ * for supported speeds
+ */
+int config_ep_by_speed_and_alt(struct usb_gadget *g,
+				struct usb_function *f,
+				struct usb_ep *_ep,
+				u8 alt)
+{
+	struct usb_endpoint_descriptor *chosen_desc = NULL;
+	struct usb_interface_descriptor *int_desc = NULL;
+	struct usb_descriptor_header **speed_desc = NULL;
+
+	struct usb_ss_ep_comp_descriptor *comp_desc = NULL;
+	int want_comp_desc = 0;
+
+	struct usb_descriptor_header **d_spd; /* cursor for speed desc */
+
+	if (!g || !f || !_ep)
+		return -EIO;
+
+	/* select desired speed */
+	switch (g->speed) {
+	case USB_SPEED_SUPER_PLUS:
+		if (gadget_is_superspeed_plus(g)) {
+			speed_desc = f->ssp_descriptors;
+			want_comp_desc = 1;
+			break;
+		}
+		fallthrough;
+	case USB_SPEED_SUPER:
+		if (gadget_is_superspeed(g)) {
+			speed_desc = f->ss_descriptors;
+			want_comp_desc = 1;
+			break;
+		}
+		fallthrough;
+	case USB_SPEED_HIGH:
+		if (gadget_is_dualspeed(g)) {
+			speed_desc = f->hs_descriptors;
+			break;
+		}
+		fallthrough;
+	default:
+		speed_desc = f->fs_descriptors;
+	}
+
+	/* find correct alternate setting descriptor */
+	for_each_desc(speed_desc, d_spd, USB_DT_INTERFACE) {
+		int_desc = (struct usb_interface_descriptor *)*d_spd;
+
+		if (int_desc->bAlternateSetting == alt) {
+			speed_desc = d_spd;
+			goto intf_found;
+		}
+	}
+	return -EIO;
+
+intf_found:
+	/* find descriptors */
+	for_each_desc(speed_desc, d_spd, USB_DT_ENDPOINT) {
+		chosen_desc = (struct usb_endpoint_descriptor *)*d_spd;
+		if (chosen_desc->bEndpointAddress == _ep->address)
+			goto ep_found;
+	}
+	return -EIO;
+
+ep_found:
+	/* commit results */
+	_ep->maxpacket = usb_endpoint_maxp(chosen_desc);
+	_ep->desc = chosen_desc;
+	_ep->comp_desc = NULL;
+	_ep->maxburst = 0;
+	_ep->mult = 1;
+
+	if (g->speed == USB_SPEED_HIGH && (usb_endpoint_xfer_isoc(_ep->desc) ||
+				usb_endpoint_xfer_int(_ep->desc)))
+		_ep->mult = usb_endpoint_maxp_mult(_ep->desc);
+
+	if (!want_comp_desc)
+		return 0;
+
+	/*
+	 * Companion descriptor should follow EP descriptor
+	 * USB 3.0 spec, #9.6.7
+	 */
+	comp_desc = (struct usb_ss_ep_comp_descriptor *)*(++d_spd);
+	if (!comp_desc ||
+	    (comp_desc->bDescriptorType != USB_DT_SS_ENDPOINT_COMP))
+		return -EIO;
+	_ep->comp_desc = comp_desc;
+	if (g->speed >= USB_SPEED_SUPER) {
+		switch (usb_endpoint_type(_ep->desc)) {
+		case USB_ENDPOINT_XFER_ISOC:
+			/* mult: bits 1:0 of bmAttributes */
+			_ep->mult = (comp_desc->bmAttributes & 0x3) + 1;
+			fallthrough;
+		case USB_ENDPOINT_XFER_BULK:
+		case USB_ENDPOINT_XFER_INT:
+			_ep->maxburst = comp_desc->bMaxBurst + 1;
+			break;
+		default:
+			if (comp_desc->bMaxBurst != 0) {
+				struct usb_composite_dev *cdev;
+
+				cdev = get_gadget_data(g);
+				ERROR(cdev, "ep0 bMaxBurst must be 0\n");
+			}
+			_ep->maxburst = 1;
+			break;
+		}
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(config_ep_by_speed_and_alt);
+
+/**
+ * config_ep_by_speed() - configures the given endpoint
+ * according to gadget speed.
+ * @g: pointer to the gadget
+ * @f: usb function
+ * @_ep: the endpoint to configure
+ *
+ * Return: error code, 0 on success
+ *
+ * This function chooses the right descriptors for a given
+ * endpoint according to gadget speed and saves it in the
+ * endpoint desc field. If the endpoint already has a descriptor
+ * assigned to it - overwrites it with currently corresponding
+ * descriptor. The endpoint maxpacket field is updated according
+ * to the chosen descriptor.
+ * Note: the supplied function should hold all the descriptors
+ * for supported speeds
+ */
+int config_ep_by_speed(struct usb_gadget *g,
+			struct usb_function *f,
+			struct usb_ep *_ep)
+{
+	return config_ep_by_speed_and_alt(g, f, _ep, 0);
+}
+EXPORT_SYMBOL_GPL(config_ep_by_speed);
+
+/**
+ * usb_add_function() - add a function to a configuration
+ * @config: the configuration
+ * @function: the function being added
+ * Context: single threaded during gadget setup
+ *
+ * After initialization, each configuration must have one or more
+ * functions added to it.  Adding a function involves calling its @bind()
+ * method to allocate resources such as interface and string identifiers
+ * and endpoints.
+ *
+ * This function returns the value of the function's bind(), which is
+ * zero for success else a negative errno value.
+ */
+int usb_add_function(struct usb_configuration *config,
+		struct usb_function *function)
+{
+	int	value = -EINVAL;
+
+	DBG(config->cdev, "adding '%s'/%p to config '%s'/%p\n",
+			function->name, function,
+			config->label, config);
+
+	if (!function->set_alt || !function->disable)
+		goto done;
+
+	function->config = config;
+	list_add_tail(&function->list, &config->functions);
+
+	if (function->bind_deactivated) {
+		value = usb_function_deactivate(function);
+		if (value)
+			goto done;
+	}
+
+	/* REVISIT *require* function->bind? */
+	if (function->bind) {
+		value = function->bind(config, function);
+		if (value < 0) {
+			list_del(&function->list);
+			function->config = NULL;
+		}
+	} else
+		value = 0;
+
+	/* We allow configurations that don't work at both speeds.
+	 * If we run into a lowspeed Linux system, treat it the same
+	 * as full speed ... it's the function drivers that will need
+	 * to avoid bulk and ISO transfers.
+	 */
+	if (!config->fullspeed && function->fs_descriptors)
+		config->fullspeed = true;
+	if (!config->highspeed && function->hs_descriptors)
+		config->highspeed = true;
+	if (!config->superspeed && function->ss_descriptors)
+		config->superspeed = true;
+	if (!config->superspeed_plus && function->ssp_descriptors)
+		config->superspeed_plus = true;
+
+done:
+	if (value)
+		DBG(config->cdev, "adding '%s'/%p --> %d\n",
+				function->name, function, value);
+	return value;
+}
+EXPORT_SYMBOL_GPL(usb_add_function);
+
+void usb_remove_function(struct usb_configuration *c, struct usb_function *f)
+{
+	if (f->disable)
+		f->disable(f);
+
+	bitmap_zero(f->endpoints, 32);
+	list_del(&f->list);
+	if (f->unbind)
+		f->unbind(c, f);
+
+	if (f->bind_deactivated)
+		usb_function_activate(f);
+}
+EXPORT_SYMBOL_GPL(usb_remove_function);
+
+/**
+ * usb_function_deactivate - prevent function and gadget enumeration
+ * @function: the function that isn't yet ready to respond
+ *
+ * Blocks response of the gadget driver to host enumeration by
+ * preventing the data line pullup from being activated.  This is
+ * normally called during @bind() processing to change from the
+ * initial "ready to respond" state, or when a required resource
+ * becomes available.
+ *
+ * For example, drivers that serve as a passthrough to a userspace
+ * daemon can block enumeration unless that daemon (such as an OBEX,
+ * MTP, or print server) is ready to handle host requests.
+ *
+ * Not all systems support software control of their USB peripheral
+ * data pullups.
+ *
+ * Returns zero on success, else negative errno.
+ */
+int usb_function_deactivate(struct usb_function *function)
+{
+	struct usb_composite_dev	*cdev = function->config->cdev;
+	unsigned long			flags;
+	int				status = 0;
+
+	spin_lock_irqsave(&cdev->lock, flags);
+
+	if (cdev->deactivations == 0) {
+		spin_unlock_irqrestore(&cdev->lock, flags);
+		status = usb_gadget_deactivate(cdev->gadget);
+		spin_lock_irqsave(&cdev->lock, flags);
+	}
+	if (status == 0)
+		cdev->deactivations++;
+
+	spin_unlock_irqrestore(&cdev->lock, flags);
+	return status;
+}
+EXPORT_SYMBOL_GPL(usb_function_deactivate);
+
+/**
+ * usb_function_activate - allow function and gadget enumeration
+ * @function: function on which usb_function_activate() was called
+ *
+ * Reverses effect of usb_function_deactivate().  If no more functions
+ * are delaying their activation, the gadget driver will respond to
+ * host enumeration procedures.
+ *
+ * Returns zero on success, else negative errno.
+ */
+int usb_function_activate(struct usb_function *function)
+{
+	struct usb_composite_dev	*cdev = function->config->cdev;
+	unsigned long			flags;
+	int				status = 0;
+
+	spin_lock_irqsave(&cdev->lock, flags);
+
+	if (WARN_ON(cdev->deactivations == 0))
+		status = -EINVAL;
+	else {
+		cdev->deactivations--;
+		if (cdev->deactivations == 0) {
+			spin_unlock_irqrestore(&cdev->lock, flags);
+			status = usb_gadget_activate(cdev->gadget);
+			spin_lock_irqsave(&cdev->lock, flags);
+		}
+	}
+
+	spin_unlock_irqrestore(&cdev->lock, flags);
+	return status;
+}
+EXPORT_SYMBOL_GPL(usb_function_activate);
+
+/**
+ * usb_interface_id() - allocate an unused interface ID
+ * @config: configuration associated with the interface
+ * @function: function handling the interface
+ * Context: single threaded during gadget setup
+ *
+ * usb_interface_id() is called from usb_function.bind() callbacks to
+ * allocate new interface IDs.  The function driver will then store that
+ * ID in interface, association, CDC union, and other descriptors.  It
+ * will also handle any control requests targeted at that interface,
+ * particularly changing its altsetting via set_alt().  There may
+ * also be class-specific or vendor-specific requests to handle.
+ *
+ * All interface identifier should be allocated using this routine, to
+ * ensure that for example different functions don't wrongly assign
+ * different meanings to the same identifier.  Note that since interface
+ * identifiers are configuration-specific, functions used in more than
+ * one configuration (or more than once in a given configuration) need
+ * multiple versions of the relevant descriptors.
+ *
+ * Returns the interface ID which was allocated; or -ENODEV if no
+ * more interface IDs can be allocated.
+ */
+int usb_interface_id(struct usb_configuration *config,
+		struct usb_function *function)
+{
+	unsigned id = config->next_interface_id;
+
+	if (id < MAX_CONFIG_INTERFACES) {
+		config->interface[id] = function;
+		config->next_interface_id = id + 1;
+		return id;
+	}
+	return -ENODEV;
+}
+EXPORT_SYMBOL_GPL(usb_interface_id);
+
+static u8 encode_bMaxPower(enum usb_device_speed speed,
+		struct usb_configuration *c)
+{
+	unsigned val;
+
+	if (c->MaxPower || (c->bmAttributes & USB_CONFIG_ATT_SELFPOWER))
+		val = c->MaxPower;
+	else
+		val = CONFIG_USB_GADGET_VBUS_DRAW;
+	if (!val)
+		return 0;
+	if (speed < USB_SPEED_SUPER)
+		return min(val, 500U) / 2;
+	else
+		/*
+		 * USB 3.x supports up to 900mA, but since 900 isn't divisible
+		 * by 8 the integral division will effectively cap to 896mA.
+		 */
+		return min(val, 900U) / 8;
+}
+
+static int config_buf(struct usb_configuration *config,
+		enum usb_device_speed speed, void *buf, u8 type)
+{
+	struct usb_config_descriptor	*c = buf;
+	void				*next = buf + USB_DT_CONFIG_SIZE;
+	int				len;
+	struct usb_function		*f;
+	int				status;
+
+	len = USB_COMP_EP0_BUFSIZ - USB_DT_CONFIG_SIZE;
+	/* write the config descriptor */
+	c = buf;
+	c->bLength = USB_DT_CONFIG_SIZE;
+	c->bDescriptorType = type;
+	/* wTotalLength is written later */
+	c->bNumInterfaces = config->next_interface_id;
+	c->bConfigurationValue = config->bConfigurationValue;
+	c->iConfiguration = config->iConfiguration;
+	c->bmAttributes = USB_CONFIG_ATT_ONE | config->bmAttributes;
+	c->bMaxPower = encode_bMaxPower(speed, config);
+
+	/* There may be e.g. OTG descriptors */
+	if (config->descriptors) {
+		status = usb_descriptor_fillbuf(next, len,
+				config->descriptors);
+		if (status < 0)
+			return status;
+		len -= status;
+		next += status;
+	}
+
+	/* add each function's descriptors */
+	list_for_each_entry(f, &config->functions, list) {
+		struct usb_descriptor_header **descriptors;
+
+		descriptors = function_descriptors(f, speed);
+		if (!descriptors)
+			continue;
+		status = usb_descriptor_fillbuf(next, len,
+			(const struct usb_descriptor_header **) descriptors);
+		if (status < 0)
+			return status;
+		len -= status;
+		next += status;
+	}
+
+	len = next - buf;
+	c->wTotalLength = cpu_to_le16(len);
+	return len;
+}
+
+static int config_desc(struct usb_composite_dev *cdev, unsigned w_value)
+{
+	struct usb_gadget		*gadget = cdev->gadget;
+	struct usb_configuration	*c;
+	struct list_head		*pos;
+	u8				type = w_value >> 8;
+	enum usb_device_speed		speed = USB_SPEED_UNKNOWN;
+
+	if (gadget->speed >= USB_SPEED_SUPER)
+		speed = gadget->speed;
+	else if (gadget_is_dualspeed(gadget)) {
+		int	hs = 0;
+		if (gadget->speed == USB_SPEED_HIGH)
+			hs = 1;
+		if (type == USB_DT_OTHER_SPEED_CONFIG)
+			hs = !hs;
+		if (hs)
+			speed = USB_SPEED_HIGH;
+
+	}
+
+	/* This is a lookup by config *INDEX* */
+	w_value &= 0xff;
+
+	pos = &cdev->configs;
+	c = cdev->os_desc_config;
+	if (c)
+		goto check_config;
+
+	while ((pos = pos->next) !=  &cdev->configs) {
+		c = list_entry(pos, typeof(*c), list);
+
+		/* skip OS Descriptors config which is handled separately */
+		if (c == cdev->os_desc_config)
+			continue;
+
+check_config:
+		/* ignore configs that won't work at this speed */
+		switch (speed) {
+		case USB_SPEED_SUPER_PLUS:
+			if (!c->superspeed_plus)
+				continue;
+			break;
+		case USB_SPEED_SUPER:
+			if (!c->superspeed)
+				continue;
+			break;
+		case USB_SPEED_HIGH:
+			if (!c->highspeed)
+				continue;
+			break;
+		default:
+			if (!c->fullspeed)
+				continue;
+		}
+
+		if (w_value == 0)
+			return config_buf(c, speed, cdev->req->buf, type);
+		w_value--;
+	}
+	return -EINVAL;
+}
+
+static int count_configs(struct usb_composite_dev *cdev, unsigned type)
+{
+	struct usb_gadget		*gadget = cdev->gadget;
+	struct usb_configuration	*c;
+	unsigned			count = 0;
+	int				hs = 0;
+	int				ss = 0;
+	int				ssp = 0;
+
+	if (gadget_is_dualspeed(gadget)) {
+		if (gadget->speed == USB_SPEED_HIGH)
+			hs = 1;
+		if (gadget->speed == USB_SPEED_SUPER)
+			ss = 1;
+		if (gadget->speed == USB_SPEED_SUPER_PLUS)
+			ssp = 1;
+		if (type == USB_DT_DEVICE_QUALIFIER)
+			hs = !hs;
+	}
+	list_for_each_entry(c, &cdev->configs, list) {
+		/* ignore configs that won't work at this speed */
+		if (ssp) {
+			if (!c->superspeed_plus)
+				continue;
+		} else if (ss) {
+			if (!c->superspeed)
+				continue;
+		} else if (hs) {
+			if (!c->highspeed)
+				continue;
+		} else {
+			if (!c->fullspeed)
+				continue;
+		}
+		count++;
+	}
+	return count;
+}
+
+/**
+ * bos_desc() - prepares the BOS descriptor.
+ * @cdev: pointer to usb_composite device to generate the bos
+ *	descriptor for
+ *
+ * This function generates the BOS (Binary Device Object)
+ * descriptor and its device capabilities descriptors. The BOS
+ * descriptor should be supported by a SuperSpeed device.
+ */
+static int bos_desc(struct usb_composite_dev *cdev)
+{
+	struct usb_ext_cap_descriptor	*usb_ext;
+	struct usb_dcd_config_params	dcd_config_params;
+	struct usb_bos_descriptor	*bos = cdev->req->buf;
+	unsigned int			besl = 0;
+
+	bos->bLength = USB_DT_BOS_SIZE;
+	bos->bDescriptorType = USB_DT_BOS;
+
+	bos->wTotalLength = cpu_to_le16(USB_DT_BOS_SIZE);
+	bos->bNumDeviceCaps = 0;
+
+	/* Get Controller configuration */
+	if (cdev->gadget->ops->get_config_params) {
+		cdev->gadget->ops->get_config_params(cdev->gadget,
+						     &dcd_config_params);
+	} else {
+		dcd_config_params.besl_baseline =
+			USB_DEFAULT_BESL_UNSPECIFIED;
+		dcd_config_params.besl_deep =
+			USB_DEFAULT_BESL_UNSPECIFIED;
+		dcd_config_params.bU1devExitLat =
+			USB_DEFAULT_U1_DEV_EXIT_LAT;
+		dcd_config_params.bU2DevExitLat =
+			cpu_to_le16(USB_DEFAULT_U2_DEV_EXIT_LAT);
+	}
+
+	if (dcd_config_params.besl_baseline != USB_DEFAULT_BESL_UNSPECIFIED)
+		besl = USB_BESL_BASELINE_VALID |
+			USB_SET_BESL_BASELINE(dcd_config_params.besl_baseline);
+
+	if (dcd_config_params.besl_deep != USB_DEFAULT_BESL_UNSPECIFIED)
+		besl |= USB_BESL_DEEP_VALID |
+			USB_SET_BESL_DEEP(dcd_config_params.besl_deep);
+
+	/*
+	 * A SuperSpeed device shall include the USB2.0 extension descriptor
+	 * and shall support LPM when operating in USB2.0 HS mode.
+	 */
+	usb_ext = cdev->req->buf + le16_to_cpu(bos->wTotalLength);
+	bos->bNumDeviceCaps++;
+	le16_add_cpu(&bos->wTotalLength, USB_DT_USB_EXT_CAP_SIZE);
+	usb_ext->bLength = USB_DT_USB_EXT_CAP_SIZE;
+	usb_ext->bDescriptorType = USB_DT_DEVICE_CAPABILITY;
+	usb_ext->bDevCapabilityType = USB_CAP_TYPE_EXT;
+	usb_ext->bmAttributes = cpu_to_le32(USB_LPM_SUPPORT |
+					    USB_BESL_SUPPORT | besl);
+
+	/*
+	 * The Superspeed USB Capability descriptor shall be implemented by all
+	 * SuperSpeed devices.
+	 */
+	if (gadget_is_superspeed(cdev->gadget)) {
+		struct usb_ss_cap_descriptor *ss_cap;
+
+		ss_cap = cdev->req->buf + le16_to_cpu(bos->wTotalLength);
+		bos->bNumDeviceCaps++;
+		le16_add_cpu(&bos->wTotalLength, USB_DT_USB_SS_CAP_SIZE);
+		ss_cap->bLength = USB_DT_USB_SS_CAP_SIZE;
+		ss_cap->bDescriptorType = USB_DT_DEVICE_CAPABILITY;
+		ss_cap->bDevCapabilityType = USB_SS_CAP_TYPE;
+		ss_cap->bmAttributes = 0; /* LTM is not supported yet */
+		ss_cap->wSpeedSupported = cpu_to_le16(USB_LOW_SPEED_OPERATION |
+						      USB_FULL_SPEED_OPERATION |
+						      USB_HIGH_SPEED_OPERATION |
+						      USB_5GBPS_OPERATION);
+		ss_cap->bFunctionalitySupport = USB_LOW_SPEED_OPERATION;
+		ss_cap->bU1devExitLat = dcd_config_params.bU1devExitLat;
+		ss_cap->bU2DevExitLat = dcd_config_params.bU2DevExitLat;
+	}
+
+	/* The SuperSpeedPlus USB Device Capability descriptor */
+	if (gadget_is_superspeed_plus(cdev->gadget)) {
+		struct usb_ssp_cap_descriptor *ssp_cap;
+		u8 ssac = 1;
+		u8 ssic;
+		int i;
+
+		if (cdev->gadget->max_ssp_rate == USB_SSP_GEN_2x2)
+			ssac = 3;
+
+		/*
+		 * Paired RX and TX sublink speed attributes share
+		 * the same SSID.
+		 */
+		ssic = (ssac + 1) / 2 - 1;
+
+		ssp_cap = cdev->req->buf + le16_to_cpu(bos->wTotalLength);
+		bos->bNumDeviceCaps++;
+
+		le16_add_cpu(&bos->wTotalLength, USB_DT_USB_SSP_CAP_SIZE(ssac));
+		ssp_cap->bLength = USB_DT_USB_SSP_CAP_SIZE(ssac);
+		ssp_cap->bDescriptorType = USB_DT_DEVICE_CAPABILITY;
+		ssp_cap->bDevCapabilityType = USB_SSP_CAP_TYPE;
+		ssp_cap->bReserved = 0;
+		ssp_cap->wReserved = 0;
+
+		ssp_cap->bmAttributes =
+			cpu_to_le32(FIELD_PREP(USB_SSP_SUBLINK_SPEED_ATTRIBS, ssac) |
+				    FIELD_PREP(USB_SSP_SUBLINK_SPEED_IDS, ssic));
+
+		ssp_cap->wFunctionalitySupport =
+			cpu_to_le16(FIELD_PREP(USB_SSP_MIN_SUBLINK_SPEED_ATTRIBUTE_ID, 0) |
+				    FIELD_PREP(USB_SSP_MIN_RX_LANE_COUNT, 1) |
+				    FIELD_PREP(USB_SSP_MIN_TX_LANE_COUNT, 1));
+
+		/*
+		 * Use 1 SSID if the gadget supports up to gen2x1 or not
+		 * specified:
+		 * - SSID 0 for symmetric RX/TX sublink speed of 10 Gbps.
+		 *
+		 * Use 1 SSID if the gadget supports up to gen1x2:
+		 * - SSID 0 for symmetric RX/TX sublink speed of 5 Gbps.
+		 *
+		 * Use 2 SSIDs if the gadget supports up to gen2x2:
+		 * - SSID 0 for symmetric RX/TX sublink speed of 5 Gbps.
+		 * - SSID 1 for symmetric RX/TX sublink speed of 10 Gbps.
+		 */
+		for (i = 0; i < ssac + 1; i++) {
+			u8 ssid;
+			u8 mantissa;
+			u8 type;
+
+			ssid = i >> 1;
+
+			if (cdev->gadget->max_ssp_rate == USB_SSP_GEN_2x1 ||
+			    cdev->gadget->max_ssp_rate == USB_SSP_GEN_UNKNOWN)
+				mantissa = 10;
+			else
+				mantissa = 5 << ssid;
+
+			if (i % 2)
+				type = USB_SSP_SUBLINK_SPEED_ST_SYM_TX;
+			else
+				type = USB_SSP_SUBLINK_SPEED_ST_SYM_RX;
+
+			ssp_cap->bmSublinkSpeedAttr[i] =
+				cpu_to_le32(FIELD_PREP(USB_SSP_SUBLINK_SPEED_SSID, ssid) |
+					    FIELD_PREP(USB_SSP_SUBLINK_SPEED_LSE,
+						       USB_SSP_SUBLINK_SPEED_LSE_GBPS) |
+					    FIELD_PREP(USB_SSP_SUBLINK_SPEED_ST, type) |
+					    FIELD_PREP(USB_SSP_SUBLINK_SPEED_LP,
+						       USB_SSP_SUBLINK_SPEED_LP_SSP) |
+					    FIELD_PREP(USB_SSP_SUBLINK_SPEED_LSM, mantissa));
+		}
+	}
+
+	return le16_to_cpu(bos->wTotalLength);
+}
+
+static void device_qual(struct usb_composite_dev *cdev)
+{
+	struct usb_qualifier_descriptor	*qual = cdev->req->buf;
+
+	qual->bLength = sizeof(*qual);
+	qual->bDescriptorType = USB_DT_DEVICE_QUALIFIER;
+	/* POLICY: same bcdUSB and device type info at both speeds */
+	qual->bcdUSB = cdev->desc.bcdUSB;
+	qual->bDeviceClass = cdev->desc.bDeviceClass;
+	qual->bDeviceSubClass = cdev->desc.bDeviceSubClass;
+	qual->bDeviceProtocol = cdev->desc.bDeviceProtocol;
+	/* ASSUME same EP0 fifo size at both speeds */
+	qual->bMaxPacketSize0 = cdev->gadget->ep0->maxpacket;
+	qual->bNumConfigurations = count_configs(cdev, USB_DT_DEVICE_QUALIFIER);
+	qual->bRESERVED = 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static void reset_config(struct usb_composite_dev *cdev)
+{
+	struct usb_function		*f;
+
+	DBG(cdev, "reset config\n");
+
+	list_for_each_entry(f, &cdev->config->functions, list) {
+		if (f->disable)
+			f->disable(f);
+
+		bitmap_zero(f->endpoints, 32);
+	}
+	cdev->config = NULL;
+	cdev->delayed_status = 0;
+}
+
+static int set_config(struct usb_composite_dev *cdev,
+		const struct usb_ctrlrequest *ctrl, unsigned number)
+{
+	struct usb_gadget	*gadget = cdev->gadget;
+	struct usb_configuration *c = NULL;
+	int			result = -EINVAL;
+	unsigned		power = gadget_is_otg(gadget) ? 8 : 100;
+	int			tmp;
+
+	if (number) {
+		list_for_each_entry(c, &cdev->configs, list) {
+			if (c->bConfigurationValue == number) {
+				/*
+				 * We disable the FDs of the previous
+				 * configuration only if the new configuration
+				 * is a valid one
+				 */
+				if (cdev->config)
+					reset_config(cdev);
+				result = 0;
+				break;
+			}
+		}
+		if (result < 0)
+			goto done;
+	} else { /* Zero configuration value - need to reset the config */
+		if (cdev->config)
+			reset_config(cdev);
+		result = 0;
+	}
+
+	DBG(cdev, "%s config #%d: %s\n",
+	    usb_speed_string(gadget->speed),
+	    number, c ? c->label : "unconfigured");
+
+	if (!c)
+		goto done;
+
+	usb_gadget_set_state(gadget, USB_STATE_CONFIGURED);
+	cdev->config = c;
+
+	/* Initialize all interfaces by setting them to altsetting zero. */
+	for (tmp = 0; tmp < MAX_CONFIG_INTERFACES; tmp++) {
+		struct usb_function	*f = c->interface[tmp];
+		struct usb_descriptor_header **descriptors;
+
+		if (!f)
+			break;
+
+		/*
+		 * Record which endpoints are used by the function. This is used
+		 * to dispatch control requests targeted at that endpoint to the
+		 * function's setup callback instead of the current
+		 * configuration's setup callback.
+		 */
+		descriptors = function_descriptors(f, gadget->speed);
+
+		for (; *descriptors; ++descriptors) {
+			struct usb_endpoint_descriptor *ep;
+			int addr;
+
+			if ((*descriptors)->bDescriptorType != USB_DT_ENDPOINT)
+				continue;
+
+			ep = (struct usb_endpoint_descriptor *)*descriptors;
+			addr = ((ep->bEndpointAddress & 0x80) >> 3)
+			     |  (ep->bEndpointAddress & 0x0f);
+			set_bit(addr, f->endpoints);
+		}
+
+		result = f->set_alt(f, tmp, 0);
+		if (result < 0) {
+			DBG(cdev, "interface %d (%s/%p) alt 0 --> %d\n",
+					tmp, f->name, f, result);
+
+			reset_config(cdev);
+			goto done;
+		}
+
+		if (result == USB_GADGET_DELAYED_STATUS) {
+			DBG(cdev,
+			 "%s: interface %d (%s) requested delayed status\n",
+					__func__, tmp, f->name);
+			cdev->delayed_status++;
+			DBG(cdev, "delayed_status count %d\n",
+					cdev->delayed_status);
+		}
+	}
+
+	/* when we return, be sure our power usage is valid */
+	if (c->MaxPower || (c->bmAttributes & USB_CONFIG_ATT_SELFPOWER))
+		power = c->MaxPower;
+	else
+		power = CONFIG_USB_GADGET_VBUS_DRAW;
+
+	if (gadget->speed < USB_SPEED_SUPER)
+		power = min(power, 500U);
+	else
+		power = min(power, 900U);
+done:
+	if (power <= USB_SELF_POWER_VBUS_MAX_DRAW)
+		usb_gadget_set_selfpowered(gadget);
+	else
+		usb_gadget_clear_selfpowered(gadget);
+
+	usb_gadget_vbus_draw(gadget, power);
+	if (result >= 0 && cdev->delayed_status)
+		result = USB_GADGET_DELAYED_STATUS;
+	return result;
+}
+
+int usb_add_config_only(struct usb_composite_dev *cdev,
+		struct usb_configuration *config)
+{
+	struct usb_configuration *c;
+
+	if (!config->bConfigurationValue)
+		return -EINVAL;
+
+	/* Prevent duplicate configuration identifiers */
+	list_for_each_entry(c, &cdev->configs, list) {
+		if (c->bConfigurationValue == config->bConfigurationValue)
+			return -EBUSY;
+	}
+
+	config->cdev = cdev;
+	list_add_tail(&config->list, &cdev->configs);
+
+	INIT_LIST_HEAD(&config->functions);
+	config->next_interface_id = 0;
+	memset(config->interface, 0, sizeof(config->interface));
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(usb_add_config_only);
+
+/**
+ * usb_add_config() - add a configuration to a device.
+ * @cdev: wraps the USB gadget
+ * @config: the configuration, with bConfigurationValue assigned
+ * @bind: the configuration's bind function
+ * Context: single threaded during gadget setup
+ *
+ * One of the main tasks of a composite @bind() routine is to
+ * add each of the configurations it supports, using this routine.
+ *
+ * This function returns the value of the configuration's @bind(), which
+ * is zero for success else a negative errno value.  Binding configurations
+ * assigns global resources including string IDs, and per-configuration
+ * resources such as interface IDs and endpoints.
+ */
+int usb_add_config(struct usb_composite_dev *cdev,
+		struct usb_configuration *config,
+		int (*bind)(struct usb_configuration *))
+{
+	int				status = -EINVAL;
+
+	if (!bind)
+		goto done;
+
+	DBG(cdev, "adding config #%u '%s'/%p\n",
+			config->bConfigurationValue,
+			config->label, config);
+
+	status = usb_add_config_only(cdev, config);
+	if (status)
+		goto done;
+
+	status = bind(config);
+	if (status < 0) {
+		while (!list_empty(&config->functions)) {
+			struct usb_function		*f;
+
+			f = list_first_entry(&config->functions,
+					struct usb_function, list);
+			list_del(&f->list);
+			if (f->unbind) {
+				DBG(cdev, "unbind function '%s'/%p\n",
+					f->name, f);
+				f->unbind(config, f);
+				/* may free memory for "f" */
+			}
+		}
+		list_del(&config->list);
+		config->cdev = NULL;
+	} else {
+		unsigned	i;
+
+		DBG(cdev, "cfg %d/%p speeds:%s%s%s%s\n",
+			config->bConfigurationValue, config,
+			config->superspeed_plus ? " superplus" : "",
+			config->superspeed ? " super" : "",
+			config->highspeed ? " high" : "",
+			config->fullspeed
+				? (gadget_is_dualspeed(cdev->gadget)
+					? " full"
+					: " full/low")
+				: "");
+
+		for (i = 0; i < MAX_CONFIG_INTERFACES; i++) {
+			struct usb_function	*f = config->interface[i];
+
+			if (!f)
+				continue;
+			DBG(cdev, "  interface %d = %s/%p\n",
+				i, f->name, f);
+		}
+	}
+
+	/* set_alt(), or next bind(), sets up ep->claimed as needed */
+	usb_ep_autoconfig_reset(cdev->gadget);
+
+done:
+	if (status)
+		DBG(cdev, "added config '%s'/%u --> %d\n", config->label,
+				config->bConfigurationValue, status);
+	return status;
+}
+EXPORT_SYMBOL_GPL(usb_add_config);
+
+static void remove_config(struct usb_composite_dev *cdev,
+			      struct usb_configuration *config)
+{
+	while (!list_empty(&config->functions)) {
+		struct usb_function		*f;
+
+		f = list_first_entry(&config->functions,
+				struct usb_function, list);
+
+		usb_remove_function(config, f);
+	}
+	list_del(&config->list);
+	if (config->unbind) {
+		DBG(cdev, "unbind config '%s'/%p\n", config->label, config);
+		config->unbind(config);
+			/* may free memory for "c" */
+	}
+}
+
+/**
+ * usb_remove_config() - remove a configuration from a device.
+ * @cdev: wraps the USB gadget
+ * @config: the configuration
+ *
+ * Drivers must call usb_gadget_disconnect before calling this function
+ * to disconnect the device from the host and make sure the host will not
+ * try to enumerate the device while we are changing the config list.
+ */
+void usb_remove_config(struct usb_composite_dev *cdev,
+		      struct usb_configuration *config)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&cdev->lock, flags);
+
+	if (cdev->config == config)
+		reset_config(cdev);
+
+	spin_unlock_irqrestore(&cdev->lock, flags);
+
+	remove_config(cdev, config);
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* We support strings in multiple languages ... string descriptor zero
+ * says which languages are supported.  The typical case will be that
+ * only one language (probably English) is used, with i18n handled on
+ * the host side.
+ */
+
+static void collect_langs(struct usb_gadget_strings **sp, __le16 *buf)
+{
+	const struct usb_gadget_strings	*s;
+	__le16				language;
+	__le16				*tmp;
+
+	while (*sp) {
+		s = *sp;
+		language = cpu_to_le16(s->language);
+		for (tmp = buf; *tmp && tmp < &buf[USB_MAX_STRING_LEN]; tmp++) {
+			if (*tmp == language)
+				goto repeat;
+		}
+		*tmp++ = language;
+repeat:
+		sp++;
+	}
+}
+
+static int lookup_string(
+	struct usb_gadget_strings	**sp,
+	void				*buf,
+	u16				language,
+	int				id
+)
+{
+	struct usb_gadget_strings	*s;
+	int				value;
+
+	while (*sp) {
+		s = *sp++;
+		if (s->language != language)
+			continue;
+		value = usb_gadget_get_string(s, id, buf);
+		if (value > 0)
+			return value;
+	}
+	return -EINVAL;
+}
+
+static int get_string(struct usb_composite_dev *cdev,
+		void *buf, u16 language, int id)
+{
+	struct usb_composite_driver	*composite = cdev->driver;
+	struct usb_gadget_string_container *uc;
+	struct usb_configuration	*c;
+	struct usb_function		*f;
+	int				len;
+
+	/* Yes, not only is USB's i18n support probably more than most
+	 * folk will ever care about ... also, it's all supported here.
+	 * (Except for UTF8 support for Unicode's "Astral Planes".)
+	 */
+
+	/* 0 == report all available language codes */
+	if (id == 0) {
+		struct usb_string_descriptor	*s = buf;
+		struct usb_gadget_strings	**sp;
+
+		memset(s, 0, 256);
+		s->bDescriptorType = USB_DT_STRING;
+
+		sp = composite->strings;
+		if (sp)
+			collect_langs(sp, s->wData);
+
+		list_for_each_entry(c, &cdev->configs, list) {
+			sp = c->strings;
+			if (sp)
+				collect_langs(sp, s->wData);
+
+			list_for_each_entry(f, &c->functions, list) {
+				sp = f->strings;
+				if (sp)
+					collect_langs(sp, s->wData);
+			}
+		}
+		list_for_each_entry(uc, &cdev->gstrings, list) {
+			struct usb_gadget_strings **sp;
+
+			sp = get_containers_gs(uc);
+			collect_langs(sp, s->wData);
+		}
+
+		for (len = 0; len <= USB_MAX_STRING_LEN && s->wData[len]; len++)
+			continue;
+		if (!len)
+			return -EINVAL;
+
+		s->bLength = 2 * (len + 1);
+		return s->bLength;
+	}
+
+	if (cdev->use_os_string && language == 0 && id == OS_STRING_IDX) {
+		struct usb_os_string *b = buf;
+		b->bLength = sizeof(*b);
+		b->bDescriptorType = USB_DT_STRING;
+		compiletime_assert(
+			sizeof(b->qwSignature) == sizeof(cdev->qw_sign),
+			"qwSignature size must be equal to qw_sign");
+		memcpy(&b->qwSignature, cdev->qw_sign, sizeof(b->qwSignature));
+		b->bMS_VendorCode = cdev->b_vendor_code;
+		b->bPad = 0;
+		return sizeof(*b);
+	}
+
+	list_for_each_entry(uc, &cdev->gstrings, list) {
+		struct usb_gadget_strings **sp;
+
+		sp = get_containers_gs(uc);
+		len = lookup_string(sp, buf, language, id);
+		if (len > 0)
+			return len;
+	}
+
+	/* String IDs are device-scoped, so we look up each string
+	 * table we're told about.  These lookups are infrequent;
+	 * simpler-is-better here.
+	 */
+	if (composite->strings) {
+		len = lookup_string(composite->strings, buf, language, id);
+		if (len > 0)
+			return len;
+	}
+	list_for_each_entry(c, &cdev->configs, list) {
+		if (c->strings) {
+			len = lookup_string(c->strings, buf, language, id);
+			if (len > 0)
+				return len;
+		}
+		list_for_each_entry(f, &c->functions, list) {
+			if (!f->strings)
+				continue;
+			len = lookup_string(f->strings, buf, language, id);
+			if (len > 0)
+				return len;
+		}
+	}
+	return -EINVAL;
+}
+
+/**
+ * usb_string_id() - allocate an unused string ID
+ * @cdev: the device whose string descriptor IDs are being allocated
+ * Context: single threaded during gadget setup
+ *
+ * @usb_string_id() is called from bind() callbacks to allocate
+ * string IDs.  Drivers for functions, configurations, or gadgets will
+ * then store that ID in the appropriate descriptors and string table.
+ *
+ * All string identifier should be allocated using this,
+ * @usb_string_ids_tab() or @usb_string_ids_n() routine, to ensure
+ * that for example different functions don't wrongly assign different
+ * meanings to the same identifier.
+ */
+int usb_string_id(struct usb_composite_dev *cdev)
+{
+	if (cdev->next_string_id < 254) {
+		/* string id 0 is reserved by USB spec for list of
+		 * supported languages */
+		/* 255 reserved as well? -- mina86 */
+		cdev->next_string_id++;
+		return cdev->next_string_id;
+	}
+	return -ENODEV;
+}
+EXPORT_SYMBOL_GPL(usb_string_id);
+
+/**
+ * usb_string_ids_tab() - allocate unused string IDs in batch
+ * @cdev: the device whose string descriptor IDs are being allocated
+ * @str: an array of usb_string objects to assign numbers to
+ * Context: single threaded during gadget setup
+ *
+ * @usb_string_ids() is called from bind() callbacks to allocate
+ * string IDs.  Drivers for functions, configurations, or gadgets will
+ * then copy IDs from the string table to the appropriate descriptors
+ * and string table for other languages.
+ *
+ * All string identifier should be allocated using this,
+ * @usb_string_id() or @usb_string_ids_n() routine, to ensure that for
+ * example different functions don't wrongly assign different meanings
+ * to the same identifier.
+ */
+int usb_string_ids_tab(struct usb_composite_dev *cdev, struct usb_string *str)
+{
+	int next = cdev->next_string_id;
+
+	for (; str->s; ++str) {
+		if (unlikely(next >= 254))
+			return -ENODEV;
+		str->id = ++next;
+	}
+
+	cdev->next_string_id = next;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(usb_string_ids_tab);
+
+static struct usb_gadget_string_container *copy_gadget_strings(
+		struct usb_gadget_strings **sp, unsigned n_gstrings,
+		unsigned n_strings)
+{
+	struct usb_gadget_string_container *uc;
+	struct usb_gadget_strings **gs_array;
+	struct usb_gadget_strings *gs;
+	struct usb_string *s;
+	unsigned mem;
+	unsigned n_gs;
+	unsigned n_s;
+	void *stash;
+
+	mem = sizeof(*uc);
+	mem += sizeof(void *) * (n_gstrings + 1);
+	mem += sizeof(struct usb_gadget_strings) * n_gstrings;
+	mem += sizeof(struct usb_string) * (n_strings + 1) * (n_gstrings);
+	uc = kmalloc(mem, GFP_KERNEL);
+	if (!uc)
+		return ERR_PTR(-ENOMEM);
+	gs_array = get_containers_gs(uc);
+	stash = uc->stash;
+	stash += sizeof(void *) * (n_gstrings + 1);
+	for (n_gs = 0; n_gs < n_gstrings; n_gs++) {
+		struct usb_string *org_s;
+
+		gs_array[n_gs] = stash;
+		gs = gs_array[n_gs];
+		stash += sizeof(struct usb_gadget_strings);
+		gs->language = sp[n_gs]->language;
+		gs->strings = stash;
+		org_s = sp[n_gs]->strings;
+
+		for (n_s = 0; n_s < n_strings; n_s++) {
+			s = stash;
+			stash += sizeof(struct usb_string);
+			if (org_s->s)
+				s->s = org_s->s;
+			else
+				s->s = "";
+			org_s++;
+		}
+		s = stash;
+		s->s = NULL;
+		stash += sizeof(struct usb_string);
+
+	}
+	gs_array[n_gs] = NULL;
+	return uc;
+}
+
+/**
+ * usb_gstrings_attach() - attach gadget strings to a cdev and assign ids
+ * @cdev: the device whose string descriptor IDs are being allocated
+ * and attached.
+ * @sp: an array of usb_gadget_strings to attach.
+ * @n_strings: number of entries in each usb_strings array (sp[]->strings)
+ *
+ * This function will create a deep copy of usb_gadget_strings and usb_string
+ * and attach it to the cdev. The actual string (usb_string.s) will not be
+ * copied but only a referenced will be made. The struct usb_gadget_strings
+ * array may contain multiple languages and should be NULL terminated.
+ * The ->language pointer of each struct usb_gadget_strings has to contain the
+ * same amount of entries.
+ * For instance: sp[0] is en-US, sp[1] is es-ES. It is expected that the first
+ * usb_string entry of es-ES contains the translation of the first usb_string
+ * entry of en-US. Therefore both entries become the same id assign.
+ */
+struct usb_string *usb_gstrings_attach(struct usb_composite_dev *cdev,
+		struct usb_gadget_strings **sp, unsigned n_strings)
+{
+	struct usb_gadget_string_container *uc;
+	struct usb_gadget_strings **n_gs;
+	unsigned n_gstrings = 0;
+	unsigned i;
+	int ret;
+
+	for (i = 0; sp[i]; i++)
+		n_gstrings++;
+
+	if (!n_gstrings)
+		return ERR_PTR(-EINVAL);
+
+	uc = copy_gadget_strings(sp, n_gstrings, n_strings);
+	if (IS_ERR(uc))
+		return ERR_CAST(uc);
+
+	n_gs = get_containers_gs(uc);
+	ret = usb_string_ids_tab(cdev, n_gs[0]->strings);
+	if (ret)
+		goto err;
+
+	for (i = 1; i < n_gstrings; i++) {
+		struct usb_string *m_s;
+		struct usb_string *s;
+		unsigned n;
+
+		m_s = n_gs[0]->strings;
+		s = n_gs[i]->strings;
+		for (n = 0; n < n_strings; n++) {
+			s->id = m_s->id;
+			s++;
+			m_s++;
+		}
+	}
+	list_add_tail(&uc->list, &cdev->gstrings);
+	return n_gs[0]->strings;
+err:
+	kfree(uc);
+	return ERR_PTR(ret);
+}
+EXPORT_SYMBOL_GPL(usb_gstrings_attach);
+
+/**
+ * usb_string_ids_n() - allocate unused string IDs in batch
+ * @c: the device whose string descriptor IDs are being allocated
+ * @n: number of string IDs to allocate
+ * Context: single threaded during gadget setup
+ *
+ * Returns the first requested ID.  This ID and next @n-1 IDs are now
+ * valid IDs.  At least provided that @n is non-zero because if it
+ * is, returns last requested ID which is now very useful information.
+ *
+ * @usb_string_ids_n() is called from bind() callbacks to allocate
+ * string IDs.  Drivers for functions, configurations, or gadgets will
+ * then store that ID in the appropriate descriptors and string table.
+ *
+ * All string identifier should be allocated using this,
+ * @usb_string_id() or @usb_string_ids_n() routine, to ensure that for
+ * example different functions don't wrongly assign different meanings
+ * to the same identifier.
+ */
+int usb_string_ids_n(struct usb_composite_dev *c, unsigned n)
+{
+	unsigned next = c->next_string_id;
+	if (unlikely(n > 254 || (unsigned)next + n > 254))
+		return -ENODEV;
+	c->next_string_id += n;
+	return next + 1;
+}
+EXPORT_SYMBOL_GPL(usb_string_ids_n);
+
+/*-------------------------------------------------------------------------*/
+
+static void composite_setup_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	struct usb_composite_dev *cdev;
+
+	if (req->status || req->actual != req->length)
+		DBG((struct usb_composite_dev *) ep->driver_data,
+				"setup complete --> %d, %d/%d\n",
+				req->status, req->actual, req->length);
+
+	/*
+	 * REVIST The same ep0 requests are shared with function drivers
+	 * so they don't have to maintain the same ->complete() stubs.
+	 *
+	 * Because of that, we need to check for the validity of ->context
+	 * here, even though we know we've set it to something useful.
+	 */
+	if (!req->context)
+		return;
+
+	cdev = req->context;
+
+	if (cdev->req == req)
+		cdev->setup_pending = false;
+	else if (cdev->os_desc_req == req)
+		cdev->os_desc_pending = false;
+	else
+		WARN(1, "unknown request %p\n", req);
+}
+
+static int composite_ep0_queue(struct usb_composite_dev *cdev,
+		struct usb_request *req, gfp_t gfp_flags)
+{
+	int ret;
+
+	ret = usb_ep_queue(cdev->gadget->ep0, req, gfp_flags);
+	if (ret == 0) {
+		if (cdev->req == req)
+			cdev->setup_pending = true;
+		else if (cdev->os_desc_req == req)
+			cdev->os_desc_pending = true;
+		else
+			WARN(1, "unknown request %p\n", req);
+	}
+
+	return ret;
+}
+
+static int count_ext_compat(struct usb_configuration *c)
+{
+	int i, res;
+
+	res = 0;
+	for (i = 0; i < c->next_interface_id; ++i) {
+		struct usb_function *f;
+		int j;
+
+		f = c->interface[i];
+		for (j = 0; j < f->os_desc_n; ++j) {
+			struct usb_os_desc *d;
+
+			if (i != f->os_desc_table[j].if_id)
+				continue;
+			d = f->os_desc_table[j].os_desc;
+			if (d && d->ext_compat_id)
+				++res;
+		}
+	}
+	BUG_ON(res > 255);
+	return res;
+}
+
+static int fill_ext_compat(struct usb_configuration *c, u8 *buf)
+{
+	int i, count;
+
+	count = 16;
+	buf += 16;
+	for (i = 0; i < c->next_interface_id; ++i) {
+		struct usb_function *f;
+		int j;
+
+		f = c->interface[i];
+		for (j = 0; j < f->os_desc_n; ++j) {
+			struct usb_os_desc *d;
+
+			if (i != f->os_desc_table[j].if_id)
+				continue;
+			d = f->os_desc_table[j].os_desc;
+			if (d && d->ext_compat_id) {
+				*buf++ = i;
+				*buf++ = 0x01;
+				memcpy(buf, d->ext_compat_id, 16);
+				buf += 22;
+			} else {
+				++buf;
+				*buf = 0x01;
+				buf += 23;
+			}
+			count += 24;
+			if (count + 24 >= USB_COMP_EP0_OS_DESC_BUFSIZ)
+				return count;
+		}
+	}
+
+	return count;
+}
+
+static int count_ext_prop(struct usb_configuration *c, int interface)
+{
+	struct usb_function *f;
+	int j;
+
+	f = c->interface[interface];
+	for (j = 0; j < f->os_desc_n; ++j) {
+		struct usb_os_desc *d;
+
+		if (interface != f->os_desc_table[j].if_id)
+			continue;
+		d = f->os_desc_table[j].os_desc;
+		if (d && d->ext_compat_id)
+			return d->ext_prop_count;
+	}
+	return 0;
+}
+
+static int len_ext_prop(struct usb_configuration *c, int interface)
+{
+	struct usb_function *f;
+	struct usb_os_desc *d;
+	int j, res;
+
+	res = 10; /* header length */
+	f = c->interface[interface];
+	for (j = 0; j < f->os_desc_n; ++j) {
+		if (interface != f->os_desc_table[j].if_id)
+			continue;
+		d = f->os_desc_table[j].os_desc;
+		if (d)
+			return min(res + d->ext_prop_len, 4096);
+	}
+	return res;
+}
+
+static int fill_ext_prop(struct usb_configuration *c, int interface, u8 *buf)
+{
+	struct usb_function *f;
+	struct usb_os_desc *d;
+	struct usb_os_desc_ext_prop *ext_prop;
+	int j, count, n, ret;
+
+	f = c->interface[interface];
+	count = 10; /* header length */
+	buf += 10;
+	for (j = 0; j < f->os_desc_n; ++j) {
+		if (interface != f->os_desc_table[j].if_id)
+			continue;
+		d = f->os_desc_table[j].os_desc;
+		if (d)
+			list_for_each_entry(ext_prop, &d->ext_prop, entry) {
+				n = ext_prop->data_len +
+					ext_prop->name_len + 14;
+				if (count + n >= USB_COMP_EP0_OS_DESC_BUFSIZ)
+					return count;
+				usb_ext_prop_put_size(buf, n);
+				usb_ext_prop_put_type(buf, ext_prop->type);
+				ret = usb_ext_prop_put_name(buf, ext_prop->name,
+							    ext_prop->name_len);
+				if (ret < 0)
+					return ret;
+				switch (ext_prop->type) {
+				case USB_EXT_PROP_UNICODE:
+				case USB_EXT_PROP_UNICODE_ENV:
+				case USB_EXT_PROP_UNICODE_LINK:
+					usb_ext_prop_put_unicode(buf, ret,
+							 ext_prop->data,
+							 ext_prop->data_len);
+					break;
+				case USB_EXT_PROP_BINARY:
+					usb_ext_prop_put_binary(buf, ret,
+							ext_prop->data,
+							ext_prop->data_len);
+					break;
+				case USB_EXT_PROP_LE32:
+					/* not implemented */
+				case USB_EXT_PROP_BE32:
+					/* not implemented */
+				default:
+					return -EINVAL;
+				}
+				buf += n;
+				count += n;
+			}
+	}
+
+	return count;
+}
+
+/*
+ * The setup() callback implements all the ep0 functionality that's
+ * not handled lower down, in hardware or the hardware driver(like
+ * device and endpoint feature flags, and their status).  It's all
+ * housekeeping for the gadget function we're implementing.  Most of
+ * the work is in config and function specific setup.
+ */
+int
+composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
+{
+	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
+	struct usb_request		*req = cdev->req;
+	int				value = -EOPNOTSUPP;
+	int				status = 0;
+	u16				w_index = le16_to_cpu(ctrl->wIndex);
+	u8				intf = w_index & 0xFF;
+	u16				w_value = le16_to_cpu(ctrl->wValue);
+	u16				w_length = le16_to_cpu(ctrl->wLength);
+	struct usb_function		*f = NULL;
+	u8				endp;
+
+	if (w_length > USB_COMP_EP0_BUFSIZ) {
+		if (ctrl->bRequestType & USB_DIR_IN) {
+			/* Cast away the const, we are going to overwrite on purpose. */
+			__le16 *temp = (__le16 *)&ctrl->wLength;
+
+			*temp = cpu_to_le16(USB_COMP_EP0_BUFSIZ);
+			w_length = USB_COMP_EP0_BUFSIZ;
+		} else {
+			goto done;
+		}
+	}
+
+	/* partial re-init of the response message; the function or the
+	 * gadget might need to intercept e.g. a control-OUT completion
+	 * when we delegate to it.
+	 */
+	req->zero = 0;
+	req->context = cdev;
+	req->complete = composite_setup_complete;
+	req->length = 0;
+	gadget->ep0->driver_data = cdev;
+
+	/*
+	 * Don't let non-standard requests match any of the cases below
+	 * by accident.
+	 */
+	if ((ctrl->bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD)
+		goto unknown;
+
+	switch (ctrl->bRequest) {
+
+	/* we handle all standard USB descriptors */
+	case USB_REQ_GET_DESCRIPTOR:
+		if (ctrl->bRequestType != USB_DIR_IN)
+			goto unknown;
+		switch (w_value >> 8) {
+
+		case USB_DT_DEVICE:
+			cdev->desc.bNumConfigurations =
+				count_configs(cdev, USB_DT_DEVICE);
+			cdev->desc.bMaxPacketSize0 =
+				cdev->gadget->ep0->maxpacket;
+			if (gadget_is_superspeed(gadget)) {
+				if (gadget->speed >= USB_SPEED_SUPER) {
+					cdev->desc.bcdUSB = cpu_to_le16(0x0320);
+					cdev->desc.bMaxPacketSize0 = 9;
+				} else {
+					cdev->desc.bcdUSB = cpu_to_le16(0x0210);
+				}
+			} else {
+				if (gadget->lpm_capable)
+					cdev->desc.bcdUSB = cpu_to_le16(0x0201);
+				else
+					cdev->desc.bcdUSB = cpu_to_le16(0x0200);
+			}
+
+			value = min(w_length, (u16) sizeof cdev->desc);
+			memcpy(req->buf, &cdev->desc, value);
+			break;
+		case USB_DT_DEVICE_QUALIFIER:
+			if (!gadget_is_dualspeed(gadget) ||
+			    gadget->speed >= USB_SPEED_SUPER)
+				break;
+			device_qual(cdev);
+			value = min_t(int, w_length,
+				sizeof(struct usb_qualifier_descriptor));
+			break;
+		case USB_DT_OTHER_SPEED_CONFIG:
+			if (!gadget_is_dualspeed(gadget) ||
+			    gadget->speed >= USB_SPEED_SUPER)
+				break;
+			fallthrough;
+		case USB_DT_CONFIG:
+			value = config_desc(cdev, w_value);
+			if (value >= 0)
+				value = min(w_length, (u16) value);
+			break;
+		case USB_DT_STRING:
+			value = get_string(cdev, req->buf,
+					w_index, w_value & 0xff);
+			if (value >= 0)
+				value = min(w_length, (u16) value);
+			break;
+		case USB_DT_BOS:
+			if (gadget_is_superspeed(gadget) ||
+			    gadget->lpm_capable) {
+				value = bos_desc(cdev);
+				value = min(w_length, (u16) value);
+			}
+			break;
+		case USB_DT_OTG:
+			if (gadget_is_otg(gadget)) {
+				struct usb_configuration *config;
+				int otg_desc_len = 0;
+
+				if (cdev->config)
+					config = cdev->config;
+				else
+					config = list_first_entry(
+							&cdev->configs,
+						struct usb_configuration, list);
+				if (!config)
+					goto done;
+
+				if (gadget->otg_caps &&
+					(gadget->otg_caps->otg_rev >= 0x0200))
+					otg_desc_len += sizeof(
+						struct usb_otg20_descriptor);
+				else
+					otg_desc_len += sizeof(
+						struct usb_otg_descriptor);
+
+				value = min_t(int, w_length, otg_desc_len);
+				memcpy(req->buf, config->descriptors[0], value);
+			}
+			break;
+		}
+		break;
+
+	/* any number of configs can work */
+	case USB_REQ_SET_CONFIGURATION:
+		if (ctrl->bRequestType != 0)
+			goto unknown;
+		if (gadget_is_otg(gadget)) {
+			if (gadget->a_hnp_support)
+				DBG(cdev, "HNP available\n");
+			else if (gadget->a_alt_hnp_support)
+				DBG(cdev, "HNP on another port\n");
+			else
+				VDBG(cdev, "HNP inactive\n");
+		}
+		spin_lock(&cdev->lock);
+		value = set_config(cdev, ctrl, w_value);
+		spin_unlock(&cdev->lock);
+		break;
+	case USB_REQ_GET_CONFIGURATION:
+		if (ctrl->bRequestType != USB_DIR_IN)
+			goto unknown;
+		if (cdev->config)
+			*(u8 *)req->buf = cdev->config->bConfigurationValue;
+		else
+			*(u8 *)req->buf = 0;
+		value = min(w_length, (u16) 1);
+		break;
+
+	/* function drivers must handle get/set altsetting */
+	case USB_REQ_SET_INTERFACE:
+		if (ctrl->bRequestType != USB_RECIP_INTERFACE)
+			goto unknown;
+		if (!cdev->config || intf >= MAX_CONFIG_INTERFACES)
+			break;
+		f = cdev->config->interface[intf];
+		if (!f)
+			break;
+
+		/*
+		 * If there's no get_alt() method, we know only altsetting zero
+		 * works. There is no need to check if set_alt() is not NULL
+		 * as we check this in usb_add_function().
+		 */
+		if (w_value && !f->get_alt)
+			break;
+
+		spin_lock(&cdev->lock);
+		value = f->set_alt(f, w_index, w_value);
+		if (value == USB_GADGET_DELAYED_STATUS) {
+			DBG(cdev,
+			 "%s: interface %d (%s) requested delayed status\n",
+					__func__, intf, f->name);
+			cdev->delayed_status++;
+			DBG(cdev, "delayed_status count %d\n",
+					cdev->delayed_status);
+		}
+		spin_unlock(&cdev->lock);
+		break;
+	case USB_REQ_GET_INTERFACE:
+		if (ctrl->bRequestType != (USB_DIR_IN|USB_RECIP_INTERFACE))
+			goto unknown;
+		if (!cdev->config || intf >= MAX_CONFIG_INTERFACES)
+			break;
+		f = cdev->config->interface[intf];
+		if (!f)
+			break;
+		/* lots of interfaces only need altsetting zero... */
+		value = f->get_alt ? f->get_alt(f, w_index) : 0;
+		if (value < 0)
+			break;
+		*((u8 *)req->buf) = value;
+		value = min(w_length, (u16) 1);
+		break;
+	case USB_REQ_GET_STATUS:
+		if (gadget_is_otg(gadget) && gadget->hnp_polling_support &&
+						(w_index == OTG_STS_SELECTOR)) {
+			if (ctrl->bRequestType != (USB_DIR_IN |
+							USB_RECIP_DEVICE))
+				goto unknown;
+			*((u8 *)req->buf) = gadget->host_request_flag;
+			value = 1;
+			break;
+		}
+
+		/*
+		 * USB 3.0 additions:
+		 * Function driver should handle get_status request. If such cb
+		 * wasn't supplied we respond with default value = 0
+		 * Note: function driver should supply such cb only for the
+		 * first interface of the function
+		 */
+		if (!gadget_is_superspeed(gadget))
+			goto unknown;
+		if (ctrl->bRequestType != (USB_DIR_IN | USB_RECIP_INTERFACE))
+			goto unknown;
+		value = 2;	/* This is the length of the get_status reply */
+		put_unaligned_le16(0, req->buf);
+		if (!cdev->config || intf >= MAX_CONFIG_INTERFACES)
+			break;
+		f = cdev->config->interface[intf];
+		if (!f)
+			break;
+		status = f->get_status ? f->get_status(f) : 0;
+		if (status < 0)
+			break;
+		put_unaligned_le16(status & 0x0000ffff, req->buf);
+		break;
+	/*
+	 * Function drivers should handle SetFeature/ClearFeature
+	 * (FUNCTION_SUSPEND) request. function_suspend cb should be supplied
+	 * only for the first interface of the function
+	 */
+	case USB_REQ_CLEAR_FEATURE:
+	case USB_REQ_SET_FEATURE:
+		if (!gadget_is_superspeed(gadget))
+			goto unknown;
+		if (ctrl->bRequestType != (USB_DIR_OUT | USB_RECIP_INTERFACE))
+			goto unknown;
+		switch (w_value) {
+		case USB_INTRF_FUNC_SUSPEND:
+			if (!cdev->config || intf >= MAX_CONFIG_INTERFACES)
+				break;
+			f = cdev->config->interface[intf];
+			if (!f)
+				break;
+			value = 0;
+			if (f->func_suspend)
+				value = f->func_suspend(f, w_index >> 8);
+			if (value < 0) {
+				ERROR(cdev,
+				      "func_suspend() returned error %d\n",
+				      value);
+				value = 0;
+			}
+			break;
+		}
+		break;
+	default:
+unknown:
+		/*
+		 * OS descriptors handling
+		 */
+		if (cdev->use_os_string && cdev->os_desc_config &&
+		    (ctrl->bRequestType & USB_TYPE_VENDOR) &&
+		    ctrl->bRequest == cdev->b_vendor_code) {
+			struct usb_configuration	*os_desc_cfg;
+			u8				*buf;
+			int				interface;
+			int				count = 0;
+
+			req = cdev->os_desc_req;
+			req->context = cdev;
+			req->complete = composite_setup_complete;
+			buf = req->buf;
+			os_desc_cfg = cdev->os_desc_config;
+			w_length = min_t(u16, w_length, USB_COMP_EP0_OS_DESC_BUFSIZ);
+			memset(buf, 0, w_length);
+			buf[5] = 0x01;
+			switch (ctrl->bRequestType & USB_RECIP_MASK) {
+			case USB_RECIP_DEVICE:
+				if (w_index != 0x4 || (w_value >> 8))
+					break;
+				buf[6] = w_index;
+				/* Number of ext compat interfaces */
+				count = count_ext_compat(os_desc_cfg);
+				buf[8] = count;
+				count *= 24; /* 24 B/ext compat desc */
+				count += 16; /* header */
+				put_unaligned_le32(count, buf);
+				value = w_length;
+				if (w_length > 0x10) {
+					value = fill_ext_compat(os_desc_cfg, buf);
+					value = min_t(u16, w_length, value);
+				}
+				break;
+			case USB_RECIP_INTERFACE:
+				if (w_index != 0x5 || (w_value >> 8))
+					break;
+				interface = w_value & 0xFF;
+				if (interface >= MAX_CONFIG_INTERFACES ||
+				    !os_desc_cfg->interface[interface])
+					break;
+				buf[6] = w_index;
+				count = count_ext_prop(os_desc_cfg,
+					interface);
+				put_unaligned_le16(count, buf + 8);
+				count = len_ext_prop(os_desc_cfg,
+					interface);
+				put_unaligned_le32(count, buf);
+				value = w_length;
+				if (w_length > 0x0A) {
+					value = fill_ext_prop(os_desc_cfg,
+							      interface, buf);
+					if (value >= 0)
+						value = min_t(u16, w_length, value);
+				}
+				break;
+			}
+
+			goto check_value;
+		}
+
+		VDBG(cdev,
+			"non-core control req%02x.%02x v%04x i%04x l%d\n",
+			ctrl->bRequestType, ctrl->bRequest,
+			w_value, w_index, w_length);
+
+		/* functions always handle their interfaces and endpoints...
+		 * punt other recipients (other, WUSB, ...) to the current
+		 * configuration code.
+		 */
+		if (cdev->config) {
+			list_for_each_entry(f, &cdev->config->functions, list)
+				if (f->req_match &&
+				    f->req_match(f, ctrl, false))
+					goto try_fun_setup;
+		} else {
+			struct usb_configuration *c;
+			list_for_each_entry(c, &cdev->configs, list)
+				list_for_each_entry(f, &c->functions, list)
+					if (f->req_match &&
+					    f->req_match(f, ctrl, true))
+						goto try_fun_setup;
+		}
+		f = NULL;
+
+		switch (ctrl->bRequestType & USB_RECIP_MASK) {
+		case USB_RECIP_INTERFACE:
+			if (!cdev->config || intf >= MAX_CONFIG_INTERFACES)
+				break;
+			f = cdev->config->interface[intf];
+			break;
+
+		case USB_RECIP_ENDPOINT:
+			if (!cdev->config)
+				break;
+			endp = ((w_index & 0x80) >> 3) | (w_index & 0x0f);
+			list_for_each_entry(f, &cdev->config->functions, list) {
+				if (test_bit(endp, f->endpoints))
+					break;
+			}
+			if (&f->list == &cdev->config->functions)
+				f = NULL;
+			break;
+		}
+try_fun_setup:
+		if (f && f->setup)
+			value = f->setup(f, ctrl);
+		else {
+			struct usb_configuration	*c;
+
+			c = cdev->config;
+			if (!c)
+				goto done;
+
+			/* try current config's setup */
+			if (c->setup) {
+				value = c->setup(c, ctrl);
+				goto done;
+			}
+
+			/* try the only function in the current config */
+			if (!list_is_singular(&c->functions))
+				goto done;
+			f = list_first_entry(&c->functions, struct usb_function,
+					     list);
+			if (f->setup)
+				value = f->setup(f, ctrl);
+		}
+
+		goto done;
+	}
+
+check_value:
+	/* respond with data transfer before status phase? */
+	if (value >= 0 && value != USB_GADGET_DELAYED_STATUS) {
+		req->length = value;
+		req->context = cdev;
+		req->zero = value < w_length;
+		value = composite_ep0_queue(cdev, req, GFP_ATOMIC);
+		if (value < 0) {
+			DBG(cdev, "ep_queue --> %d\n", value);
+			req->status = 0;
+			composite_setup_complete(gadget->ep0, req);
+		}
+	} else if (value == USB_GADGET_DELAYED_STATUS && w_length != 0) {
+		WARN(cdev,
+			"%s: Delayed status not supported for w_length != 0",
+			__func__);
+	}
+
+done:
+	/* device either stalls (value < 0) or reports success */
+	return value;
+}
+
+static void __composite_disconnect(struct usb_gadget *gadget)
+{
+	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
+	unsigned long			flags;
+
+	/* REVISIT:  should we have config and device level
+	 * disconnect callbacks?
+	 */
+	spin_lock_irqsave(&cdev->lock, flags);
+	cdev->suspended = 0;
+	if (cdev->config)
+		reset_config(cdev);
+	if (cdev->driver->disconnect)
+		cdev->driver->disconnect(cdev);
+	spin_unlock_irqrestore(&cdev->lock, flags);
+}
+
+void composite_disconnect(struct usb_gadget *gadget)
+{
+	usb_gadget_vbus_draw(gadget, 0);
+	__composite_disconnect(gadget);
+}
+
+void composite_reset(struct usb_gadget *gadget)
+{
+	/*
+	 * Section 1.4.13 Standard Downstream Port of the USB battery charging
+	 * specification v1.2 states that a device connected on a SDP shall only
+	 * draw at max 100mA while in a connected, but unconfigured state.
+	 */
+	usb_gadget_vbus_draw(gadget, 100);
+	__composite_disconnect(gadget);
+}
+
+/*-------------------------------------------------------------------------*/
+
+static ssize_t suspended_show(struct device *dev, struct device_attribute *attr,
+			      char *buf)
+{
+	struct usb_gadget *gadget = dev_to_usb_gadget(dev);
+	struct usb_composite_dev *cdev = get_gadget_data(gadget);
+
+	return sprintf(buf, "%d\n", cdev->suspended);
+}
+static DEVICE_ATTR_RO(suspended);
+
+static void __composite_unbind(struct usb_gadget *gadget, bool unbind_driver)
+{
+	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
+	struct usb_gadget_strings	*gstr = cdev->driver->strings[0];
+	struct usb_string		*dev_str = gstr->strings;
+
+	/* composite_disconnect() must already have been called
+	 * by the underlying peripheral controller driver!
+	 * so there's no i/o concurrency that could affect the
+	 * state protected by cdev->lock.
+	 */
+	WARN_ON(cdev->config);
+
+	while (!list_empty(&cdev->configs)) {
+		struct usb_configuration	*c;
+		c = list_first_entry(&cdev->configs,
+				struct usb_configuration, list);
+		remove_config(cdev, c);
+	}
+	if (cdev->driver->unbind && unbind_driver)
+		cdev->driver->unbind(cdev);
+
+	composite_dev_cleanup(cdev);
+
+	if (dev_str[USB_GADGET_MANUFACTURER_IDX].s == cdev->def_manufacturer)
+		dev_str[USB_GADGET_MANUFACTURER_IDX].s = "";
+
+	kfree(cdev->def_manufacturer);
+	kfree(cdev);
+	set_gadget_data(gadget, NULL);
+}
+
+static void composite_unbind(struct usb_gadget *gadget)
+{
+	__composite_unbind(gadget, true);
+}
+
+static void update_unchanged_dev_desc(struct usb_device_descriptor *new,
+		const struct usb_device_descriptor *old)
+{
+	__le16 idVendor;
+	__le16 idProduct;
+	__le16 bcdDevice;
+	u8 iSerialNumber;
+	u8 iManufacturer;
+	u8 iProduct;
+
+	/*
+	 * these variables may have been set in
+	 * usb_composite_overwrite_options()
+	 */
+	idVendor = new->idVendor;
+	idProduct = new->idProduct;
+	bcdDevice = new->bcdDevice;
+	iSerialNumber = new->iSerialNumber;
+	iManufacturer = new->iManufacturer;
+	iProduct = new->iProduct;
+
+	*new = *old;
+	if (idVendor)
+		new->idVendor = idVendor;
+	if (idProduct)
+		new->idProduct = idProduct;
+	if (bcdDevice)
+		new->bcdDevice = bcdDevice;
+	else
+		new->bcdDevice = cpu_to_le16(get_default_bcdDevice());
+	if (iSerialNumber)
+		new->iSerialNumber = iSerialNumber;
+	if (iManufacturer)
+		new->iManufacturer = iManufacturer;
+	if (iProduct)
+		new->iProduct = iProduct;
+}
+
+int composite_dev_prepare(struct usb_composite_driver *composite,
+		struct usb_composite_dev *cdev)
+{
+	struct usb_gadget *gadget = cdev->gadget;
+	int ret = -ENOMEM;
+
+	/* preallocate control response and buffer */
+	cdev->req = usb_ep_alloc_request(gadget->ep0, GFP_KERNEL);
+	if (!cdev->req)
+		return -ENOMEM;
+
+	cdev->req->buf = kzalloc(USB_COMP_EP0_BUFSIZ, GFP_KERNEL);
+	if (!cdev->req->buf)
+		goto fail;
+
+	ret = device_create_file(&gadget->dev, &dev_attr_suspended);
+	if (ret)
+		goto fail_dev;
+
+	cdev->req->complete = composite_setup_complete;
+	cdev->req->context = cdev;
+	gadget->ep0->driver_data = cdev;
+
+	cdev->driver = composite;
+
+	/*
+	 * As per USB compliance update, a device that is actively drawing
+	 * more than 100mA from USB must report itself as bus-powered in
+	 * the GetStatus(DEVICE) call.
+	 */
+	if (CONFIG_USB_GADGET_VBUS_DRAW <= USB_SELF_POWER_VBUS_MAX_DRAW)
+		usb_gadget_set_selfpowered(gadget);
+
+	/* interface and string IDs start at zero via kzalloc.
+	 * we force endpoints to start unassigned; few controller
+	 * drivers will zero ep->driver_data.
+	 */
+	usb_ep_autoconfig_reset(gadget);
+	return 0;
+fail_dev:
+	kfree(cdev->req->buf);
+fail:
+	usb_ep_free_request(gadget->ep0, cdev->req);
+	cdev->req = NULL;
+	return ret;
+}
+
+int composite_os_desc_req_prepare(struct usb_composite_dev *cdev,
+				  struct usb_ep *ep0)
+{
+	int ret = 0;
+
+	cdev->os_desc_req = usb_ep_alloc_request(ep0, GFP_KERNEL);
+	if (!cdev->os_desc_req) {
+		ret = -ENOMEM;
+		goto end;
+	}
+
+	cdev->os_desc_req->buf = kmalloc(USB_COMP_EP0_OS_DESC_BUFSIZ,
+					 GFP_KERNEL);
+	if (!cdev->os_desc_req->buf) {
+		ret = -ENOMEM;
+		usb_ep_free_request(ep0, cdev->os_desc_req);
+		goto end;
+	}
+	cdev->os_desc_req->context = cdev;
+	cdev->os_desc_req->complete = composite_setup_complete;
+end:
+	return ret;
+}
+
+void composite_dev_cleanup(struct usb_composite_dev *cdev)
+{
+	struct usb_gadget_string_container *uc, *tmp;
+	struct usb_ep			   *ep, *tmp_ep;
+
+	list_for_each_entry_safe(uc, tmp, &cdev->gstrings, list) {
+		list_del(&uc->list);
+		kfree(uc);
+	}
+	if (cdev->os_desc_req) {
+		if (cdev->os_desc_pending)
+			usb_ep_dequeue(cdev->gadget->ep0, cdev->os_desc_req);
+
+		kfree(cdev->os_desc_req->buf);
+		cdev->os_desc_req->buf = NULL;
+		usb_ep_free_request(cdev->gadget->ep0, cdev->os_desc_req);
+		cdev->os_desc_req = NULL;
+	}
+	if (cdev->req) {
+		if (cdev->setup_pending)
+			usb_ep_dequeue(cdev->gadget->ep0, cdev->req);
+
+		kfree(cdev->req->buf);
+		cdev->req->buf = NULL;
+		usb_ep_free_request(cdev->gadget->ep0, cdev->req);
+		cdev->req = NULL;
+	}
+	cdev->next_string_id = 0;
+	device_remove_file(&cdev->gadget->dev, &dev_attr_suspended);
+
+	/*
+	 * Some UDC backends have a dynamic EP allocation scheme.
+	 *
+	 * In that case, the dispose() callback is used to notify the
+	 * backend that the EPs are no longer in use.
+	 *
+	 * Note: The UDC backend can remove the EP from the ep_list as
+	 *	 a result, so we need to use the _safe list iterator.
+	 */
+	list_for_each_entry_safe(ep, tmp_ep,
+				 &cdev->gadget->ep_list, ep_list) {
+		if (ep->ops->dispose)
+			ep->ops->dispose(ep);
+	}
+}
+
+static int composite_bind(struct usb_gadget *gadget,
+		struct usb_gadget_driver *gdriver)
+{
+	struct usb_composite_dev	*cdev;
+	struct usb_composite_driver	*composite = to_cdriver(gdriver);
+	int				status = -ENOMEM;
+
+	cdev = kzalloc(sizeof *cdev, GFP_KERNEL);
+	if (!cdev)
+		return status;
+
+	spin_lock_init(&cdev->lock);
+	cdev->gadget = gadget;
+	set_gadget_data(gadget, cdev);
+	INIT_LIST_HEAD(&cdev->configs);
+	INIT_LIST_HEAD(&cdev->gstrings);
+
+	status = composite_dev_prepare(composite, cdev);
+	if (status)
+		goto fail;
+
+	/* composite gadget needs to assign strings for whole device (like
+	 * serial number), register function drivers, potentially update
+	 * power state and consumption, etc
+	 */
+	status = composite->bind(cdev);
+	if (status < 0)
+		goto fail;
+
+	if (cdev->use_os_string) {
+		status = composite_os_desc_req_prepare(cdev, gadget->ep0);
+		if (status)
+			goto fail;
+	}
+
+	update_unchanged_dev_desc(&cdev->desc, composite->dev);
+
+	/* has userspace failed to provide a serial number? */
+	if (composite->needs_serial && !cdev->desc.iSerialNumber)
+		WARNING(cdev, "userspace failed to provide iSerialNumber\n");
+
+	INFO(cdev, "%s ready\n", composite->name);
+	return 0;
+
+fail:
+	__composite_unbind(gadget, false);
+	return status;
+}
+
+/*-------------------------------------------------------------------------*/
+
+void composite_suspend(struct usb_gadget *gadget)
+{
+	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
+	struct usb_function		*f;
+
+	/* REVISIT:  should we have config level
+	 * suspend/resume callbacks?
+	 */
+	DBG(cdev, "suspend\n");
+	if (cdev->config) {
+		list_for_each_entry(f, &cdev->config->functions, list) {
+			if (f->suspend)
+				f->suspend(f);
+		}
+	}
+	if (cdev->driver->suspend)
+		cdev->driver->suspend(cdev);
+
+	cdev->suspended = 1;
+
+	usb_gadget_set_selfpowered(gadget);
+	usb_gadget_vbus_draw(gadget, 2);
+}
+
+void composite_resume(struct usb_gadget *gadget)
+{
+	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
+	struct usb_function		*f;
+	unsigned			maxpower;
+
+	/* REVISIT:  should we have config level
+	 * suspend/resume callbacks?
+	 */
+	DBG(cdev, "resume\n");
+	if (cdev->driver->resume)
+		cdev->driver->resume(cdev);
+	if (cdev->config) {
+		list_for_each_entry(f, &cdev->config->functions, list) {
+			if (f->resume)
+				f->resume(f);
+		}
+
+		maxpower = cdev->config->MaxPower ?
+			cdev->config->MaxPower : CONFIG_USB_GADGET_VBUS_DRAW;
+		if (gadget->speed < USB_SPEED_SUPER)
+			maxpower = min(maxpower, 500U);
+		else
+			maxpower = min(maxpower, 900U);
+
+		if (maxpower > USB_SELF_POWER_VBUS_MAX_DRAW)
+			usb_gadget_clear_selfpowered(gadget);
+
+		usb_gadget_vbus_draw(gadget, maxpower);
+	}
+
+	cdev->suspended = 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static const struct usb_gadget_driver composite_driver_template = {
+	.bind		= composite_bind,
+	.unbind		= composite_unbind,
+
+	.setup		= composite_setup,
+	.reset		= composite_reset,
+	.disconnect	= composite_disconnect,
+
+	.suspend	= composite_suspend,
+	.resume		= composite_resume,
+
+	.driver	= {
+		.owner		= THIS_MODULE,
+	},
+};
+
+/**
+ * usb_composite_probe() - register a composite driver
+ * @driver: the driver to register
+ *
+ * Context: single threaded during gadget setup
+ *
+ * This function is used to register drivers using the composite driver
+ * framework.  The return value is zero, or a negative errno value.
+ * Those values normally come from the driver's @bind method, which does
+ * all the work of setting up the driver to match the hardware.
+ *
+ * On successful return, the gadget is ready to respond to requests from
+ * the host, unless one of its components invokes usb_gadget_disconnect()
+ * while it was binding.  That would usually be done in order to wait for
+ * some userspace participation.
+ */
+int usb_composite_probe(struct usb_composite_driver *driver)
+{
+	struct usb_gadget_driver *gadget_driver;
+
+	if (!driver || !driver->dev || !driver->bind)
+		return -EINVAL;
+
+	if (!driver->name)
+		driver->name = "composite";
+
+	driver->gadget_driver = composite_driver_template;
+	gadget_driver = &driver->gadget_driver;
+
+	gadget_driver->function =  (char *) driver->name;
+	gadget_driver->driver.name = driver->name;
+	gadget_driver->max_speed = driver->max_speed;
+
+	return usb_gadget_probe_driver(gadget_driver);
+}
+EXPORT_SYMBOL_GPL(usb_composite_probe);
+
+/**
+ * usb_composite_unregister() - unregister a composite driver
+ * @driver: the driver to unregister
+ *
+ * This function is used to unregister drivers using the composite
+ * driver framework.
+ */
+void usb_composite_unregister(struct usb_composite_driver *driver)
+{
+	usb_gadget_unregister_driver(&driver->gadget_driver);
+}
+EXPORT_SYMBOL_GPL(usb_composite_unregister);
+
+/**
+ * usb_composite_setup_continue() - Continue with the control transfer
+ * @cdev: the composite device who's control transfer was kept waiting
+ *
+ * This function must be called by the USB function driver to continue
+ * with the control transfer's data/status stage in case it had requested to
+ * delay the data/status stages. A USB function's setup handler (e.g. set_alt())
+ * can request the composite framework to delay the setup request's data/status
+ * stages by returning USB_GADGET_DELAYED_STATUS.
+ */
+void usb_composite_setup_continue(struct usb_composite_dev *cdev)
+{
+	int			value;
+	struct usb_request	*req = cdev->req;
+	unsigned long		flags;
+
+	DBG(cdev, "%s\n", __func__);
+	spin_lock_irqsave(&cdev->lock, flags);
+
+	if (cdev->delayed_status == 0) {
+		WARN(cdev, "%s: Unexpected call\n", __func__);
+
+	} else if (--cdev->delayed_status == 0) {
+		DBG(cdev, "%s: Completing delayed status\n", __func__);
+		req->length = 0;
+		req->context = cdev;
+		value = composite_ep0_queue(cdev, req, GFP_ATOMIC);
+		if (value < 0) {
+			DBG(cdev, "ep_queue --> %d\n", value);
+			req->status = 0;
+			composite_setup_complete(cdev->gadget->ep0, req);
+		}
+	}
+
+	spin_unlock_irqrestore(&cdev->lock, flags);
+}
+EXPORT_SYMBOL_GPL(usb_composite_setup_continue);
+
+static char *composite_default_mfr(struct usb_gadget *gadget)
+{
+	return kasprintf(GFP_KERNEL, "%s %s with %s", init_utsname()->sysname,
+			 init_utsname()->release, gadget->name);
+}
+
+void usb_composite_overwrite_options(struct usb_composite_dev *cdev,
+		struct usb_composite_overwrite *covr)
+{
+	struct usb_device_descriptor	*desc = &cdev->desc;
+	struct usb_gadget_strings	*gstr = cdev->driver->strings[0];
+	struct usb_string		*dev_str = gstr->strings;
+
+	if (covr->idVendor)
+		desc->idVendor = cpu_to_le16(covr->idVendor);
+
+	if (covr->idProduct)
+		desc->idProduct = cpu_to_le16(covr->idProduct);
+
+	if (covr->bcdDevice)
+		desc->bcdDevice = cpu_to_le16(covr->bcdDevice);
+
+	if (covr->serial_number) {
+		desc->iSerialNumber = dev_str[USB_GADGET_SERIAL_IDX].id;
+		dev_str[USB_GADGET_SERIAL_IDX].s = covr->serial_number;
+	}
+	if (covr->manufacturer) {
+		desc->iManufacturer = dev_str[USB_GADGET_MANUFACTURER_IDX].id;
+		dev_str[USB_GADGET_MANUFACTURER_IDX].s = covr->manufacturer;
+
+	} else if (!strlen(dev_str[USB_GADGET_MANUFACTURER_IDX].s)) {
+		desc->iManufacturer = dev_str[USB_GADGET_MANUFACTURER_IDX].id;
+		cdev->def_manufacturer = composite_default_mfr(cdev->gadget);
+		dev_str[USB_GADGET_MANUFACTURER_IDX].s = cdev->def_manufacturer;
+	}
+
+	if (covr->product) {
+		desc->iProduct = dev_str[USB_GADGET_PRODUCT_IDX].id;
+		dev_str[USB_GADGET_PRODUCT_IDX].s = covr->product;
+	}
+}
+EXPORT_SYMBOL_GPL(usb_composite_overwrite_options);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Brownell");
diff --git a/drivers/diebold/linux-dbdusb/dbdmsg.c b/drivers/diebold/linux-dbdusb/dbdmsg.c
new file mode 100755
index 000000000..5bfc5abfd
--- /dev/null
+++ b/drivers/diebold/linux-dbdusb/dbdmsg.c
@@ -0,0 +1,979 @@
+//#include <ansi_c.h>
+/*************************************************************************
+*******************  Copyright (c) Diebold, 1998,99,00  ******************
+*******************          All Rights Reserved        ******************
+**
+**   This software contains proprietary, trade secret information
+**   and is the property of Diebold.  This software and the
+**   information contained therein may not be disclosed, used or
+**   copied in whole or in part without the express, prior, written
+**   consent of Diebold.
+**
+**
+** Module Name:  Msgpackage.c
+**
+** Description:
+**   This module contains methods to encode messages into packets 
+**   for transmission and methods to decode messages received.  
+**   This same module functions on both the TP and the target module 
+**   
+**   Usage:
+**   For encoding:
+**    Declare in client module: Protocol_s BulkOut;  uint8_t pktbuf[64];
+**    
+**    call LLEncodeProtocolInit(pktbuf, 64, &BulkOut);
+**    Prior to each new msg to send invoke: 
+**    LLEncodeReset(msgbuf, msglen, &BulkOut);
+**    where msgbuf and msglen refer to the msg to be sent now
+**    If there is no message to send, msgbuf should be null and msglen  = 0.  
+**    rc = LLEncode(&BulkOut);
+**    if rc = kRCEncodeOk, send the packet, and continue LLEncode(&BulkOut)
+**    if rc = kRCMsgComplete, the msg has been sent
+
+**    For Decoding:
+**    Declare in client Module: Protocol_s BulkIn;
+**    uint8_t pktbuf[64];
+**    uint8_t msgbuf[10000];
+**    call LLDecodeProtocolInit(msgbuf, 10000, pktbuf, 64, &BulkIn);
+**    Client can use this to reset the current decode sequence
+**    invoke LLDecodeReset(&BulkIn);
+**    As each msg packet is received copy it into the pktbuf and invoke
+**    uint32_t inMsgLen;
+**    rc = LLDecode(&BulkIn, & inMsgLen);
+**    if rc = kRCMsgNoData, this is a 0 length msg, the msg is complete,
+**    but do not route the msg
+**    if rc = kRCDecodeOk, this is a valid msg and reconstruction is continuing
+**    if rc = kRCMsgComplete, the msg is reconstructed, route it.
+**    
+**    
+**
+** VCS Archive Data:
+**     $Archive:   V:/VCS/DATABASE/ColoradoModuleCommonFirmware.vdb/msgpackage.cv_  $
+**    $Revision:   1.3  $
+**        $Date:   Oct 22 2003 10:11:06  $
+**
+**************************************************************************/
+
+#define __DBD_MSGPACKAGE_C
+
+
+/****************************************************************************/
+/* HEADER files                                                             */
+/****************************************************************************/
+
+#include <linux/slab.h>
+
+// #include <string.h>
+#include "dbdmsg.h"
+// #include "asrt.h"
+#define ASRT(f)       {}
+#define ASRT_DATA(f,s)  {}
+#define DASRT(f,p)     {}
+#define DASRT_DATA(f,s,p)  {}
+#define DASRT_CLEAR()  {}
+#define ASRT_FILENAME
+
+ASRT_FILENAME;
+
+
+//const uint8_t kPkgHdrData = 'B';	// Header and data packet
+const uint8_t kPkgCommand = 'C';	// command only packet
+const uint8_t kPkgData = 'D';		// data packet
+
+/****************************************************************************/
+/* STATIC prototypes methods                                                */
+/****************************************************************************/
+static uint32_t calcMsgLenFromProtocolMsgLen(uint32_t prLen, MsgPackage_s * hdl);
+static uint32_t calcProtocolMsgLenFromMsgLen(uint32_t msgLen, MsgPackage_s *encHdl);
+
+
+/****************************************************************************/
+/* PUBLIC methods                                                           */
+/****************************************************************************/
+/*****************************************************************************
+** NAME: LLEncodeStatus
+**
+** DESCRIPTION:  
+**   Decodes the internal state into either ready, error or busy.
+**   Note, these are not thread safe calls since a call to LLEncode
+**   does not protect State changes. 
+**  
+** RETURN:
+**    rc
+*****************************************************************************/
+uint32_t LLEncodeStatus(MsgPackage_s * enc)
+{
+   uint32_t rc;
+   switch (enc->State)
+   {
+      case kPkgStateMsgComplete:
+         rc = kRCPkgReady;
+      break;
+      case kPkgStateError:
+         rc = kRCPkgError;
+      break;
+      default:
+         rc = kRCPkgBusy;
+      break;
+   }
+   return(rc);
+   
+}
+/*****************************************************************************
+** NAME: LLDecodeStatus
+**
+** DESCRIPTION:  
+**   Decodes the internal state into either ready, error or busy.
+**   Note, these are not thread safe calls since a call to LLDecode
+**   does not protect State changes. 
+** RETURN:
+**    rc
+*****************************************************************************/
+uint32_t LLDecodeStatus(MsgPackage_s * dcd)
+{
+   uint32_t rc;
+   switch (dcd->State)
+   {
+      case kPkgStateMsgCommand:
+         rc = kRCPkgReady;
+      break;
+      case kPkgStateError:
+         rc = kRCPkgError;
+      break;
+      default:
+         rc = kRCPkgBusy;
+      break;
+   }
+   return(rc);
+   
+}
+/*****************************************************************************
+** NAME: LLEncodePkgInit
+**
+** DESCRIPTION:  
+**  Invoked by client to initialize the encoding package.  
+**  The PktBuf memory sections are owned by the client
+**  as is the MsgPackage_s. 
+**  
+** RETURN:
+**    none
+*****************************************************************************/
+void LLEncodePkgInit(uint8_t *pPktBuf,   // in: pointer to packeting buffer
+                          uint32_t PktLen,    // in: absolute length of each packet
+                          MsgPackage_s * encHdl // modify: encoding instance handle
+                          )
+{
+	// clear all structure menbers
+	memset(encHdl,0,sizeof(encHdl));
+	// save the packet poiniter
+	encHdl->pPktBuf = pPktBuf;
+	// save the packet length
+	encHdl->PktLen = PktLen;
+	// set the state
+	encHdl->State = kPkgStateMsgComplete;
+}
+
+/*****************************************************************************
+** NAME: LLDecodePkgInit
+**
+** DESCRIPTION:  
+**  Invoked by client to initialize the decoding package.  
+**  The MsgBuf and PktBuf memory sections are owned by the client
+**  as is the MsgPackage_s. 
+**  
+** RETURN:
+**    none
+*****************************************************************************/
+void LLDecodePkgInit(uint8_t *pMsgBuf,			// in: ptr to msg buffer to accumulate msg in
+                          uint32_t MsgBufLen,	// in: size of the msg buffer 
+                          uint8_t *pPktBuf,		// in: pointer to packeting buffer
+                          uint32_t PktLen,		// in: absolute length of each packet
+                          MsgPackage_s * dcdHdl // modify: encoding instance handle
+                          )
+{
+	// clear all structure menbers
+	memset(dcdHdl,0,sizeof(dcdHdl));
+
+	// save the message buffer pointer and length
+	dcdHdl->pMsgBuf = pMsgBuf;		// for unlimited buffer sizes, set to NULL
+	dcdHdl->MsgBufLen = MsgBufLen;	// and set the size to 0
+
+	// save the packet bugger pointer and its length
+	dcdHdl->pPktBuf = pPktBuf;
+	dcdHdl->PktLen = PktLen;
+	// set the default state
+	dcdHdl->State = kPkgStateMsgCommand;
+}
+
+
+/*****************************************************************************
+** NAME: LLDecodeReset
+**
+** DESCRIPTION:  
+**  Method is called by the client to reset our state
+**  to the default of waiting on a command
+**  
+** RETURN:
+**    none
+*****************************************************************************/
+void LLDecodeReset(MsgPackage_s *dcdHdl) // in: decoding instance handle
+{
+	// set the default state
+	dcdHdl->State = kPkgStateMsgCommand;
+
+	// Don't need to reset msgbytesprocessed, it is reset when a 'C' pkt
+	// is received.
+
+	// if message buffer is dynamically allocated
+	if (! dcdHdl->MsgBufLen)	// no static User Message Buffer
+		{
+		if ( dcdHdl->pMsgBuf )	// and a message buffer exists?
+			{
+			kfree(dcdHdl->pMsgBuf);	// free this discarded message
+			dcdHdl->pMsgBuf = NULL;	// null out the pointer
+			}
+		}
+}
+
+
+/*****************************************************************************
+** NAME: LLDecode
+**
+** DESCRIPTION:  
+**  Method used by the client to decode a msg using this protocol.  
+**  Client continues to call this method until the entire msg is
+**  decoded.  The msg is reconstructed in this method. 
+**  
+** RETURN:
+**   kRCNoMsgData:		0 length msg found, do not route, msg complete
+**   kRCDecodeOk:		still decoding a msg, call with next pkt recvd,
+**   kRCMsgComplete:	Entire msg decoded, client should route
+**   kRCMsgBufOverrun:	incoming msg was larger than static message buffer
+*****************************************************************************/
+uint32_t LLDecode(MsgPackage_s * dcdHdl,  // in: instance ptr
+                  uint32_t * msglen     // out: msg length decoded thus far
+                  )
+{
+   uint32_t rc = kRCPkgError;
+   uint32_t pktBytesToCopy;  // # of bytes to copy from this packet (up to pkt length - 1)
+   uint8_t *copyTo;          // used for copying the packet data into the msg buffer
+   bool contStateProcessing = false; // var to control looping back to process another state.
+   
+   PDSTD_PACKET pPacket = (PDSTD_PACKET)dcdHdl->pPktBuf;
+
+   do
+   {
+      contStateProcessing = false;
+      switch (dcdHdl->State)
+      {
+         case kPkgStateMsgCommand:
+         {
+            // No msg length decoded yet, just header packet
+            *msglen = 0;
+            
+            // Expecting a 'C' in the message
+            if (pPacket->PacketType == kPkgCommand)
+            {
+				if (pPacket->U.CmdPacket.protocolVersion != MPKG_VERSION)
+				{
+				 dcdHdl->VersionError++;
+				 dcdHdl->State = kPkgStateError;
+				 rc = kRCPkgError;
+				}
+				else
+				{
+					// Decode Command Packet
+					// Reset the # of bytes processed
+				   dcdHdl->MsgBytesProcessed = 0;
+				   //
+				   // Protocol msglen into actual msg length, this is used to track
+				   // when we are finished and how many bytes are valid to the client
+				   //
+				   dcdHdl->MsgLen = calcMsgLenFromProtocolMsgLen(pPacket->U.CmdPacket.encodedMsgLen, dcdHdl); 
+#ifdef DBD_DEBUG
+                   printf("New Message Length %4d bytes... ", dcdHdl->MsgLen);
+#endif
+				   if (dcdHdl->MsgLen != 0)
+				   {
+					  dcdHdl->State = kPkgStateMsgInProgress;
+					  // Do I need to allocate a message buffer?
+					  if (!dcdHdl->MsgBufLen)
+					  {
+						  // there shouldn't be a buffer, but if there is free it
+						 if (dcdHdl->pMsgBuf)
+						 {
+							 kfree (dcdHdl->pMsgBuf);
+							 dcdHdl->pMsgBuf = NULL;
+						 }
+
+						 // malloc a new message buffer
+						 dcdHdl->pMsgBuf = (uint8_t *)kmalloc(dcdHdl->MsgLen+1, GFP_ATOMIC);
+						 if (dcdHdl->pMsgBuf)
+							{
+							rc = kRCDecodeOk;
+							}
+						 else
+							{
+							 dcdHdl->MsgMallocError++;
+							 dcdHdl->State = kPkgStateError;
+							 rc = kRCPkgError;
+							}
+					  }
+					  else
+					  // Will this msg fit in our buffer space?
+					  if (dcdHdl->MsgLen <= dcdHdl->MsgBufLen)
+					  {
+						 rc = kRCDecodeOk;
+					  }
+					  else
+					  {
+						 dcdHdl->MsgBufOverrun++;
+						 dcdHdl->State = kPkgStateError;
+						 rc = kRCPkgError;
+					  }
+				   }
+				   else
+				   {
+					  // 0 length msg, no data to consume or send to client
+					  dcdHdl->State = kPkgStateMsgCommand;
+					  rc = kRCNoMsgData;
+				   }
+				}              
+            }
+            else if (pPacket->PacketType == kPkgData)
+            {
+               // No state change here, just increment the # of times we 
+               // got a data pkt out of sequence
+               dcdHdl->DataSeqError++;
+               dcdHdl->State = kPkgStateError;
+               rc = kRCPkgError;
+			   // Do I need to free the message buffer?
+			   if (!dcdHdl->MsgBufLen && dcdHdl->pMsgBuf)
+			   {
+				   kfree (dcdHdl->pMsgBuf);
+				   dcdHdl->pMsgBuf = NULL;
+			   }
+            }
+            else
+            {
+               // Really bad error, the first byte is something unrecognizable
+               dcdHdl->HdrError++;
+               dcdHdl->State = kPkgStateError;
+               rc = kRCPkgError;
+			   // Do I need to free the message buffer?
+			   if (!dcdHdl->MsgBufLen && dcdHdl->pMsgBuf) {
+				   kfree (dcdHdl->pMsgBuf);
+				   dcdHdl->pMsgBuf = NULL;
+			   }
+            }
+         }
+         break;
+         
+         
+         case kPkgStateMsgInProgress:
+            // Expecting 'D' in the message
+            if (pPacket->PacketType == kPkgData)
+            {
+               // Decode 'D' Packet
+               // copy data remaining data from packet into msg buffer
+               pktBytesToCopy = dcdHdl->MsgLen - dcdHdl->MsgBytesProcessed;
+               
+               // must have some data or this is pkt is useless
+               ASRT(pktBytesToCopy != 0);
+
+               if (pktBytesToCopy > (dcdHdl->PktLen - kPkgDataPktHdrLen))
+               {
+                 pktBytesToCopy = ((dcdHdl->PktLen - kPkgDataPktHdrLen));
+               }
+
+               copyTo = &dcdHdl->pMsgBuf[dcdHdl->MsgBytesProcessed] ;
+               
+               memcpy(copyTo, pPacket->U.DataPacket.MsgData, pktBytesToCopy);
+               
+               dcdHdl->MsgBytesProcessed += pktBytesToCopy;
+
+               if (dcdHdl->MsgBytesProcessed == dcdHdl->MsgLen)
+               {
+                  dcdHdl->State = kPkgStateMsgCommand;
+                  rc = kRCClientMsgComplete;
+               }
+               else
+               {
+                  rc = kRCDecodeOk;
+               }
+            }
+            else if (pPacket->PacketType == kPkgCommand)
+            {
+               //
+               // Got a cmd pkt, expecting a data pkt.  
+               // This is a valid command pkt, set state to process it and loop back
+               // and get back in sync.  
+               //
+               dcdHdl->CmdSeqError++;
+               dcdHdl->State = kPkgStateMsgCommand;
+               contStateProcessing = true;
+			   // Do I need to free the message buffer?
+			   if (!dcdHdl->MsgBufLen && dcdHdl->pMsgBuf)
+			   {
+				   kfree (dcdHdl->pMsgBuf);
+				   dcdHdl->pMsgBuf = NULL;
+			   }
+            }
+            else 
+            {
+               dcdHdl->HdrError++;
+               dcdHdl->State = kPkgStateError;
+               rc = kRCPkgError;
+			   // Do I need to free the message buffer?
+			   if (!dcdHdl->MsgBufLen && dcdHdl->pMsgBuf)
+			   {
+				   kfree (dcdHdl->pMsgBuf);
+				   dcdHdl->pMsgBuf = NULL;
+			   }
+            }
+         break;
+         
+         case kPkgStateError:
+         {
+            //
+            // buf > len, 'D' exp 'C'  or 'C' exp 'D'
+            // Regardless, this state just continues until we find the next 'C' and then
+            // we process that command from the kPrStateMsgCmd.
+            // This way we only increment the error counts once for each initial stimulus
+            //
+            if (pPacket->PacketType == kPkgCommand)
+            {
+               // Ok we can get out of this state, process this command packet
+               dcdHdl->State = kPkgStateMsgCommand;
+               contStateProcessing = true;
+            }
+            else
+            {
+              // Stay in error state until command found,
+              // no bytes processed, still in error state. 
+              dcdHdl->MsgBytesProcessed = 0;
+              rc = kRCPkgError;
+            }
+         }
+         break;
+
+         default:
+            ASRT(false);
+            
+         break;
+      }
+   } while (contStateProcessing);
+
+   // update the msg length processed so far
+   *msglen = dcdHdl->MsgBytesProcessed;
+   
+   return(rc);
+   
+}
+
+/*****************************************************************************
+** NAME: LLDecodeGetRequestBytes
+**
+** DESCRIPTION:  
+**   Returns the total # of bytes to request to complete the current msg
+**   The # returned is the actual # of bytes to request including protocol
+**   0 pad bytes, etc.   
+** 
+** RETURN:
+**    none
+*****************************************************************************/
+uint32_t LLDecodeGetRequestBytes(MsgPackage_s *dcdHdl)
+{
+   uint32_t msgBytes = dcdHdl->MsgLen - dcdHdl->MsgBytesProcessed;
+   uint32_t packets;
+   
+   if (dcdHdl->State != kPkgStateMsgInProgress)
+   {
+      // if we aren't receiving a msg, then there is nothing left to request
+      return(0);
+   }
+   if (msgBytes == 0)
+   {
+      return(0);
+   }
+   packets = (msgBytes / (dcdHdl->PktLen - kPkgDataPktHdrLen) );
+
+   if ((msgBytes % (dcdHdl->PktLen - kPkgDataPktHdrLen) ) != 0)
+      packets++;
+
+   return(packets * dcdHdl->PktLen);
+   
+}
+/*****************************************************************************
+** NAME: LLEncodeReset
+**
+** DESCRIPTION:  
+**   Invoked by client when there is a new message to encode.
+**   If the msgbuf is NULL and MsgLen is 0, a 'C' message with no 
+**   data is encoded as a 'nothing to transmit' indicator. 
+**   
+** RETURN:
+**    none
+*****************************************************************************/
+void LLEncodeReset(uint8_t *pMsgBuf, // in: Msg buffer to encode
+                   uint32_t MsgLen,   // in: Msg length in bytes
+                   MsgPackage_s *encHdl // in: the encoding instance handle
+                   )
+{
+   ASRT(MsgLen != 0 && pMsgBuf != NULL);
+   encHdl->MsgBytesProcessed = 0;
+   encHdl->State = kPkgStateMsgIdle;
+   encHdl->pMsgBuf = pMsgBuf;
+   encHdl->MsgLen = MsgLen;
+}
+
+
+/*****************************************************************************
+** NAME: LLEncode
+**
+** DESCRIPTION:  
+**   Client method to encode a msg for transmission.  Client
+**   continues calling this method until msg complete status is returned. 
+**   
+** RETURN:
+**    kRCEncodeOk: Packet has been encoded, client should send it
+**    kRCMsgComplete:  Entire sent and received, Client can eliminate msg
+*****************************************************************************/
+uint32_t LLEncode(MsgPackage_s *encHdl // in: the encoding instance handle
+                 )
+{
+   uint32_t rc = kRCPkgError;
+   uint32_t pktBytesToCopy;
+   uint8_t *pPktBuf = encHdl->pPktBuf;
+   //uint8_t *pMsgBuf = encHdl->pMsgBuf;
+   uint8_t *copyFrom;
+   bool contStateProcessing;
+   bool firstDataPacket = false;  // boolean indicating if this is the first Datapacket encoding
+                                    // used to indicate that the bytes processed should not be updated
+                                    // on the fall through from Command state to MsgInProgress state.
+                                    // Just a way to reuse the MsgInProgress state. 
+   PDSTD_PACKET pPacket = (PDSTD_PACKET)encHdl->pPktBuf;
+
+   do
+   {
+      contStateProcessing = false;
+      switch (encHdl->State)
+      {
+         case kPkgStateMsgIdle:
+         {
+            //
+            // Encode the Command packet
+            // Clear the packet initially, it is not required to clear the entire packet, but 
+            // this will make debug and line trace analysis easier since we'll always send a mostly
+            // 0 packet at the beginning of a message
+            //
+            memset(pPktBuf, 0, encHdl->PktLen);
+
+            // Add the command mnemonic, version ID and msg length
+            pPacket->PacketType = kPkgCommand;
+			pPacket->U.CmdPacket.protocolVersion = MPKG_VERSION;
+
+			// put the size of the encoded message into the packet
+            pPacket->U.CmdPacket.encodedMsgLen = calcProtocolMsgLenFromMsgLen(encHdl->MsgLen, encHdl);
+
+            encHdl->State = kPkgStateMsgCommand;
+            rc = kRCEncodeOk;
+         }
+            break;
+            
+         case kPkgStateMsgCommand:
+         {
+            // Formatted the command packet 
+            if (encHdl->MsgLen == 0)	// if the message length is 0, we're done.
+            {
+               encHdl->State = kPkgStateMsgComplete;
+               rc = kRCClientMsgComplete;
+            }
+            else	// encode first data pkt
+            {
+               // Encode data packet, only update bytes processed after first packet so that
+               // we know how many bytes have been actually sent
+               firstDataPacket = true;
+               encHdl->State = kPkgStateMsgInProgress;
+               contStateProcessing = true;
+            }          
+         }
+            break;
+         
+         case kPkgStateMsgInProgress:
+         {
+            // BytesProcessed reflects the actual bytes sent.  Therefore do not
+            // update it on the firstdatapacket
+            if (firstDataPacket == false)
+            {
+               //
+               // Update bytes processed since last pkt was sent
+               // Always inc by entire pkt size even if we actually sent less bytes
+               // as part of the last pkt.  End condition is MsgBytesProc >= Msglen
+               // so a '>' condition is ok.  
+               //
+               encHdl->MsgBytesProcessed += (encHdl->PktLen - kPkgDataPktHdrLen) ;
+// LDH               encHdl->MsgBytesProcessed += sizeof(pPacket->U.DataPacket.MsgData);
+            }
+            if (encHdl->MsgBytesProcessed >= encHdl->MsgLen)
+            {
+               // Done with this message
+               encHdl->State = kPkgStateMsgComplete;
+               rc = kRCClientMsgComplete;
+            }
+            else
+            {
+               // More data to encode
+               pPacket->PacketType = kPkgData;
+               pktBytesToCopy = encHdl->MsgLen - encHdl->MsgBytesProcessed;
+               
+               // must have some data or this pkt is useless
+               ASRT(pktBytesToCopy != 0);
+
+               if (pktBytesToCopy > (encHdl->PktLen - kPkgDataPktHdrLen) )
+               {
+                 // Copying a full pkt
+                 pktBytesToCopy = (encHdl->PktLen - kPkgDataPktHdrLen);
+               }
+               else
+               {
+                  // Copying a partial pkt, 0 pad any bytes left in the packet
+                  memset(&pPacket->U.DataPacket.MsgData[pktBytesToCopy], 0,
+					  (encHdl->PktLen - kPkgDataPktHdrLen)-pktBytesToCopy);
+               }
+               copyFrom = &encHdl->pMsgBuf[encHdl->MsgBytesProcessed] ;
+               memcpy(pPacket->U.DataPacket.MsgData, copyFrom, pktBytesToCopy);
+               
+               rc = kRCEncodeOk;
+            }
+         }
+            break;
+            
+         case kPkgStateMsgComplete:
+         {
+            // If encoding here, then no msg to send, 
+            // protocol says we must send a Command packet with 0 length.
+            memset(pPktBuf, 0, encHdl->PktLen);
+            // Add the command mnemonic and msg length
+            pPacket->PacketType = kPkgCommand;
+			pPacket->U.CmdPacket.protocolVersion = MPKG_VERSION;
+			encHdl->State = kPkgStateNullCommand;
+            rc = kRCEncodeOk;
+         }
+            break;
+            
+         case kPkgStateNullCommand:
+         {
+            // Null command successful
+            encHdl->State = kPkgStateMsgComplete;
+            rc = kRCPkgMsgComplete;
+         }
+            break;
+
+         case kPkgStateError:
+         {
+            rc = kRCPkgError;
+         }
+            break;
+         
+         default:
+            ASRT(false);
+            break;
+      }
+   } while (contStateProcessing == true);
+   
+   return(rc);
+}
+
+
+void LLGetErrorCounters(MsgPackage_s *hdl, uint32_t *cmdSeqError, uint32_t *dataSeqError, 
+                                      uint32_t *hdrError, uint32_t *msgBufOverrun)
+{
+  *cmdSeqError = hdl->CmdSeqError;
+  *dataSeqError = hdl->DataSeqError;
+  *hdrError = hdl->HdrError;
+  *msgBufOverrun = hdl->MsgBufOverrun;
+  
+}
+
+/****************************************************************************/
+/* STATIC methods                                                        */
+/****************************************************************************/
+
+/*****************************************************************************
+** NAME: calcMsgLenFromProtocolMsgLen
+**
+** DESCRIPTION:  
+**  Translates the protocol msg length (with hdr info) 
+**  into a total length of bytes of just msg data. 
+**  
+** RETURN:
+**   Msg data length in bytes. 
+*****************************************************************************/
+static uint32_t calcMsgLenFromProtocolMsgLen(uint32_t prLen, MsgPackage_s * dcdHdl)
+{
+	uint32_t msglen = 0;
+	uint32_t remPktBytes;
+	if ( prLen )
+		{
+		 // # of full packets * msg bytes/packet + msg bytes in last pkt 
+		 msglen =  (prLen / dcdHdl->PktLen) * (dcdHdl->PktLen-kPkgDataPktHdrLen);
+ 
+		 // Now add bytes left in last packet, if there is one
+		 remPktBytes = prLen % dcdHdl->PktLen;
+		 if (remPktBytes != 0)
+			{
+			// Add remaining bytes in last packet, minus the hdr length in last packet. 
+			msglen += remPktBytes - kPkgDataPktHdrLen;  
+			}
+		}
+	return(msglen);
+}
+
+
+/*****************************************************************************
+** NAME: calcProtocolMsgLenFromMsgLen
+**
+** DESCRIPTION:  
+**  Translates the msg length (without hdr info) 
+**  into a total protocol msg length with hdr info 
+**  
+** RETURN:
+**   Msg data length in bytes. 
+*****************************************************************************/
+static uint32_t calcProtocolMsgLenFromMsgLen(uint32_t msgLen, MsgPackage_s *encHdl)
+{
+	uint32_t prLen = msgLen + (msgLen / (encHdl->PktLen-kPkgDataPktHdrLen)) * kPkgDataPktHdrLen;
+
+	if ((msgLen % (encHdl->PktLen-kPkgDataPktHdrLen)) != 0)
+		{
+		prLen += kPkgDataPktHdrLen;
+		}
+	return(prLen);
+}
+
+//#define PACKAGETEST
+#ifdef PACKAGETEST
+void confirmMsg(uint8_t * msgbuf, uint8_t * outmsgbuf, uint32_t len)
+{
+  uint32_t idx;
+  for(idx = 0; idx < len; idx++)
+  {
+    ASRT(msgbuf[idx] == outmsgbuf[idx]);
+  }
+}
+
+void packageTest(void)
+{
+   uint8_t msgbuf[10000];
+   uint8_t outmsgbuf[10000];
+   uint8_t pktbuf[64];
+   int i;
+   MsgPackage_s enc, dcd;
+   uint32_t rc =   9999;
+   uint32_t outmsglen;
+   uint32_t cseqerr, dseqerr, hdrerr, buferr, temperr;
+   uint8_t testcount = 0;
+   uint16_t testlength = 1;
+
+   LLDecodePkgInit(outmsgbuf, 10000, pktbuf, 64, &dcd);
+   LLDecodeReset(&dcd);
+   LLEncodePkgInit(pktbuf, 64, &enc);
+   for (i = 0; i < 300; i++)
+   {
+      msgbuf[i] = i;
+   }
+   
+   ASRT(LLEncodeStatus(&enc) == kRCPkgReady);
+   ASRT(LLDecodeStatus(&dcd) == kRCPkgReady);
+   
+   memset(outmsgbuf, 0xaa, 10000); 
+   // verify std msg tx on 63 byte boundary (perfect packet length)
+   LLEncodeReset(msgbuf, 189, &enc);
+   do
+   {
+      rc = LLEncode(&enc);
+      ASRT(rc == kRCEncodeOk);
+      
+      rc = LLDecode(&dcd, &outmsglen);
+      ASRT(rc == kRCDecodeOk || rc == kRCClientMsgComplete); 
+   }
+   while (rc != kRCClientMsgComplete);
+   rc = LLEncode(&enc);
+   ASRT(rc == kRCClientMsgComplete);
+   
+   ASRT(outmsglen == 189);
+   confirmMsg(msgbuf, outmsgbuf, outmsglen);
+   memset(outmsgbuf, 0xaa, 10000);
+   
+   // verify std msg tx not on 63 byte boundary (partial packet)
+   LLEncodeReset(msgbuf, 9993, &enc);
+   do
+   {
+      rc = LLEncode(&enc);
+      ASRT(rc == kRCEncodeOk);
+      
+      rc = LLDecode(&dcd, &outmsglen);
+      ASRT(rc == kRCDecodeOk || rc == kRCClientMsgComplete); 
+   }
+   while (rc != kRCClientMsgComplete);
+   
+   rc = LLEncode(&enc);
+   ASRT(rc == kRCClientMsgComplete);
+   
+   ASRT(outmsglen == 9993);
+   confirmMsg(msgbuf, outmsgbuf, outmsglen);
+   memset(outmsgbuf, 0xaa, 10000);
+
+   // Verify 0 message transmission
+   rc = LLEncode(&enc);
+   ASRT(rc == kRCEncodeOk);
+   ASRT(LLEncodeStatus(&enc) == kRCPkgBusy);
+   rc = LLDecode(&dcd, &outmsglen);
+   ASRT(rc == kRCNoMsgData);
+   ASRT(outmsglen == 0);
+   rc = LLEncode(&enc);
+   ASRT(rc == kRCPkgMsgComplete);
+   ASRT(LLEncodeStatus(&enc) == kRCPkgReady);
+   memset(outmsgbuf, 0xaa, 10000);   
+   
+   // verify single packet tx
+   LLEncodeReset(msgbuf, 34, &enc);
+   //encode command
+   rc = LLEncode(&enc);
+   ASRT(rc == kRCEncodeOk);
+   
+   // dcd cmd
+   rc = LLDecode(&dcd, &outmsglen);
+   ASRT(rc == kRCDecodeOk);
+   ASRT(outmsglen == 0);
+   
+   // encode data
+   rc = LLEncode(&enc);
+   ASRT(rc == kRCEncodeOk);
+   ASRT(LLEncodeStatus(&enc) == kRCPkgBusy);
+   // decode data
+   rc = LLDecode(&dcd, &outmsglen);
+   ASRT(rc == kRCClientMsgComplete);
+   ASRT(outmsglen == 34);
+   
+   // call encode last time for msg complete
+   rc = LLEncode(&enc);
+   ASRT(rc == kRCClientMsgComplete);
+   ASRT(LLEncodeStatus(&enc) == kRCPkgReady);
+   confirmMsg(msgbuf, outmsgbuf, outmsglen);  
+   memset(outmsgbuf, 0xaa, 10000); 
+   
+
+// Test: every length message
+do 
+{
+   memset(outmsgbuf, 0xaa, 10000);
+   LLEncodeReset(msgbuf, testlength, &enc);
+   do
+   {
+      rc = LLEncode(&enc);
+      ASRT(rc == kRCEncodeOk);
+      
+      rc = LLDecode(&dcd, &outmsglen);
+      ASRT(rc == kRCDecodeOk || rc == kRCClientMsgComplete); 
+   }
+   while (rc != kRCClientMsgComplete);
+   
+   rc = LLEncode(&enc);
+   ASRT(rc == kRCClientMsgComplete);
+   
+   ASRT(outmsglen == testlength);
+   confirmMsg(msgbuf, outmsgbuf, outmsglen);
+
+   testlength++;
+}
+while (testlength <= 10000);
+
+
+// Test: got a "C" and expected a "D"
+   memset(msgbuf, 0xaa, 10000);
+
+   LLGetErrorCounters(&dcd, &temperr, &dseqerr, &hdrerr, &buferr);
+
+   LLEncodeReset(outmsgbuf, 800, &enc);  // 14 packets
+   testcount = 0;
+   do
+   {
+      rc = LLEncode(&enc);
+      ASRT(rc == kRCEncodeOk);
+      
+      rc = LLDecode(&dcd, &outmsglen);
+      ASRT(rc == kRCDecodeOk || rc == kRCClientMsgComplete); 
+   }
+   while (testcount++ < 6);
+   
+   // expecting a "D", start a new message
+   LLEncodeReset(msgbuf, 1952, &enc);
+   do
+   {
+      rc = LLEncode(&enc);
+      ASRT(rc == kRCEncodeOk);
+      
+      rc = LLDecode(&dcd, &outmsglen);
+      ASRT(rc == kRCDecodeOk || rc == kRCClientMsgComplete); 
+   }
+   while (rc != kRCClientMsgComplete);
+   
+   rc = LLEncode(&enc);
+   ASRT(rc == kRCClientMsgComplete);
+   
+   ASRT(outmsglen == 1952);
+   confirmMsg(msgbuf, outmsgbuf, outmsglen);
+
+   LLGetErrorCounters(&dcd, &cseqerr, &dseqerr, &hdrerr, &buferr);
+   ASRT(temperr + 1 == cseqerr);
+   // Test that a call to LLEncode at msg complete returns ok 
+   // starting a 0 length msg
+   rc = LLEncode(&enc);
+   ASRT(rc == kRCEncodeOk && LLEncodeStatus(&enc) == kRCPkgBusy);
+   rc = LLEncode(&enc);
+   ASRT(rc == kRCPkgMsgComplete && LLEncodeStatus(&enc) == kRCPkgReady);
+
+
+// Test: got a "D" and expected a "C"
+   memset(outmsgbuf, 0xaa, 10000);
+
+   LLEncodeReset(msgbuf, 600, &enc) ;
+   rc = LLEncode(&enc);
+   ASRT(rc == kRCEncodeOk);
+   //purposely do not call decode
+   
+   rc = LLEncode(&enc);
+   ASRT(rc == kRCEncodeOk);
+
+   LLGetErrorCounters(&dcd, &cseqerr, &temperr, &hdrerr, &buferr);
+
+   rc = LLDecode(&dcd, &outmsglen);
+   ASRT(rc == kRCPkgError);
+   ASRT(LLDecodeStatus(&dcd) == kRCPkgError);
+   
+   LLGetErrorCounters(&dcd, &cseqerr, &dseqerr, &hdrerr, &buferr);
+   ASRT(temperr + 1 == dseqerr);
+   // decode should remain in error state until next command found
+   rc = LLDecode(&dcd, &outmsglen);
+   ASRT(rc == kRCPkgError);
+   
+   // verify decode gets back in sync
+   LLEncodeReset(msgbuf, 500, &enc);
+   rc = LLEncode(&enc);
+   ASRT(rc == kRCEncodeOk);
+   
+   rc = LLDecode(&dcd, &outmsglen);
+   ASRT(rc = kRCDecodeOk && outmsglen == 0);
+   
+   
+   
+   
+   
+    
+   
+   
+}
+
+#endif
diff --git a/drivers/diebold/linux-dbdusb/dbdmsg.h b/drivers/diebold/linux-dbdusb/dbdmsg.h
new file mode 100755
index 000000000..7ce59d702
--- /dev/null
+++ b/drivers/diebold/linux-dbdusb/dbdmsg.h
@@ -0,0 +1,152 @@
+/*************************************************************************
+*******************  Copyright (c) Diebold, 1998,99,00  ******************
+*******************          All Rights Reserved        ******************
+**
+**   This software contains proprietary, trade secret information
+**   and is the property of Diebold.  This software and the
+**   information contained therein may not be disclosed, used or
+**   copied in whole or in part without the express, prior, written
+**   consent of Diebold.
+**
+**
+** Module Name: Msgpackage.h
+**   
+** Description:
+**
+** VCS Archive Data:
+**     $Archive:   V:/VCS/DATABASE/ColoradoModuleCommonFirmware.vdb/msgpackage.hv_  $
+**    $Revision:   1.2  $
+**        $Date:   Oct 22 2003 10:10:56  $
+**
+***************************************************************************/
+
+
+#ifndef __DBD_MSGPACKAGE_H
+#define __DBD_MSGPACKAGE_H
+
+/****************************************************************************/
+/* HEADER files                                                             */
+/****************************************************************************/
+#include <stdint-gcc.h>
+#include <stdbool.h>
+#include <string.h>
+
+// #include "types.h"
+// #include <INTEGRITY.h>
+
+//	Protocol version definition
+#define MPKG_VERSION	((uint8_t)0)
+
+typedef enum 
+{
+   kRCEncodeOk,         // Pkt encoded, client must send
+   kRCDecodeOk,         // Pkt decoded, client continue decoding
+   kRCNoMsgData,        // Nothing to do, message has 0 length
+   kRCClientMsgComplete,      // Finished processing this client message
+   kRCPkgMsgComplete,   // finished processing this Pkg msg (to do with the protocol, not the client)
+   kRCPkgBusy,          // Currently packing/unpacking a msg (status rc)
+   kRCPkgReady,         // Ready to handle another msg (status rc)
+   kRCPkgError         // Detected protocol error, msg overrun (status rc)
+                        // invalid pkt sequence or invalid pkt header 
+} MsgPackageRC_e;
+
+typedef enum 
+{
+   // Note for decoding, the 'idle' state is msg complete.  This is so that we don't have
+   // multiple checks in asserts for the state validity of MsgComplete OR Idle that can
+   // happen on the initial method calls before the first msg is actually processed.
+   // It also makes the state chart more intuitive for decoding. 
+   
+   kPkgStateMsgIdle,         // Idle state
+   kPkgStateMsgCommand,      // New msg, processing Command packet
+   kPkgStateNullCommand,     // no data to send command poll state
+   kPkgStateMsgInProgress,   // Continuing msg, processing data packets
+   kPkgStateMsgComplete,     // Last data packet processed,
+   kPkgStateError           // Detected some sort of protocol error 
+} MsgPackageState_e;
+
+
+typedef struct
+{
+   uint8_t * pMsgBuf;			// Reference to the actual msg buffer
+   uint32_t MsgBufLen;			// Maximum length of the msg buffer
+								// LDH + if this is 0 then messages are allocated!
+   uint32_t MsgLen;				// Length of active msg
+   uint8_t *pPktBuf;			// Packet for encoding/decoding
+   uint32_t PktLen;				// Length of the packet buffer and the encode/decode packet length
+   uint32_t MsgBytesProcessed;  // # of msg bytes that have been processed
+                                // this is the actual msg data length, not the
+                                // protocol level data length!
+   MsgPackageState_e State;		// Allows protocol to manage its encode/decode operations
+   uint32_t CmdSeqError;		// Received a 'D' when expecting a 'C'
+   uint32_t DataSeqError;		// Received a 'C' when expecting a 'D'
+   uint32_t HdrError;			// Received hdr with unrecognizable first byte
+   uint32_t MsgBufOverrun;		// Msg won't fit in given length
+   uint32_t MsgMallocError;		// LDH + couldn't allocate a buffer for the message
+   uint32_t VersionError;		// LDH + Received hdr with the wrong version byte
+   
+}  MsgPackage_s;
+
+
+#define kPkgCmdMinPktDataLen  (56)
+#define kPkgDataMinPktDataLen (63)
+
+#pragma pack(1)
+
+// definition of a command packet
+typedef struct _DSTD_PACKET_CMD
+{
+   uint8_t protocolVersion;				// one byte value 0 - 255
+   uint8_t reserved[2];					// two unused bytes
+   uint32_t encodedMsgLen;				// Length of data
+   uint8_t MsgData[kPkgCmdMinPktDataLen];	// encoded data - variable length, minimum defined here
+}  DSTD_PACKET_CMD, *PDSTD_PACKET_CMD;
+
+// definition of a data packet
+typedef struct _DSTD_PACKET_DATA
+{
+   uint8_t MsgData[kPkgDataMinPktDataLen];     // encoded data- variable length, minimum defined here
+}  DSTD_PACKET_DATA, *PDSTD_PACKET_DATA;
+
+
+// Union of all packet types
+typedef struct _DSTD_PACKET
+{
+	uint8_t PacketType;		// type of packet	'B', 'C' or 'D'
+	union
+	{
+	DSTD_PACKET_CMD CmdPacket;
+	DSTD_PACKET_DATA DataPacket;
+	} U;
+
+} DSTD_PACKET, *PDSTD_PACKET;
+
+#pragma pack()
+
+#define kPkgDataPktHdrLen 1
+
+  #ifdef __cplusplus
+    extern "C" 
+    {
+  #endif
+
+      // Public Methods
+      void LLEncodePkgInit(uint8_t * pPkt, uint32_t PktLen, MsgPackage_s * encHdl);
+      void LLEncodeReset(uint8_t * pMsgBuf, uint32_t MsgLen, MsgPackage_s * encHdl);
+      uint32_t LLEncodeStatus(MsgPackage_s * enc);  // 
+      uint32_t LLEncode(MsgPackage_s * encHdl);
+
+
+      void LLDecodePkgInit(uint8_t * pMsgBuf, uint32_t MsgLen, uint8_t * pPkt, uint32_t PktLen, MsgPackage_s * dcdHdl);
+      void LLDecodeReset(MsgPackage_s * dcdHdl);
+      uint32_t LLDecode(MsgPackage_s * dcdHdl, uint32_t *msglen);
+      uint32_t LLDecodeGetRequestBytes(MsgPackage_s * dcdHdl); 
+
+      void LLErrorGetCounters(MsgPackage_s *hdl, uint32_t *cmdSeqError, uint32_t *dataSeqError, 
+                                                 uint32_t *hdrError, uint32_t *msgBufOverrun);
+
+  #ifdef __cplusplus
+    }
+  #endif
+
+#endif
diff --git a/drivers/diebold/linux-dbdusb/dbdosi.c b/drivers/diebold/linux-dbdusb/dbdosi.c
new file mode 100755
index 000000000..9dd341d2a
--- /dev/null
+++ b/drivers/diebold/linux-dbdusb/dbdosi.c
@@ -0,0 +1,345 @@
+/*
+ * dbdosi.c -- Multifunction Composite driver
+ *
+ * Copyright (C) 2008 David Brownell
+ * Copyright (C) 2008 Nokia Corporation
+ * Copyright (C) 2009 Samsung Electronics
+ * Copyright (C) 2012 Diebold
+ * Author: Eric J. Klein (kleine@diebold.com)
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/list.h>
+
+#define DRIVER_DESC		"Diebold OSI Composite Gadget"
+#define DRIVER_VERSION	"2012/11/16"
+
+/*-------------------------------------------------------------------------*/
+
+#define OSIG_VENDOR_NUM		0x03f4	/* Diebold */
+#define OSIG_PRODUCT_NUM	0x1024	/* OSI */
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * kbuild is not very cooperative with respect to linking separately
+ * compiled library objects into one module.  So for now we won't use
+ * separate compilation ... ensuring init/exit sections work to shrink
+ * the runtime footprint, and giving us at least some parts of what
+ * a "gcc --combine ... part1.c part2.c part3.c ... " build would.
+ */
+
+#include "composite.c"
+#include "usbstring.c"
+#include "config.c"
+#include "epautoconf.c"
+
+#include "f_hid.c"
+#include "f_dbdusb.c"
+
+struct hidg_func_node {
+	struct list_head node;
+	struct hidg_func_descriptor *func;
+};
+
+static LIST_HEAD(hidg_func_list);
+
+/*-------------------------------------------------------------------------*/
+
+static struct usb_device_descriptor device_desc = {
+	.bLength =		sizeof device_desc,
+	.bDescriptorType =	USB_DT_DEVICE,
+
+	.bcdUSB =		cpu_to_le16(0x0200),
+
+	/* .bDeviceClass =		USB_CLASS_COMM, */
+	/* .bDeviceSubClass =	0, */
+	/* .bDeviceProtocol =	0, */
+	.bDeviceClass =		USB_CLASS_PER_INTERFACE,
+	.bDeviceSubClass =	0,
+	.bDeviceProtocol =	0,
+	/* .bMaxPacketSize0 = f(hardware) */
+
+	/* Vendor and product id can be overridden by module parameters.  */
+	.idVendor =		cpu_to_le16(OSIG_VENDOR_NUM),
+	.idProduct =		cpu_to_le16(OSIG_PRODUCT_NUM),
+	/* .bcdDevice = f(hardware) */
+	/* .iManufacturer = DYNAMIC */
+	/* .iProduct = DYNAMIC */
+	/* NO SERIAL NUMBER */
+	.bNumConfigurations =	1,
+};
+
+static struct usb_otg_descriptor otg_descriptor = {
+	.bLength =		sizeof otg_descriptor,
+	.bDescriptorType =	USB_DT_OTG,
+
+	/* REVISIT SRP-only hardware is possible, although
+	 * it would not be called "OTG" ...
+	 */
+	.bmAttributes =		USB_OTG_SRP | USB_OTG_HNP,
+};
+
+static const struct usb_descriptor_header *otg_desc[] = {
+	(struct usb_descriptor_header *) &otg_descriptor,
+	NULL,
+};
+
+
+/* string IDs are assigned dynamically */
+
+#define STRING_MANUFACTURER_IDX		0
+#define STRING_PRODUCT_IDX		1
+
+static char manufacturer[50];
+
+static struct usb_string strings_dev[] = {
+	[STRING_MANUFACTURER_IDX].s = manufacturer,
+	[STRING_PRODUCT_IDX].s = DRIVER_DESC,
+	{  } /* end of list */
+};
+
+static struct usb_gadget_strings stringtab_dev = {
+	.language	= 0x0409,	/* en-us */
+	.strings	= strings_dev,
+};
+
+static struct usb_gadget_strings *dev_strings[] = {
+	&stringtab_dev,
+	NULL,
+};
+
+
+
+/****************************** Configurations ******************************/
+
+static int __ref do_config(struct usb_configuration *c)
+{
+	struct hidg_func_node *e;
+	int func = 0, status = 0;
+
+	if (gadget_is_otg(c->cdev->gadget)) {
+		c->descriptors = otg_desc;
+		c->bmAttributes |= USB_CONFIG_ATT_WAKEUP;
+	}
+
+    dbdusb_bind_config(c);
+
+	list_for_each_entry(e, &hidg_func_list, node) {
+		status = hidg_bind_config(c, e->func, func++);
+		if (status)
+			break;
+	}
+
+	return status;
+}
+
+static struct usb_configuration config_driver = {
+	.label			= "DBDOSI Gadget",
+	.bConfigurationValue	= 1,
+	/* .iConfiguration = DYNAMIC */
+	.bmAttributes		= USB_CONFIG_ATT_SELFPOWER,
+};
+
+/****************************** Gadget Bind ******************************/
+
+static int __ref osi_bind(struct usb_composite_dev *cdev)
+{
+	struct usb_gadget *gadget = cdev->gadget;
+	struct list_head *tmp;
+	int status, gcnum, funcs = 0;
+
+	list_for_each(tmp, &hidg_func_list)
+		funcs++;
+
+	if (!funcs)
+		return -ENODEV;
+
+	/* set up HID */
+	status = ghid_setup(cdev->gadget, funcs);
+	if (status < 0)
+		return status;
+
+	gcnum = usb_gadget_controller_number(gadget);
+	if (gcnum >= 0)
+		device_desc.bcdDevice = cpu_to_le16(0x0300 | gcnum);
+	else
+		device_desc.bcdDevice = cpu_to_le16(0x0300 | 0x0099);
+
+
+	/* Allocate string descriptor numbers ... note that string
+	 * contents can be overridden by the composite_dev glue.
+	 */
+
+	/* device descriptor strings: manufacturer, product */
+	snprintf(manufacturer, sizeof manufacturer, "%s %s with %s",
+		init_utsname()->sysname, init_utsname()->release,
+		gadget->name);
+	status = usb_string_id(cdev);
+	if (status < 0)
+		return status;
+	strings_dev[STRING_MANUFACTURER_IDX].id = status;
+	device_desc.iManufacturer = status;
+
+	status = usb_string_id(cdev);
+	if (status < 0)
+		return status;
+	strings_dev[STRING_PRODUCT_IDX].id = status;
+	device_desc.iProduct = status;
+
+	/* register our configuration */
+	status = usb_add_config(cdev, &config_driver, do_config);
+	if (status < 0)
+		return status;
+
+	dev_info(&gadget->dev, DRIVER_DESC ", version: " DRIVER_VERSION "\n");
+
+	return 0;
+}
+
+static int __exit osi_unbind(struct usb_composite_dev *cdev)
+{
+	ghid_cleanup();
+	return 0;
+}
+
+static int __init osig_plat_driver_probe(struct platform_device *pdev)
+{
+	struct hidg_func_descriptor *func = pdev->dev.platform_data;
+	struct hidg_func_node *entry;
+
+	if (!func) {
+		dev_err(&pdev->dev, "Platform data missing\n");
+		return -ENODEV;
+	}
+
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	if (!entry)
+		return -ENOMEM;
+
+	entry->func = func;
+	list_add_tail(&entry->node, &hidg_func_list);
+
+	return 0;
+}
+
+static int __devexit osig_plat_driver_remove(struct platform_device *pdev)
+{
+	struct hidg_func_node *e, *n;
+
+	list_for_each_entry_safe(e, n, &hidg_func_list, node) {
+		list_del(&e->node);
+		kfree(e);
+	}
+
+	return 0;
+}
+
+/********************* Devices for userland access ***********/
+
+/* hid descriptor for a keyboard */
+static struct hidg_func_descriptor my_hid_data = {
+.subclass       = 0, /* No subclass */
+.protocol       = 1, /* Keyboard */
+.report_length      = 8,
+.report_desc_length = 63,
+.report_desc        = {
+        0x05, 0x01, /* USAGE_PAGE (Generic Desktop)           */
+        0x09, 0x06, /* USAGE (Keyboard)                       */
+        0xa1, 0x01, /* COLLECTION (Application)               */
+        0x05, 0x07, /*   USAGE_PAGE (Keyboard)                */
+        0x19, 0xe0, /*   USAGE_MINIMUM (Keyboard LeftControl) */
+        0x29, 0xe7, /*   USAGE_MAXIMUM (Keyboard Right GUI)   */
+        0x15, 0x00, /*   LOGICAL_MINIMUM (0)                  */
+        0x25, 0x01, /*   LOGICAL_MAXIMUM (1)                  */
+        0x75, 0x01, /*   REPORT_SIZE (1)                      */
+        0x95, 0x08, /*   REPORT_COUNT (8)                     */
+        0x81, 0x02, /*   INPUT (Data,Var,Abs)                 */
+        0x95, 0x01, /*   REPORT_COUNT (1)                     */
+        0x75, 0x08, /*   REPORT_SIZE (8)                      */
+        0x81, 0x03, /*   INPUT (Cnst,Var,Abs)                 */
+        0x95, 0x05, /*   REPORT_COUNT (5)                     */
+        0x75, 0x01, /*   REPORT_SIZE (1)                      */
+        0x05, 0x08, /*   USAGE_PAGE (LEDs)                    */
+        0x19, 0x01, /*   USAGE_MINIMUM (Num Lock)             */
+        0x29, 0x05, /*   USAGE_MAXIMUM (Kana)                 */
+        0x91, 0x02, /*   OUTPUT (Data,Var,Abs)                */
+        0x95, 0x01, /*   REPORT_COUNT (1)                     */
+        0x75, 0x03, /*   REPORT_SIZE (3)                      */
+        0x91, 0x03, /*   OUTPUT (Cnst,Var,Abs)                */
+        0x95, 0x06, /*   REPORT_COUNT (6)                     */
+        0x75, 0x08, /*   REPORT_SIZE (8)                      */
+        0x15, 0x00, /*   LOGICAL_MINIMUM (0)                  */
+        0x25, 0x65, /*   LOGICAL_MAXIMUM (101)                */
+        0x05, 0x07, /*   USAGE_PAGE (Keyboard)                */
+        0x19, 0x00, /*   USAGE_MINIMUM (Reserved)             */
+        0x29, 0x65, /*   USAGE_MAXIMUM (Keyboard Application) */
+        0x81, 0x00, /*   INPUT (Data,Ary,Abs)                 */
+        0xc0        /* END_COLLECTION                         */
+    }
+};
+
+static struct platform_device my_hid = {
+.name           = "hidg",
+.id         = 0,
+.num_resources      = 0,
+.resource       = 0,
+.dev = {
+    .platform_data  = &my_hid_data,
+    }, 
+};
+
+/****************************** Drivers ******************************/
+
+static struct usb_composite_driver osig_driver = {
+	.name		= "g_osi",
+	.dev		= &device_desc,
+	.strings	= dev_strings,
+	.unbind		= __exit_p(osi_unbind),
+};
+
+static struct platform_driver osig_plat_driver = {
+    .probe      = osig_plat_driver_probe,
+	.remove		= __devexit_p(osig_plat_driver_remove),
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "hidg",
+	},
+};
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("Eric Klein");
+MODULE_LICENSE("GPL");
+
+static int __init osig_init(void)
+{
+	int status;
+
+    status = platform_device_register(&my_hid);
+printk(KERN_ERR "dbdosi: platform_device_register status=%x\n", status);
+    if (status < 0)
+        return status;
+
+	status = platform_driver_probe(&osig_plat_driver,
+				osig_plat_driver_probe);
+printk(KERN_ERR "dbdosi: platform_driver_probe status=%x\n", status);
+	if (status < 0)
+		return status;
+
+	status = usb_composite_probe(&osig_driver, osi_bind);
+printk(KERN_ERR "dbdosi: usb_composite_probe status=%x\n", status);
+	if (status < 0)
+		platform_driver_unregister(&osig_plat_driver);
+
+	return status;
+}
+module_init(osig_init);
+
+static void __exit osig_cleanup(void)
+{
+	platform_driver_unregister(&osig_plat_driver);
+	usb_composite_unregister(&osig_driver);
+}
+module_exit(osig_cleanup);
diff --git a/drivers/diebold/linux-dbdusb/epautoconf.c b/drivers/diebold/linux-dbdusb/epautoconf.c
new file mode 100755
index 000000000..4efc22bbe
--- /dev/null
+++ b/drivers/diebold/linux-dbdusb/epautoconf.c
@@ -0,0 +1,335 @@
+/*
+ * epautoconf.c -- endpoint autoconfiguration for usb gadget drivers
+ *
+ * Copyright (C) 2004 David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/device.h>
+
+#include <linux/ctype.h>
+#include <linux/string.h>
+
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+
+#include "gadget_chips.h"
+
+
+/* we must assign addresses for configurable endpoints (like net2280) */
+static unsigned epnum;
+
+// #define MANY_ENDPOINTS
+#ifdef MANY_ENDPOINTS
+/* more than 15 configurable endpoints */
+static unsigned in_epnum;
+#endif
+
+
+/*
+ * This should work with endpoints from controller drivers sharing the
+ * same endpoint naming convention.  By example:
+ *
+ *	- ep1, ep2, ... address is fixed, not direction or type
+ *	- ep1in, ep2out, ... address and direction are fixed, not type
+ *	- ep1-bulk, ep2-bulk, ... address and type are fixed, not direction
+ *	- ep1in-bulk, ep2out-iso, ... all three are fixed
+ *	- ep-* ... no functionality restrictions
+ *
+ * Type suffixes are "-bulk", "-iso", or "-int".  Numbers are decimal.
+ * Less common restrictions are implied by gadget_is_*().
+ *
+ * NOTE:  each endpoint is unidirectional, as specified by its USB
+ * descriptor; and isn't specific to a configuration or altsetting.
+ */
+static int
+ep_matches (
+	struct usb_gadget		*gadget,
+	struct usb_ep			*ep,
+	struct usb_endpoint_descriptor	*desc
+)
+{
+	u8		type;
+	const char	*tmp;
+	u16		max;
+
+	/* endpoint already claimed? */
+	if (NULL != ep->driver_data)
+		return 0;
+
+	/* only support ep0 for portable CONTROL traffic */
+	type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
+	if (USB_ENDPOINT_XFER_CONTROL == type)
+		return 0;
+
+	/* some other naming convention */
+	if ('e' != ep->name[0])
+		return 0;
+
+	/* type-restriction:  "-iso", "-bulk", or "-int".
+	 * direction-restriction:  "in", "out".
+	 */
+	if ('-' != ep->name[2]) {
+		tmp = strrchr (ep->name, '-');
+		if (tmp) {
+			switch (type) {
+			case USB_ENDPOINT_XFER_INT:
+				/* bulk endpoints handle interrupt transfers,
+				 * except the toggle-quirky iso-synch kind
+				 */
+				if ('s' == tmp[2])	// == "-iso"
+					return 0;
+				/* for now, avoid PXA "interrupt-in";
+				 * it's documented as never using DATA1.
+				 */
+				if (gadget_is_pxa (gadget)
+						&& 'i' == tmp [1])
+					return 0;
+				break;
+			case USB_ENDPOINT_XFER_BULK:
+				if ('b' != tmp[1])	// != "-bulk"
+					return 0;
+				break;
+			case USB_ENDPOINT_XFER_ISOC:
+				if ('s' != tmp[2])	// != "-iso"
+					return 0;
+			}
+		} else {
+			tmp = ep->name + strlen (ep->name);
+		}
+
+		/* direction-restriction:  "..in-..", "out-.." */
+		tmp--;
+		if (!isdigit (*tmp)) {
+			if (desc->bEndpointAddress & USB_DIR_IN) {
+				if ('n' != *tmp)
+					return 0;
+			} else {
+				if ('t' != *tmp)
+					return 0;
+			}
+		}
+	}
+
+	/*
+	 * If the protocol driver hasn't yet decided on wMaxPacketSize
+	 * and wants to know the maximum possible, provide the info.
+	 */
+	if (desc->wMaxPacketSize == 0)
+		desc->wMaxPacketSize = cpu_to_le16(ep->maxpacket);
+
+	/* endpoint maxpacket size is an input parameter, except for bulk
+	 * where it's an output parameter representing the full speed limit.
+	 * the usb spec fixes high speed bulk maxpacket at 512 bytes.
+	 */
+	max = 0x7ff & le16_to_cpu(desc->wMaxPacketSize);
+	switch (type) {
+	case USB_ENDPOINT_XFER_INT:
+		/* INT:  limit 64 bytes full speed, 1024 high speed */
+		if (!gadget->is_dualspeed && max > 64)
+			return 0;
+		/* FALLTHROUGH */
+
+	case USB_ENDPOINT_XFER_ISOC:
+		/* ISO:  limit 1023 bytes full speed, 1024 high speed */
+		if (ep->maxpacket < max)
+			return 0;
+		if (!gadget->is_dualspeed && max > 1023)
+			return 0;
+
+		/* BOTH:  "high bandwidth" works only at high speed */
+		if ((desc->wMaxPacketSize & cpu_to_le16(3<<11))) {
+			if (!gadget->is_dualspeed)
+				return 0;
+			/* configure your hardware with enough buffering!! */
+		}
+		break;
+	}
+
+	/* MATCH!! */
+
+	/* report address */
+	desc->bEndpointAddress &= USB_DIR_IN;
+	if (isdigit (ep->name [2])) {
+		u8	num = simple_strtoul (&ep->name [2], NULL, 10);
+		desc->bEndpointAddress |= num;
+#ifdef	MANY_ENDPOINTS
+	} else if (desc->bEndpointAddress & USB_DIR_IN) {
+		if (++in_epnum > 15)
+			return 0;
+		desc->bEndpointAddress = USB_DIR_IN | in_epnum;
+#endif
+	} else {
+		if (++epnum > 15)
+			return 0;
+		desc->bEndpointAddress |= epnum;
+	}
+
+	/* report (variable) full speed bulk maxpacket */
+	if (USB_ENDPOINT_XFER_BULK == type) {
+		int size = ep->maxpacket;
+
+		/* min() doesn't work on bitfields with gcc-3.5 */
+		if (size > 64)
+			size = 64;
+		desc->wMaxPacketSize = cpu_to_le16(size);
+	}
+	return 1;
+}
+
+static struct usb_ep *
+find_ep (struct usb_gadget *gadget, const char *name)
+{
+	struct usb_ep	*ep;
+
+	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
+		if (0 == strcmp (ep->name, name))
+			return ep;
+	}
+	return NULL;
+}
+
+/**
+ * usb_ep_autoconfig - choose an endpoint matching the descriptor
+ * @gadget: The device to which the endpoint must belong.
+ * @desc: Endpoint descriptor, with endpoint direction and transfer mode
+ *	initialized.  For periodic transfers, the maximum packet
+ *	size must also be initialized.  This is modified on success.
+ *
+ * By choosing an endpoint to use with the specified descriptor, this
+ * routine simplifies writing gadget drivers that work with multiple
+ * USB device controllers.  The endpoint would be passed later to
+ * usb_ep_enable(), along with some descriptor.
+ *
+ * That second descriptor won't always be the same as the first one.
+ * For example, isochronous endpoints can be autoconfigured for high
+ * bandwidth, and then used in several lower bandwidth altsettings.
+ * Also, high and full speed descriptors will be different.
+ *
+ * Be sure to examine and test the results of autoconfiguration on your
+ * hardware.  This code may not make the best choices about how to use the
+ * USB controller, and it can't know all the restrictions that may apply.
+ * Some combinations of driver and hardware won't be able to autoconfigure.
+ *
+ * On success, this returns an un-claimed usb_ep, and modifies the endpoint
+ * descriptor bEndpointAddress.  For bulk endpoints, the wMaxPacket value
+ * is initialized as if the endpoint were used at full speed.  To prevent
+ * the endpoint from being returned by a later autoconfig call, claim it
+ * by assigning ep->driver_data to some non-null value.
+ *
+ * On failure, this returns a null endpoint descriptor.
+ */
+struct usb_ep *usb_ep_autoconfig (
+	struct usb_gadget		*gadget,
+	struct usb_endpoint_descriptor	*desc
+)
+{
+	struct usb_ep	*ep;
+	u8		type;
+
+	type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
+
+	/* First, apply chip-specific "best usage" knowledge.
+	 * This might make a good usb_gadget_ops hook ...
+	 */
+	if (gadget_is_net2280 (gadget) && type == USB_ENDPOINT_XFER_INT) {
+		/* ep-e, ep-f are PIO with only 64 byte fifos */
+		ep = find_ep (gadget, "ep-e");
+		if (ep && ep_matches (gadget, ep, desc))
+			return ep;
+		ep = find_ep (gadget, "ep-f");
+		if (ep && ep_matches (gadget, ep, desc))
+			return ep;
+
+	} else if (gadget_is_goku (gadget)) {
+		if (USB_ENDPOINT_XFER_INT == type) {
+			/* single buffering is enough */
+			ep = find_ep (gadget, "ep3-bulk");
+			if (ep && ep_matches (gadget, ep, desc))
+				return ep;
+		} else if (USB_ENDPOINT_XFER_BULK == type
+				&& (USB_DIR_IN & desc->bEndpointAddress)) {
+			/* DMA may be available */
+			ep = find_ep (gadget, "ep2-bulk");
+			if (ep && ep_matches (gadget, ep, desc))
+				return ep;
+		}
+
+#ifdef CONFIG_BLACKFIN
+	} else if (gadget_is_musbhdrc(gadget)) {
+		if ((USB_ENDPOINT_XFER_BULK == type) ||
+		    (USB_ENDPOINT_XFER_ISOC == type)) {
+			if (USB_DIR_IN & desc->bEndpointAddress)
+				ep = find_ep (gadget, "ep5in");
+			else
+				ep = find_ep (gadget, "ep6out");
+		} else if (USB_ENDPOINT_XFER_INT == type) {
+			if (USB_DIR_IN & desc->bEndpointAddress)
+				ep = find_ep(gadget, "ep1in");
+			else
+				ep = find_ep(gadget, "ep2out");
+		} else
+			ep = NULL;
+		if (ep && ep_matches (gadget, ep, desc))
+			return ep;
+#endif
+	}
+
+#ifdef CONFIG_USB_G_DBDOSI
+    /* Make sure out EP address is 2 for Diebold Windows driver */
+    if (desc->bEndpointAddress==2) {
+        ep = find_ep(gadget, "ep2out");
+        if (ep && ep_matches(gadget, ep, desc))
+            return ep;
+    }
+#endif
+
+	/* Second, look at endpoints until an unclaimed one looks usable */
+	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
+		if (ep_matches (gadget, ep, desc))
+			return ep;
+	}
+
+	/* Fail */
+	return NULL;
+}
+
+/**
+ * usb_ep_autoconfig_reset - reset endpoint autoconfig state
+ * @gadget: device for which autoconfig state will be reset
+ *
+ * Use this for devices where one configuration may need to assign
+ * endpoint resources very differently from the next one.  It clears
+ * state such as ep->driver_data and the record of assigned endpoints
+ * used by usb_ep_autoconfig().
+ */
+void usb_ep_autoconfig_reset (struct usb_gadget *gadget)
+{
+	struct usb_ep	*ep;
+
+	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
+		ep->driver_data = NULL;
+	}
+#ifdef	MANY_ENDPOINTS
+	in_epnum = 0;
+#endif
+	epnum = 0;
+}
+
diff --git a/drivers/diebold/linux-dbdusb/f_dbdusb.c b/drivers/diebold/linux-dbdusb/f_dbdusb.c
new file mode 100755
index 000000000..b50498ee3
--- /dev/null
+++ b/drivers/diebold/linux-dbdusb/f_dbdusb.c
@@ -0,0 +1,960 @@
+/*
+ * f_dbdusb.c - Diebold Colorado USB function driver
+ *
+ * Copyright (C) 2012 by Diebold Corporation
+ *
+ */
+
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/mutex.h>
+
+#include "gadget_chips.h"
+
+#include "dbdmsg.c"
+
+
+struct dbdusb_descs {
+	struct usb_endpoint_descriptor	*in;
+	struct usb_endpoint_descriptor	*out;
+	struct usb_endpoint_descriptor	*bulk_in;
+};
+
+struct queued_msg {
+    wait_queue_head_t wait_queue;
+    spinlock_t lock;
+    u32 len;
+    u8 *data;
+};
+
+struct f_dbdusb {
+	u8				        data_id;
+	struct usb_function		func;
+
+    struct usb_request      *out_req;
+    struct usb_request      *in_req;
+    struct usb_request      *c0_in_req[2]; /* one for interrupt, one for bulk */
+
+	struct dbdusb_descs		fs;
+	struct dbdusb_descs		hs;
+
+    struct usb_endpoint_descriptor *in_desc;
+    struct usb_endpoint_descriptor *out_desc;
+    struct usb_endpoint_descriptor *bulk_in_desc;
+
+    struct usb_ep           *in_ep;
+    struct usb_ep           *out_ep;
+    struct usb_ep           *bulk_in_ep;
+
+    /* set true to initiate next read on out_ep when queue is full */
+    bool                    needs_out_read_req;
+
+    /* stuff for Colorado message encode/decode */
+    MsgPackage_s            decode_pkg;
+    MsgPackage_s            encode_pkg;
+    u8                      *decode_pkt;
+    u8                      *encode_pkt;
+
+    /* tasklet to queue incoming messages */
+	// struct tasklet_struct	qmsg_tasklet;
+
+    /* bookkeeping */
+    u32                     bad_writes;
+    u32                     good_writes;
+    u32                     bad_reads;
+    u32                     good_reads;
+
+    /* queue of incoming messages */
+    struct queued_msg       readq;
+
+    /* queue of outgoing messages */
+    struct queued_msg       writeq;
+
+    /* data for char dev */
+    dev_t                   chrdev_major_minor;
+    struct cdev             chrdev;
+    struct class            *chrdev_class;
+
+    /* limit char dev to one read and write at a time*/
+	struct mutex			chrdev_mutex;
+	bool                    chrdev_read_active;
+    bool                    chrdev_write_active;
+};
+
+static inline struct f_dbdusb *func_to_dbdusb(struct usb_function *f)
+{
+	return container_of(f, struct f_dbdusb, func);
+}
+
+static inline struct f_dbdusb *cdev_to_dbdusb(struct cdev *c)
+{
+    return container_of(c, struct f_dbdusb, chrdev);
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* interface descriptor: */
+
+static struct usb_interface_descriptor dbdusb_interface_desc __initdata = {
+	.bLength =		USB_DT_INTERFACE_SIZE,
+	.bDescriptorType =	USB_DT_INTERFACE,
+	/* .bInterfaceNumber = DYNAMIC */
+	.bNumEndpoints =	3,
+	.bInterfaceClass =	USB_CLASS_VENDOR_SPEC,
+	.bInterfaceSubClass =	0,
+	.bInterfaceProtocol =	0,
+	/* .iInterface = DYNAMIC */
+};
+
+/* full speed support: */
+
+static struct usb_endpoint_descriptor dbdusb_fs_in_desc __initdata = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	USB_DIR_IN | 1,
+    .bInterval        = 3,
+	.bmAttributes =		USB_ENDPOINT_XFER_INT,
+	.wMaxPacketSize =	cpu_to_le16(256),
+};
+
+static struct usb_endpoint_descriptor dbdusb_fs_out_desc __initdata = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	USB_DIR_OUT | 2,
+    .bInterval        = 3,
+	.bmAttributes =		USB_ENDPOINT_XFER_INT,
+	.wMaxPacketSize =	cpu_to_le16(256),
+};
+
+static struct usb_endpoint_descriptor dbdusb_fs_bulk_in_desc __initdata = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	USB_DIR_IN | 5,
+    .bInterval        = 3,
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize =	cpu_to_le16(256),
+};
+
+static struct usb_descriptor_header *dbdusb_fs_function[] __initdata = {
+	(struct usb_descriptor_header *) &dbdusb_interface_desc,
+	(struct usb_descriptor_header *) &dbdusb_fs_in_desc,
+	(struct usb_descriptor_header *) &dbdusb_fs_out_desc,
+	(struct usb_descriptor_header *) &dbdusb_fs_bulk_in_desc,
+	NULL,
+};
+
+/* high speed support: */
+static struct usb_endpoint_descriptor dbdusb_hs_in_desc __initdata = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	USB_DIR_IN | 1,
+    .bInterval        = 3,
+	.bmAttributes =		USB_ENDPOINT_XFER_INT,
+	.wMaxPacketSize =	cpu_to_le16(256),
+};
+
+static struct usb_endpoint_descriptor dbdusb_hs_out_desc __initdata = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	USB_DIR_OUT | 2,
+    .bInterval        = 3,
+	.bmAttributes =		USB_ENDPOINT_XFER_INT,
+	.wMaxPacketSize =	cpu_to_le16(256),
+};
+
+static struct usb_endpoint_descriptor dbdusb_hs_bulk_in_desc __initdata = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	USB_DIR_IN | 5,
+    .bInterval        = 16,
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize =	cpu_to_le16(512),
+};
+
+static struct usb_descriptor_header *dbdusb_hs_function[] __initdata = {
+	(struct usb_descriptor_header *) &dbdusb_interface_desc,
+	(struct usb_descriptor_header *) &dbdusb_hs_in_desc,
+	(struct usb_descriptor_header *) &dbdusb_hs_out_desc,
+	(struct usb_descriptor_header *) &dbdusb_hs_bulk_in_desc,
+	NULL,
+};
+
+/* string descriptors: */
+
+static struct usb_string dbdusb_string_defs[] = {
+	[0].s = "Diebold USB",
+	{  } /* end of list */
+};
+
+static struct usb_gadget_strings dbdusb_string_table = {
+	.language =		0x0409,	/* en-us */
+	.strings =		dbdusb_string_defs,
+};
+
+static struct usb_gadget_strings *dbdusb_strings[] = {
+	&dbdusb_string_table,
+	NULL,
+};
+
+/*-------------------------------------------------------------------------*/
+/* handling of messages in transit between USB and chrdev
+   the "queue" is really just one item right now  */
+
+static void dbdusb_create_message_queue(struct queued_msg *q)
+{
+    q->data = NULL;
+    q->len = 0;
+    spin_lock_init(&q->lock);
+	init_waitqueue_head(&q->wait_queue);
+}
+
+static inline bool dbdusb_queue_if_empty(struct queued_msg *q, u8 *msg, u32 len)
+{
+    unsigned long flags;
+    bool rc = false;
+
+    spin_lock_irqsave(&q->lock, flags);
+    if (q->data==NULL) {
+        rc = true;
+        q->data = msg;
+        q->len = len;
+    }
+    spin_unlock_irqrestore(&q->lock, flags);
+
+    if (rc)
+        wake_up_interruptible(&q->wait_queue);
+
+    return rc;
+}
+
+static int dbdusb_queue_blocking(struct queued_msg *q, u8 *msg, u32 len)
+{
+    while (!dbdusb_queue_if_empty(q, msg, len)) {
+    
+        if (wait_event_interruptible(q->wait_queue, (q->data==NULL)))
+            return -ERESTARTSYS;
+    }
+
+    return 0;
+}
+
+static u8 *dbdusb_dequeue_if_present(struct queued_msg *q, u32 *len)
+{
+    u8 *rc;
+    unsigned long flags;
+    
+    spin_lock_irqsave(&q->lock, flags);
+    rc = q->data;
+    if (rc) {
+        if (len)
+            *len = q->len;
+
+        q->data = NULL;
+        q->len = 0;
+    }
+    spin_unlock_irqrestore(&q->lock, flags);
+
+    if (rc) 
+        wake_up_interruptible(&q->wait_queue);
+
+    return rc;
+}
+
+static u8 *dbdusb_dequeue_blocking(struct queued_msg *q, u32 *len)
+{
+    u8 *rc;
+
+    while (!(rc = dbdusb_dequeue_if_present(q, len))) {
+
+        if (wait_event_interruptible(q->wait_queue, (q->data!=NULL)))
+            return NULL;
+    }
+
+    return rc;
+}
+
+static u32 dbdusb_peek_blocking(struct queued_msg *q)
+{
+    int rc = 0;
+    unsigned long flags;
+
+    while (rc==0) {
+        spin_lock_irqsave(&q->lock, flags);
+        if (q->data!=NULL) 
+            rc = q->len;
+        spin_unlock_irqrestore(&q->lock, flags);
+
+        if (rc==0) {
+            if (wait_event_interruptible(q->wait_queue, (q->data!=NULL)))
+                break;
+        }
+    } 
+    return rc;
+}
+
+/*-------------------------------------------------------------------------*/
+static void dbdusb_usb_read_complete(struct usb_ep *ep, struct usb_request *req)
+{
+    struct f_dbdusb *dbdusb = ep->driver_data;
+
+    if (req->status) {  /* error or shutdown */
+        if (req->status != -ESHUTDOWN) {
+            ++dbdusb->bad_reads;
+            usb_ep_queue(ep, req, GFP_ATOMIC);
+        }
+    }
+    else {
+        u32 len = 0;
+        u32 rc = LLDecode(&dbdusb->decode_pkg, &len);
+
+        ++dbdusb->good_reads;
+
+        switch (rc) {
+
+            /* still decoding a msg, call with next pkt recvd */
+            case kRCDecodeOk:		
+                usb_ep_queue(ep, req, GFP_ATOMIC);
+                break;
+
+            /* Entire msg decoded, client should route */
+            case kRCClientMsgComplete:	
+                if (dbdusb_queue_if_empty(&dbdusb->readq, 
+                                    dbdusb->decode_pkg.pMsgBuf, 
+                                    dbdusb->decode_pkg.MsgLen)) {
+                    dbdusb->decode_pkg.pMsgBuf = NULL;
+                    LLDecodeReset(&dbdusb->decode_pkg);
+                    usb_ep_queue(ep, req, GFP_ATOMIC);
+                }
+                else {
+                    printk(KERN_ERR "dbdusb: message queue full\n");
+                    dbdusb->needs_out_read_req = true;
+                }
+                break;
+
+            /* length msg found, do not route, msg complete */
+            case kRCNoMsgData:		
+                LLDecodeReset(&dbdusb->decode_pkg);
+                usb_ep_queue(ep, req, GFP_ATOMIC);
+                break;
+
+            case kRCPkgError:	/* ??? */
+            default:
+                printk(KERN_ERR "dbdusb: error from LLDecode\n");
+                usb_ep_queue(ep, req, GFP_ATOMIC);
+                break;
+        }
+    }
+}
+
+static int dbdusb_start_rx(struct f_dbdusb *dbdusb)
+{
+    struct usb_request *req;
+    struct usb_ep *out = dbdusb->out_ep;
+    int status = -ENOMEM;
+
+    /* allocate request to place packet directly in decode buffer */
+	req = usb_ep_alloc_request(out, GFP_KERNEL);
+	if (req != NULL) {
+		req->length = out->maxpacket;
+		req->buf = dbdusb->decode_pkt;
+        req->complete = dbdusb_usb_read_complete;
+        dbdusb->out_req = req;
+        status = usb_ep_queue(out, req, GFP_ATOMIC);
+    }
+
+    /* ignore pending request from last session */
+    dbdusb->needs_out_read_req = false;
+
+    return status;
+}
+
+static void dbdusb_free_request_buffers(struct f_dbdusb *dbdusb)
+{
+    int i;
+    struct usb_request *req;
+
+    for (i=0; i<2; i++) {
+        req = dbdusb->c0_in_req[i];
+        if (req) {
+            if (req->buf)
+                kfree(req->buf);
+            usb_ep_free_request(i==0 ? 
+                    dbdusb->in_ep : dbdusb->bulk_in_ep, req);
+            dbdusb->c0_in_req[i] = NULL;
+        }
+    }
+    if (dbdusb->in_req) {
+        usb_ep_free_request(dbdusb->in_ep, dbdusb->in_req);
+        dbdusb->in_req = NULL;
+    }
+}
+
+static void dbdusb_queue_c0_packet(struct f_dbdusb *dbdusb, struct usb_ep *ep)
+{
+    if (ep == dbdusb->in_ep)
+        usb_ep_queue(ep, dbdusb->c0_in_req[0], GFP_ATOMIC);
+    else
+        usb_ep_queue(ep, dbdusb->c0_in_req[1], GFP_ATOMIC);
+}
+
+static void dbdusb_usb_write_complete(struct usb_ep *ep, struct usb_request *req)
+{
+    struct f_dbdusb *dbdusb = ep->driver_data;
+
+    if (req->status) {  /* error or shutdown */
+        if (req->status == -ESHUTDOWN) {
+            if (dbdusb->in_ep == ep)    /* only free once, on interrupt IN request */
+                dbdusb_free_request_buffers(dbdusb);
+        }
+        else {
+            ++dbdusb->bad_writes;
+            usb_ep_queue(ep, req, GFP_ATOMIC);
+        }
+    }
+    else {
+        u32 encode_status;
+
+        ++dbdusb->good_writes;
+
+        encode_status = LLEncodeStatus(&dbdusb->encode_pkg);
+        switch (encode_status) {
+
+            /* package idle, send first packet or C0 if no data */
+            case kRCPkgReady:
+            {
+                u32 len;
+                u8 *data = dbdusb_dequeue_if_present(&dbdusb->writeq, &len);
+                if (data) {
+
+                    /* first packet, reset encoder */
+                    LLEncodeReset(data, len, &dbdusb->encode_pkg);
+                    encode_status = LLEncode(&dbdusb->encode_pkg);
+                }
+                else {
+                    dbdusb_queue_c0_packet(dbdusb, ep);
+                }
+            }
+            break;
+
+            /* still encoding, call again */
+            case kRCPkgBusy:
+            {
+                encode_status = LLEncode(&dbdusb->encode_pkg);
+            }
+            break;
+        }
+
+        /* encode_status is now LLEncode status from above */
+        switch (encode_status) {
+
+            /* no reset/encode, C0 packet already queued */
+            case kRCPkgReady:  
+                break;
+
+            /* Entire msg encoded, done */
+            case kRCClientMsgComplete:	
+                kfree(dbdusb->encode_pkg.pMsgBuf);
+                dbdusb->encode_pkg.pMsgBuf = NULL;
+                /* fall through */
+            case kRCEncodeOk:           /* still encoding */
+                usb_ep_queue(ep, dbdusb->in_req, GFP_ATOMIC);
+                break;
+
+            case kRCPkgError:	/* ??? */
+            default:
+                printk(KERN_ERR "dbdusb: error from LLEncode\n");
+                if (dbdusb->encode_pkg.pMsgBuf) {
+                    kfree(dbdusb->encode_pkg.pMsgBuf);
+                    dbdusb->encode_pkg.pMsgBuf = NULL;
+                }
+                dbdusb_queue_c0_packet(dbdusb, ep);
+                break;
+        }
+    }
+}
+
+static int dbdusb_start_tx(struct f_dbdusb *dbdusb)
+{
+    struct usb_request *req;
+    struct usb_ep *in[2];
+    int status = -ENOMEM;
+    int i;
+
+    in[0] = dbdusb->in_ep;
+    in[1] = dbdusb->bulk_in_ep;
+
+    /* allocate C0 responses */
+    for (i=0; i<2; i++) {
+        req = usb_ep_alloc_request(in[i], GFP_KERNEL);
+        if (!req)
+            goto fail;
+
+        dbdusb->c0_in_req[i] = req;
+        req->length = in[i]->maxpacket;
+        req->complete = dbdusb_usb_write_complete;
+        req->buf = kzalloc(req->length, GFP_KERNEL);
+        if (!req->buf)
+            goto fail;
+
+        memset(req->buf, 0, req->length);
+        ((char*)req->buf)[0] = 'C';
+    }
+
+    /* allocate request to send packet from encode buffer */
+    req = usb_ep_alloc_request(in[0], GFP_KERNEL);
+    if (!req) 
+        goto fail;
+
+    dbdusb->in_req = req;
+    req->length = in[0]->maxpacket;
+    req->complete = dbdusb_usb_write_complete;
+    req->buf = dbdusb->encode_pkt;
+
+    /* start answering */
+    for (i=0; i<2; i++) {
+        status = usb_ep_queue(in[i], dbdusb->c0_in_req[i], GFP_ATOMIC);
+        if (status)
+            goto fail;
+    }
+    return 0;
+
+fail:
+    dbdusb_free_request_buffers(dbdusb);
+    return status;
+}
+
+static int dbdusb_connect(struct f_dbdusb *dbdusb)
+{
+    int status = 0;
+
+    /* initialize for Colorado encode/decode */
+	dbdusb->decode_pkt = kzalloc(dbdusb->out_desc->wMaxPacketSize, GFP_KERNEL);
+    if (!dbdusb->decode_pkt)
+        return -ENOMEM;
+    LLDecodePkgInit(NULL, 0, 
+            dbdusb->decode_pkt, dbdusb->out_desc->wMaxPacketSize,
+            &dbdusb->decode_pkg);
+
+	dbdusb->encode_pkt = kzalloc(dbdusb->in_desc->wMaxPacketSize, GFP_KERNEL);
+    if (!dbdusb->encode_pkt)
+        return -ENOMEM;
+    LLEncodePkgInit(
+            dbdusb->encode_pkt, dbdusb->in_desc->wMaxPacketSize,
+            &dbdusb->encode_pkg);
+
+    /* enable the endpoints */
+	status = usb_ep_enable(dbdusb->in_ep, dbdusb->in_desc);
+	if (status < 0)
+		goto fail_in;
+    dbdusb->in_ep->driver_data = dbdusb;
+
+	status = usb_ep_enable(dbdusb->out_ep, dbdusb->out_desc);
+	if (status < 0)
+		goto fail_out;
+    dbdusb->out_ep->driver_data = dbdusb;
+
+	status = usb_ep_enable(dbdusb->bulk_in_ep, dbdusb->bulk_in_desc);
+	if (status < 0) 
+		goto fail_bulk;
+    dbdusb->bulk_in_ep->driver_data = dbdusb;
+
+    /* enque initial requests */
+    status = dbdusb_start_tx(dbdusb);
+    if (status == 0) {
+        status = dbdusb_start_rx(dbdusb);
+    }
+    if (status < 0)
+        goto fail_bulk;
+
+    return 0;
+
+fail_bulk:
+    usb_ep_disable(dbdusb->bulk_in_ep);
+    dbdusb->bulk_in_ep->driver_data = NULL;
+fail_out:
+    usb_ep_disable(dbdusb->in_ep);
+    dbdusb->in_ep->driver_data = NULL;
+fail_in:
+
+    return status;
+}
+
+static void dbdusb_disconnect(struct f_dbdusb *dbdusb)
+{
+    usb_ep_disable(dbdusb->in_ep);
+    usb_ep_disable(dbdusb->out_ep);
+    usb_ep_disable(dbdusb->bulk_in_ep);
+
+	kfree(dbdusb->decode_pkt);
+    dbdusb->decode_pkt = dbdusb->decode_pkg.pPktBuf = NULL;
+	kfree(dbdusb->encode_pkt);
+    dbdusb->encode_pkt = dbdusb->encode_pkg.pPktBuf = NULL;
+
+    dbdusb->in_ep->driver_data 
+    = dbdusb->out_ep->driver_data 
+    = dbdusb->bulk_in_ep->driver_data = NULL;
+}
+
+
+static int dbdusb_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
+{
+	struct f_dbdusb	*dbdusb = func_to_dbdusb(f);
+	struct usb_composite_dev *cdev = f->config->cdev;
+    int status = 0;
+
+    if (!dbdusb->in_ep) {
+        dbdusb_disconnect(dbdusb);
+    }
+    else {
+        dbdusb->in_desc = ep_choose(cdev->gadget,
+                    dbdusb->hs.in, dbdusb->fs.in);
+        dbdusb->out_desc = ep_choose(cdev->gadget,
+                    dbdusb->hs.out, dbdusb->fs.out);
+        dbdusb->bulk_in_desc = ep_choose(cdev->gadget,
+                    dbdusb->hs.bulk_in, dbdusb->fs.bulk_in);
+    }
+
+	status = dbdusb_connect(dbdusb);
+	if (status < 0) {
+		printk(KERN_ERR "dbdusb: rc=%d from dbdusb_connect\n", status);
+    }
+
+    return status;
+}
+
+static void dbdusb_disable(struct usb_function *f)
+{
+	struct f_dbdusb *dbdusb = func_to_dbdusb(f);
+
+printk(KERN_ERR "dbdusb: bad_reads=%d good_reads=%d bad_writes=%d good_writes=%d\n", dbdusb->bad_reads, dbdusb->good_reads, dbdusb->bad_writes, dbdusb->good_writes);
+    dbdusb->bad_reads = dbdusb->good_reads = dbdusb->bad_writes = dbdusb->good_writes = 0;
+
+    dbdusb_disconnect(dbdusb);
+}
+
+
+/*-------------------------------------------------------------------------*/
+/* entry points for user device access */
+
+int dbdusb_chrdev_open(struct inode *inode, struct file *f)
+{
+    /*  stash dbdusb pointer in file private data */
+
+    struct cdev *cdev = inode->i_cdev;
+    f->private_data = cdev_to_dbdusb(cdev);
+
+    return 0;
+}
+
+static bool dbdusb_chrdev_set_active(struct f_dbdusb *dbdusb, bool *flag)
+{
+    mutex_lock(&dbdusb->chrdev_mutex);
+    if (*flag) {
+        mutex_unlock(&dbdusb->chrdev_mutex);
+        return false;
+    }
+
+    *flag = true;
+    mutex_unlock(&dbdusb->chrdev_mutex);
+
+    return true;
+}
+
+static void dbdusb_chrdev_set_idle(struct f_dbdusb *dbdusb, bool *flag)
+{
+    mutex_lock(&dbdusb->chrdev_mutex);
+    *flag = false;
+    mutex_unlock(&dbdusb->chrdev_mutex);
+}
+
+ssize_t dbdusb_chrdev_read(struct file *f, char __user *uptr, size_t s, loff_t *ofs)
+{
+    struct f_dbdusb *dbdusb = f->private_data;
+    u8 *data;
+    u32 len;
+
+    if (!dbdusb_chrdev_set_active(dbdusb, &dbdusb->chrdev_read_active)) {
+        return -EBUSY;
+    }
+
+    data = dbdusb_dequeue_blocking(&dbdusb->readq, &len);
+    if (!data) {
+        dbdusb_chrdev_set_idle(dbdusb, &dbdusb->chrdev_read_active);
+        return -ERESTARTSYS;
+    }
+
+    if (dbdusb->needs_out_read_req) {   /* restart read if buffer was full */
+        if (usb_ep_queue(dbdusb->out_ep, dbdusb->out_req, GFP_ATOMIC)) {
+            printk(KERN_ERR 
+            "dbdusb: error queuing USB request after read queue full");
+        }
+        else 
+            dbdusb->needs_out_read_req = false;
+    }
+
+    dbdusb_chrdev_set_idle(dbdusb, &dbdusb->chrdev_read_active);
+
+    if (s < len)
+        len = s;
+
+    if (copy_to_user(uptr, data, len)) {
+        kfree(data);
+        return -EFAULT;
+    }
+
+    kfree(data);
+
+    return len;
+}
+
+ssize_t dbdusb_chrdev_write(struct file *f, const char __user *uptr, size_t s, loff_t *ofs)
+{
+    struct f_dbdusb *dbdusb = f->private_data;
+    u8 *buffer;
+    int status;
+    
+    if (!dbdusb_chrdev_set_active(dbdusb, &dbdusb->chrdev_write_active)) {
+        return -EBUSY;
+    }
+
+    buffer = kzalloc(s, GFP_ATOMIC);
+    if (!buffer) {
+        dbdusb_chrdev_set_idle(dbdusb, &dbdusb->chrdev_write_active);
+        return -ENOMEM;
+    }
+
+    if (copy_from_user(buffer, uptr, s)) {
+        dbdusb_chrdev_set_idle(dbdusb, &dbdusb->chrdev_write_active);
+        kfree(buffer);
+        return -EFAULT;
+    }
+    status = dbdusb_queue_blocking(&dbdusb->writeq, buffer, s);
+
+    dbdusb_chrdev_set_idle(dbdusb, &dbdusb->chrdev_write_active);
+
+    if (status) {   /* interrupt from wait queue */
+        kfree(buffer);
+        return -ERESTARTSYS;
+    }
+
+    return s;
+}
+
+static long dbdusb_chrdev_ioctl(struct file *f, unsigned int ip, unsigned long lp)
+{
+    struct f_dbdusb *dbdusb = f->private_data;
+    switch (ip) {
+
+    //  Wait for incoming message and return its length for subsequent read
+        case 0xdbd0001:
+        {
+            u32 len;
+
+            if (!dbdusb_chrdev_set_active(dbdusb, &dbdusb->chrdev_read_active)) 
+                return -EBUSY;
+
+            len = dbdusb_peek_blocking(&dbdusb->readq);
+            if (!len) {
+                dbdusb_chrdev_set_idle(dbdusb, &dbdusb->chrdev_read_active);
+                return -ERESTARTSYS;
+            }
+
+            dbdusb_chrdev_set_idle(dbdusb, &dbdusb->chrdev_read_active);
+            return len;
+        }
+
+        default:
+            printk(KERN_ERR "dbdusb: got unknown ioctl: %d\n", ip);
+            return -EINVAL;
+    }
+    return 0;
+}
+
+static struct file_operations dbdusb_chrdev_ops = {
+    .owner =    THIS_MODULE,
+    .open =     dbdusb_chrdev_open,
+    .read =     dbdusb_chrdev_read,
+    .write =    dbdusb_chrdev_write,
+    .unlocked_ioctl =    dbdusb_chrdev_ioctl,
+};
+
+
+/*-------------------------------------------------------------------------*/
+/* driver setup/binding */
+
+static void dbdusb_chrdev_free(struct f_dbdusb *dbdusb)
+{
+    unregister_chrdev_region(dbdusb->chrdev_major_minor, 1);
+
+    device_destroy(dbdusb->chrdev_class, dbdusb->chrdev_major_minor);
+
+    class_destroy(dbdusb->chrdev_class);
+}
+
+static int __init
+dbdusb_chrdev_create(struct f_dbdusb *dbdusb)
+{
+    int status;
+
+    dbdusb->chrdev_class = class_create(THIS_MODULE, "dbdusb");
+
+    //  TODO: bulk pipe?
+    status = alloc_chrdev_region(&dbdusb->chrdev_major_minor, 0, 1, "dbdusb");
+    if (status < 0)
+        return status;
+
+    cdev_init(&dbdusb->chrdev, &dbdusb_chrdev_ops);
+    dbdusb->chrdev.owner = THIS_MODULE;
+
+    status = cdev_add(&dbdusb->chrdev, dbdusb->chrdev_major_minor, 1);
+    if (status < 0) {
+        dbdusb_chrdev_free(dbdusb);
+        return status;
+    }
+
+	device_create(dbdusb->chrdev_class, NULL, dbdusb->chrdev_major_minor, NULL, "dbdusb");
+
+    mutex_init(&dbdusb->chrdev_mutex);
+
+    return 0;
+}
+
+static int __init
+dbdusb_bind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct usb_composite_dev *cdev = c->cdev;
+	struct f_dbdusb		*dbdusb = func_to_dbdusb(f);
+	int			status;
+	struct usb_ep		*ep;
+
+	/* allocate instance-specific interface IDs */
+	status = usb_interface_id(c, f);
+	if (status < 0)
+		goto fail;
+	dbdusb->data_id = status;
+	dbdusb_interface_desc.bInterfaceNumber = status;
+
+	status = -ENODEV;
+
+	/* allocate instance-specific endpoints */
+	ep = usb_ep_autoconfig(cdev->gadget, &dbdusb_fs_in_desc);
+	if (!ep)
+		goto fail;
+    ep->driver_data = cdev;
+	dbdusb->in_ep = ep;
+
+	ep = usb_ep_autoconfig(cdev->gadget, &dbdusb_fs_out_desc);
+	if (!ep)
+		goto fail;
+    ep->driver_data = cdev;
+	dbdusb->out_ep = ep;
+
+	ep = usb_ep_autoconfig(cdev->gadget, &dbdusb_fs_bulk_in_desc);
+	if (!ep)
+		goto fail;
+    ep->driver_data = cdev;
+	dbdusb->bulk_in_ep = ep;
+
+	/* copy descriptors, and track endpoint copies */
+	f->descriptors = usb_copy_descriptors(dbdusb_fs_function);
+
+	dbdusb->fs.in = usb_find_endpoint(dbdusb_fs_function,
+			f->descriptors, &dbdusb_fs_in_desc);
+	dbdusb->fs.out = usb_find_endpoint(dbdusb_fs_function,
+			f->descriptors, &dbdusb_fs_out_desc);
+	dbdusb->fs.bulk_in = usb_find_endpoint(dbdusb_fs_function,
+			f->descriptors, &dbdusb_fs_bulk_in_desc);
+
+
+	/* support all relevant hardware speeds... we expect that when
+	 * hardware is dual speed, all bulk-capable endpoints work at
+	 * both speeds
+	 */
+	if (gadget_is_dualspeed(c->cdev->gadget)) {
+		dbdusb_hs_in_desc.bEndpointAddress =
+				dbdusb_fs_in_desc.bEndpointAddress;
+		dbdusb_hs_out_desc.bEndpointAddress =
+				dbdusb_fs_out_desc.bEndpointAddress;
+		dbdusb_hs_bulk_in_desc.bEndpointAddress =
+				dbdusb_fs_bulk_in_desc.bEndpointAddress;
+
+		/* copy descriptors, and track endpoint copies */
+		f->hs_descriptors = usb_copy_descriptors(dbdusb_hs_function);
+
+		dbdusb->hs.in = usb_find_endpoint(dbdusb_hs_function,
+				f->hs_descriptors, &dbdusb_hs_in_desc);
+		dbdusb->hs.out = usb_find_endpoint(dbdusb_hs_function,
+				f->hs_descriptors, &dbdusb_hs_out_desc);
+		dbdusb->hs.bulk_in = usb_find_endpoint(dbdusb_hs_function,
+				f->hs_descriptors, &dbdusb_hs_bulk_in_desc);
+	}
+
+    /* create tasklet for allocating incoming messages */
+    // tasklet_init(&dbdusb->qmsg_tasklet, dbdusb_qmsg, (unsigned long)dbdusb);
+
+    /* initializate data for messages in transit */
+    dbdusb_create_message_queue(&dbdusb->writeq);
+    dbdusb_create_message_queue(&dbdusb->readq);
+
+    /* create device for userland access */
+    status = dbdusb_chrdev_create(dbdusb);
+    if (status < 0)
+        printk(KERN_ERR "dbdusb: couldn't create chrdev for access: error=%d\n", status);
+
+	DBG(cdev, "dbdusb: %s speed\n",
+			gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full");
+	return 0;
+
+fail:
+	ERROR(cdev, "%s: can't bind, err %d\n", f->name, status);
+
+	return status;
+}
+
+static void
+dbdusb_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct f_dbdusb *dbdusb = func_to_dbdusb(f);
+
+    dbdusb_chrdev_free(dbdusb);
+
+    // tasklet_kill(&dbdusb->qmsg_tasklet);
+
+	if (gadget_is_dualspeed(c->cdev->gadget))
+		usb_free_descriptors(f->hs_descriptors);
+	usb_free_descriptors(f->descriptors);
+	kfree(func_to_dbdusb(f));
+}
+
+/**
+ * dbdusb_bind_config - add dbdusb function to a configuration
+ * @c: the configuration to support the dbdusb instance
+ * Context: single threaded during gadget setup
+ *
+ * Returns zero on success, else negative errno.
+ *
+ */
+int __init dbdusb_bind_config(struct usb_configuration *c)
+{
+	struct f_dbdusb	*dbdusb;
+	int		status;
+
+	dbdusb = kzalloc(sizeof *dbdusb, GFP_KERNEL);
+	if (!dbdusb)
+		return -ENOMEM;
+
+	dbdusb->func.name = "dbdusb";
+	dbdusb->func.strings = dbdusb_strings;
+	dbdusb->func.bind = dbdusb_bind;
+	dbdusb->func.unbind = dbdusb_unbind;
+	dbdusb->func.set_alt = dbdusb_set_alt;
+	dbdusb->func.disable = dbdusb_disable;
+
+	status = usb_add_function(c, &dbdusb->func);
+	if (status)
+		kfree(dbdusb);
+
+	return status;
+}
diff --git a/drivers/diebold/linux-dbdusb/u_os_desc.h b/drivers/diebold/linux-dbdusb/u_os_desc.h
new file mode 100644
index 000000000..5d7d35c8c
--- /dev/null
+++ b/drivers/diebold/linux-dbdusb/u_os_desc.h
@@ -0,0 +1,120 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * u_os_desc.h
+ *
+ * Utility definitions for "OS Descriptors" support
+ *
+ * Copyright (c) 2014 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ *
+ * Author: Andrzej Pietrasiewicz <andrzejtp2010@gmail.com>
+ */
+
+#ifndef __U_OS_DESC_H__
+#define __U_OS_DESC_H__
+
+#include <asm/unaligned.h>
+#include <linux/nls.h>
+
+#define USB_EXT_PROP_DW_SIZE			0
+#define USB_EXT_PROP_DW_PROPERTY_DATA_TYPE	4
+#define USB_EXT_PROP_W_PROPERTY_NAME_LENGTH	8
+#define USB_EXT_PROP_B_PROPERTY_NAME		10
+#define USB_EXT_PROP_DW_PROPERTY_DATA_LENGTH	10
+#define USB_EXT_PROP_B_PROPERTY_DATA		14
+
+#define USB_EXT_PROP_RESERVED			0
+#define USB_EXT_PROP_UNICODE			1
+#define USB_EXT_PROP_UNICODE_ENV		2
+#define USB_EXT_PROP_BINARY			3
+#define USB_EXT_PROP_LE32			4
+#define USB_EXT_PROP_BE32			5
+#define USB_EXT_PROP_UNICODE_LINK		6
+#define USB_EXT_PROP_UNICODE_MULTI		7
+
+static inline u8 *__usb_ext_prop_ptr(u8 *buf, size_t offset)
+{
+	return buf + offset;
+}
+
+static inline u8 *usb_ext_prop_size_ptr(u8 *buf)
+{
+	return __usb_ext_prop_ptr(buf, USB_EXT_PROP_DW_SIZE);
+}
+
+static inline u8 *usb_ext_prop_type_ptr(u8 *buf)
+{
+	return __usb_ext_prop_ptr(buf, USB_EXT_PROP_DW_PROPERTY_DATA_TYPE);
+}
+
+static inline u8 *usb_ext_prop_name_len_ptr(u8 *buf)
+{
+	return __usb_ext_prop_ptr(buf, USB_EXT_PROP_W_PROPERTY_NAME_LENGTH);
+}
+
+static inline u8 *usb_ext_prop_name_ptr(u8 *buf)
+{
+	return __usb_ext_prop_ptr(buf, USB_EXT_PROP_B_PROPERTY_NAME);
+}
+
+static inline u8 *usb_ext_prop_data_len_ptr(u8 *buf, size_t off)
+{
+	return __usb_ext_prop_ptr(buf,
+				  USB_EXT_PROP_DW_PROPERTY_DATA_LENGTH + off);
+}
+
+static inline u8 *usb_ext_prop_data_ptr(u8 *buf, size_t off)
+{
+	return __usb_ext_prop_ptr(buf, USB_EXT_PROP_B_PROPERTY_DATA + off);
+}
+
+static inline void usb_ext_prop_put_size(u8 *buf, int dw_size)
+{
+	put_unaligned_le32(dw_size, usb_ext_prop_size_ptr(buf));
+}
+
+static inline void usb_ext_prop_put_type(u8 *buf, int type)
+{
+	put_unaligned_le32(type, usb_ext_prop_type_ptr(buf));
+}
+
+static inline int usb_ext_prop_put_name(u8 *buf, const char *name, int pnl)
+{
+	int result;
+
+	put_unaligned_le16(pnl, usb_ext_prop_name_len_ptr(buf));
+	result = utf8s_to_utf16s(name, strlen(name), UTF16_LITTLE_ENDIAN,
+		(wchar_t *) usb_ext_prop_name_ptr(buf), pnl - 2);
+	if (result < 0)
+		return result;
+
+	put_unaligned_le16(0, &buf[USB_EXT_PROP_B_PROPERTY_NAME + pnl - 2]);
+
+	return pnl;
+}
+
+static inline void usb_ext_prop_put_binary(u8 *buf, int pnl, const u8 *data,
+					   int data_len)
+{
+	put_unaligned_le32(data_len, usb_ext_prop_data_len_ptr(buf, pnl));
+	memcpy(usb_ext_prop_data_ptr(buf, pnl), data, data_len);
+}
+
+static inline int usb_ext_prop_put_unicode(u8 *buf, int pnl, const char *string,
+					   int data_len)
+{
+	int result;
+	put_unaligned_le32(data_len, usb_ext_prop_data_len_ptr(buf, pnl));
+	result = utf8s_to_utf16s(string, data_len >> 1, UTF16_LITTLE_ENDIAN,
+			(wchar_t *) usb_ext_prop_data_ptr(buf, pnl),
+			data_len - 2);
+	if (result < 0)
+		return result;
+
+	put_unaligned_le16(0,
+		&buf[USB_EXT_PROP_B_PROPERTY_DATA + pnl + data_len - 2]);
+
+	return data_len;
+}
+
+#endif /* __U_OS_DESC_H__ */
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index f1a60de49..e51ae4071 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -312,6 +312,15 @@ config DRM_PANEL_ORISETECH_OTM8009A
 	  Say Y here if you want to enable support for Orise Technology
 	  otm8009a 480x800 dsi 2dl panel.
 
+# Add for create card device DRM
+config DRM_PANEL_DIEBOLD_OP7
+	tristate "Diebold display OP7 1024x600 dsi to edp panel"
+	depends on OF
+	depends on DRM_MIPI_DSI
+	help
+	  Say Y here if you want to enable support for Diebold display 
+	  OP7 1024x600 dsi to edp panel.
+
 config DRM_PANEL_OSD_OSD101T2587_53TS
 	tristate "OSD OSD101T2587-53TS DSI 1920x1200 video mode panel"
 	depends on OF
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 57d794897..7c3f63fc0 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -30,6 +30,10 @@ obj-$(CONFIG_DRM_PANEL_NOVATEK_NT39016) += panel-novatek-nt39016.o
 obj-$(CONFIG_DRM_PANEL_MANTIX_MLAF057WE51) += panel-mantix-mlaf057we51.o
 obj-$(CONFIG_DRM_PANEL_OLIMEX_LCD_OLINUXINO) += panel-olimex-lcd-olinuxino.o
 obj-$(CONFIG_DRM_PANEL_ORISETECH_OTM8009A) += panel-orisetech-otm8009a.o
+
+# Add for create card device DRM
+obj-$(CONFIG_DRM_PANEL_DIEBOLD_OP7) += panel-diebold-op7.o
+
 obj-$(CONFIG_DRM_PANEL_OSD_OSD101T2587_53TS) += panel-osd-osd101t2587-53ts.o
 obj-$(CONFIG_DRM_PANEL_PANASONIC_VVX10F034N00) += panel-panasonic-vvx10f034n00.o
 obj-$(CONFIG_DRM_PANEL_RASPBERRYPI_TOUCHSCREEN) += panel-raspberrypi-touchscreen.o
diff --git a/drivers/gpu/drm/panel/panel-diebold-op7.c b/drivers/gpu/drm/panel/panel-diebold-op7.c
new file mode 100644
index 000000000..0b0dcccbd
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-diebold-op7.c
@@ -0,0 +1,237 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * HUB - LSE 
+ * Authors: Matheus Assuncao
+ *          Mateus Pantoja
+ */
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+
+struct diebold_op7 {
+	struct device *dev;
+	struct drm_panel panel;
+	struct regulator *supply;
+	bool prepared;
+	bool enabled;
+};
+
+static const struct drm_display_mode modes[] = {
+	{ /* 51 Hz */
+		.clock = 33000,
+		.hdisplay = 1024,
+		.hsync_start = 1024 + 46,
+		.hsync_end = 1024 + 46 + 80,
+		.htotal = 1024 + 46 + 80 + 100,
+		.vdisplay = 600,
+		.vsync_start = 600 + 5,
+		.vsync_end = 600 + 5 + 5,
+		.vtotal = 600 + 5 + 5 + 20,
+		.flags = DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC,
+		.width_mm = 52,
+		.height_mm = 86,
+	},
+};
+
+static inline struct diebold_op7 *panel_to_diebold_op7(struct drm_panel *panel)
+{
+	return container_of(panel, struct diebold_op7, panel);
+}
+
+static int diebold_op7_disable(struct drm_panel *panel)
+{
+	struct diebold_op7 *ctx = panel_to_diebold_op7(panel);
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+	int ret;
+
+	if (!ctx->enabled)
+		return 0; /* This is not an issue so we return 0 here */
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret)
+		return ret;
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret)
+		return ret;
+
+	msleep(120);
+
+	ctx->enabled = false;
+
+	return 0;
+}
+
+static int diebold_op7_unprepare(struct drm_panel *panel)
+{
+	struct diebold_op7 *ctx = panel_to_diebold_op7(panel);
+
+	if (!ctx->prepared)
+		return 0;
+
+	regulator_disable(ctx->supply);
+
+	ctx->prepared = false;
+
+	return 0;
+}
+
+static int diebold_op7_prepare(struct drm_panel *panel)
+{
+	struct diebold_op7 *ctx = panel_to_diebold_op7(panel);
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(panel->dev, "failed to enable supply: %d\n", ret);
+		return ret;
+	}
+
+	ctx->prepared = true;
+
+	return 0;
+}
+
+static int diebold_op7_enable(struct drm_panel *panel)
+{
+	struct diebold_op7 *ctx = panel_to_diebold_op7(panel);
+
+	if (ctx->enabled)
+		return 0;
+
+	ctx->enabled = true;
+
+	return 0;
+}
+
+static int diebold_op7_get_modes(struct drm_panel *panel,
+			      struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+	unsigned int num_modes = ARRAY_SIZE(modes);
+	unsigned int i;
+
+	for (i = 0; i < num_modes; i++) {
+		mode = drm_mode_duplicate(connector->dev, &modes[i]);
+		if (!mode) {
+			dev_err(panel->dev, "failed to add mode %ux%u@%u\n",
+				modes[i].hdisplay,
+				modes[i].vdisplay,
+				drm_mode_vrefresh(&modes[i]));
+			return -ENOMEM;
+		}
+
+		mode->type = DRM_MODE_TYPE_DRIVER;
+
+		/* Setting first mode as preferred */
+		if (!i)
+			mode->type |=  DRM_MODE_TYPE_PREFERRED;
+
+		drm_mode_set_name(mode);
+		drm_mode_probed_add(connector, mode);
+	}
+
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	connector->display_info.bus_flags = DRM_BUS_FLAG_DE_HIGH |
+					    DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE;
+
+	return num_modes;
+}
+
+static const struct drm_panel_funcs diebold_op7_drm_funcs = {
+	.disable   = diebold_op7_disable,
+	.unprepare = diebold_op7_unprepare,
+	.prepare   = diebold_op7_prepare,
+	.enable    = diebold_op7_enable,
+	.get_modes = diebold_op7_get_modes,
+};
+
+
+static int diebold_op7_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct diebold_op7 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply)) {
+		ret = PTR_ERR(ctx->supply);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "failed to request regulator: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	ctx->dev = dev;
+
+	dsi->lanes = 2;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST | MIPI_DSI_MODE_LPM;
+
+	drm_panel_init(&ctx->panel, dev, &diebold_op7_drm_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "mipi_dsi_attach failed. Is host ready?\n");
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int diebold_op7_remove(struct mipi_dsi_device *dsi)
+{
+	struct diebold_op7 *ctx = mipi_dsi_get_drvdata(dsi);
+
+	mipi_dsi_detach(dsi);
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id diebold_op7_of_match[] = {
+	{ .compatible = "diebold,op7" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, diebold_op7_of_match);
+
+static struct mipi_dsi_driver diebold_op7_driver = {
+	.probe  = diebold_op7_probe,
+	.remove = diebold_op7_remove,
+	.driver = {
+		.name = "panel-diebold-op7",
+		.of_match_table = diebold_op7_of_match,
+	},
+};
+module_mipi_dsi_driver(diebold_op7_driver);
+
+MODULE_AUTHOR("Matheus Assuncao");
+MODULE_AUTHOR("Mateus Pantoja");
+MODULE_DESCRIPTION("DRM driver for Diebold display op7 dsi to edp panel");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/stm/1024x600-45M_160_DSI-Chris_42000.txt b/drivers/gpu/drm/stm/1024x600-45M_160_DSI-Chris_42000.txt
new file mode 100644
index 000000000..c8171224d
--- /dev/null
+++ b/drivers/gpu/drm/stm/1024x600-45M_160_DSI-Chris_42000.txt
@@ -0,0 +1,129 @@
+//Setup Main Link
+i2c1_d2dp_write( 0x06A0,0x11113081); //DP0_SrcCtrl
+i2c1_d2dp_write( 0x07A0,0x11113000); //DP1_SrcCtrl
+i2c1_d2dp_write( 0x0918,0x00000301); //SYS_PLLPARAM
+//DP-PHY/PLLs
+i2c1_d2dp_write( 0x0800,0x03000003); //DP_PHY_CTRL
+i2c1_d2dp_write( 0x0900,0x00000005); //DP0_PLLCTRL
+Waitx1ms(10);
+i2c1_d2dp_write( 0x0904,0x00000005); //DP1_PLLCTRL
+Waitx1ms(10);
+i2c1_d2dp_write( 0x0914,0x00338D21); //PXL_PLLPARAM
+i2c1_d2dp_write( 0x0908,0x00000005); //PXL_PLLCTRL
+Waitx1ms(1);
+//DSI RD LPTX setting
+i2c1_d2dp_write( 0x013C,0x00050006); //PPI_TX_RX_TA
+i2c1_d2dp_write( 0x0114,0x00000004); //PPI_LPTXTIMECNT
+//Device ID RD
+i2c1_d2dp_read( 0x0500); //IDREG
+//Reset/Enable Main Link(s)
+i2c1_d2dp_write( 0x0800,0x13001103); //DP_PHY_CTRL
+i2c1_d2dp_write( 0x0800,0x03000003); //DP_PHY_CTRL
+Waitx1ms(35);
+i2c1_d2dp_read( 0x0800); //DP_PHY_CTRL
+//Read DP Rx Link Capability
+i2c1_d2dp_write( 0x0664,0x0001063F); //DP0_AuxCfg1
+i2c1_d2dp_write( 0x0668,0x00000000); //DP0_AuxAddr
+i2c1_d2dp_write( 0x0660,0x00000209); //DP0_AuxCfg0
+Waitx1ms(1);
+i2c1_d2dp_read( 0x068C); //DP0_AuxStatus
+i2c1_d2dp_read( 0x067C); //DP0_AuxRData0
+//Set Link Rate and Lane Count (DPCD 00100h,00101h)
+i2c1_d2dp_write( 0x0668,0x00000100); //DP0_AuxAddr
+i2c1_d2dp_write( 0x066C,0x00000106); //DP0_AuxWData0
+i2c1_d2dp_write( 0x0660,0x00000108); //DP0_AuxCfg0
+//Set Main Link Channel Coding (DPCD 00108h)
+i2c1_d2dp_write( 0x0668,0x00000108); //DP0_AuxAddr
+i2c1_d2dp_write( 0x066C,0x00000001); //DP0_AuxWData0
+i2c1_d2dp_write( 0x0660,0x00000008); //DP0_AuxCfg0
+//Write DPCD 00103h~00104h before Training Pat1
+i2c1_d2dp_write( 0x0668,0x00000103); //DP0_AuxAddr
+i2c1_d2dp_write( 0x066C,0x00000001); //DP0_AuxWData0
+i2c1_d2dp_write( 0x0660,0x00000108); //DP0_AuxCfg0
+//Set DPCD 00102h for Training Pat 1
+i2c1_d2dp_write( 0x06E4,0x00000021); //DP0_SnkLTCtrl
+i2c1_d2dp_write( 0x06D8,0xF500002A); //DP0_LTLoopCtrl
+//Set DP0 Trainin Pattern 1
+i2c1_d2dp_write( 0x06A0,0x01013080); //DP0_SrcCtrl
+i2c1_d2dp_write( 0x06A0,0x01013181); //DP0_SrcCtrl
+//Enable DP0 to start Link Training
+i2c1_d2dp_write( 0x0600,0x00000001); //DP0Ctl
+Waitx1ms(10);
+i2c1_d2dp_read( 0x06D0); //DP0_LTStat
+//Set DPCD 00102h for Link Traing Pat 2
+i2c1_d2dp_write( 0x06E4,0x00000022); //DP0_SnkLTCtrl
+//Write DPCD 00103h~00104h before Training Pat2
+i2c1_d2dp_write( 0x0668,0x00000103); //DP0_AuxAddr
+i2c1_d2dp_write( 0x066C,0x00000009); //DP0_AuxWData0
+i2c1_d2dp_write( 0x0660,0x00000108); //DP0_AuxCfg0
+//Set DP0 Trainin Pattern 2
+i2c1_d2dp_write( 0x06A0,0x11113080); //DP0_SrcCtrl
+i2c1_d2dp_write( 0x06A0,0x11113281); //DP0_SrcCtrl
+Waitx1ms(10);
+i2c1_d2dp_read( 0x06D0); //DP0_LTStat
+//Clear DP0 Trainin Pattern
+i2c1_d2dp_write( 0x06A0,0x11111081); //DP0_SrcCtrl
+//Clear DPCD 00102h
+i2c1_d2dp_write( 0x0668,0x00000102); //AuxAddr
+i2c1_d2dp_write( 0x066C,0x00000000); //AuxWData0
+i2c1_d2dp_write( 0x0660,0x00000008); //AuxCfg0
+//Read DPCD 00200h-00206h
+i2c1_d2dp_write( 0x0668,0x00000200); //DP0_AuxAddr
+i2c1_d2dp_write( 0x0660,0x00000609); //DP0_AuxCfg0
+Waitx1ms(1);
+i2c1_d2dp_read( 0x068C); //DP0_AuxStatus
+i2c1_d2dp_read( 0x067C); //DP0_AuxRData0
+i2c1_d2dp_read( 0x0680); //DP0_AuxRData1
+//Write DPCD 0010Ah (ASSR, Enhanced Framing)
+i2c1_d2dp_write( 0x0668,0x0000010A); //AuxAddr
+i2c1_d2dp_write( 0x066C,0x00000000); //AuxWData0
+i2c1_d2dp_write( 0x0660,0x00000008); //AuxCfg0
+//Write DPCD 00107h (SSCG)
+i2c1_d2dp_write( 0x0668,0x00000107); //AuxAddr
+i2c1_d2dp_write( 0x066C,0x00000000); //AuxWData0
+i2c1_d2dp_write( 0x0660,0x00000008); //AuxCfg0
+//Read DPCD 00100h-00106h
+i2c1_d2dp_write( 0x0668,0x00000100); //DP0_AuxAddr
+i2c1_d2dp_write( 0x0660,0x00000609); //DP0_AuxCfg0
+Waitx1ms(1);
+i2c1_d2dp_read( 0x068C); //DP0_AuxStatus
+i2c1_d2dp_read( 0x067C); //DP0_AuxRData0
+i2c1_d2dp_read( 0x0680); //DP0_AuxRData1
+i2c1_d2dp_write( 0x013C,0x00050006); //PPI_TX_RX_TA
+i2c1_d2dp_write( 0x0114,0x00000004); //PPI_LPTXTIMECNT
+i2c1_d2dp_write( 0x0164,0x00000003); //CLRSIPOCOUNT
+i2c1_d2dp_write( 0x0168,0x00000003); //CLRSIPOCOUNT
+i2c1_d2dp_write( 0x016C,0x00000003); //CLRSIPOCOUNT
+i2c1_d2dp_write( 0x0170,0x00000003); //CLRSIPOCOUNT
+i2c1_d2dp_write( 0x0134,0x00000007); //PPI_LANEENABLE
+i2c1_d2dp_write( 0x0210,0x00000007); //DSI_LANEENABLE
+i2c1_d2dp_write( 0x0104,0x00000001); //PPI_STARTPPI
+i2c1_d2dp_write( 0x0204,0x00000001); //DSI_STARTDSI
+//LCD Ctl Frame Size
+i2c1_d2dp_write( 0x0450,0x01400100); //VPCTRL0
+i2c1_d2dp_write( 0x0454,0x00140002); //HTIM01
+i2c1_d2dp_write( 0x0458,0x000A0400); //HTIM02
+i2c1_d2dp_write( 0x045C,0x000A000A); //VTIM01
+i2c1_d2dp_write( 0x0460,0x000A0258); //VTIM02
+i2c1_d2dp_write( 0x0464,0x00000001); //VFUEN0
+//DP Main Stream Attirbutes
+i2c1_d2dp_write( 0x0644,0x003E0416); //DP0_VidSyncDly
+i2c1_d2dp_write( 0x0648,0x02760420); //DP0_TotalVal
+i2c1_d2dp_write( 0x064C,0x00140016); //DP0_StartVal
+i2c1_d2dp_write( 0x0650,0x02580400); //DP0_ActiveVal
+i2c1_d2dp_write( 0x0654,0x800A8002); //DP0_SyncVal
+//DP Flow Shape & TimeStamp
+i2c1_d2dp_write( 0x0658,0x1F3F0020); //DP0_Misc
+//Nvid/Mvid setting
+i2c1_d2dp_write( 0x0610,0x000096D2); //DP0_Vid_fM
+i2c1_d2dp_write( 0x0614,0x0002E464); //DP0_Vid_N
+//Enable Video and DP link
+i2c1_d2dp_write( 0x0600,0x00000041); //DP0Ctl
+i2c1_d2dp_write( 0x0600,0x00000043); //DP0Ctl
+i2c1_d2dp_write( 0x0510,0x00000001); //SYSCTRL
+Waitx1ms(1);
+i2c1_d2dp_read( 0x0610); //DP0_Vid_fM
+i2c1_d2dp_read( 0x0614); //DP0_Vid_N
+i2c1_d2dp_read( 0x0618); //DP0_Vid_M
+i2c1_d2dp_read( 0x0508); //SYSSTAT
+i2c1_d2dp_read( 0x0220); //DSI_INTSTATUS
diff --git a/drivers/gpu/drm/stm/dw_mipi_dsi-stm.c b/drivers/gpu/drm/stm/dw_mipi_dsi-stm.c
index 89897d5f5..55b8a447a 100644
--- a/drivers/gpu/drm/stm/dw_mipi_dsi-stm.c
+++ b/drivers/gpu/drm/stm/dw_mipi_dsi-stm.c
@@ -19,6 +19,8 @@
 #include <drm/drm_mipi_dsi.h>
 #include <drm/drm_print.h>
 
+#include <linux/gpio/consumer.h>
+
 #define HWVER_130			0x31333000	/* IP version 1.30 */
 #define HWVER_131			0x31333100	/* IP version 1.31 */
 
@@ -82,6 +84,9 @@ struct dw_mipi_dsi_stm {
 	int lane_min_kbps;
 	int lane_max_kbps;
 	struct regulator *vdd_supply;
+
+	//Add for reset toshiba tc358867 pin
+	struct gpio_desc *reset_gpio;
 };
 
 static inline void dsi_write(struct dw_mipi_dsi_stm *dsi, u32 reg, u32 val)
@@ -196,6 +201,7 @@ static int dsi_pll_get_params(struct dw_mipi_dsi_stm *dsi,
 
 static int dw_mipi_dsi_phy_init(void *priv_data)
 {
+	printk("dw_mipi_dsi_phy_init\n");
 	struct dw_mipi_dsi_stm *dsi = priv_data;
 	u32 val;
 	int ret;
@@ -220,11 +226,22 @@ static int dw_mipi_dsi_phy_init(void *priv_data)
 static void dw_mipi_dsi_phy_power_on(void *priv_data)
 {
 	struct dw_mipi_dsi_stm *dsi = priv_data;
-
+	printk("dw_mipi_dsi_phy_power_on\n");
 	DRM_DEBUG_DRIVER("\n");
 
 	/* Enable the DSI wrapper */
 	dsi_set(dsi, DSI_WCR, WCR_DSIEN);
+
+	//========= Reset Toshiba TC358867 ==============
+	if (dsi->reset_gpio) {
+		gpiod_set_value_cansleep(dsi->reset_gpio, 0);
+		gpiod_set_value_cansleep(dsi->reset_gpio, 1);
+		msleep(20);
+		gpiod_set_value_cansleep(dsi->reset_gpio, 0);
+	}
+	// msleep(2000);
+	// tc358867_configure_weston();
+	//===============================================
 }
 
 static void dw_mipi_dsi_phy_power_off(void *priv_data)
@@ -498,6 +515,16 @@ static int dw_mipi_dsi_stm_probe(struct platform_device *pdev)
 		goto err_dsi_probe;
 	}
 
+	//===== Get pin for reset Toshiba TC358867 ======
+	dsi->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(dsi->reset_gpio)) {
+		ret = PTR_ERR(dsi->reset_gpio);
+		if (ret != -EPROBE_DEFER)
+			DRM_ERROR("cannot get reset GPIO: %d\n", ret);
+		return ret;
+	}
+	//===============================================
+
 	dsi->hw_version = dsi_read(dsi, DSI_VERSION) & VERSION;
 	clk_disable_unprepare(pclk);
 
@@ -562,6 +589,7 @@ static int __maybe_unused dw_mipi_dsi_stm_suspend(struct device *dev)
 
 static int __maybe_unused dw_mipi_dsi_stm_resume(struct device *dev)
 {
+	printk("dw_mipi_dsi_phy_init\n");
 	struct dw_mipi_dsi_stm *dsi = dw_mipi_dsi_stm_plat_data.priv_data;
 	int ret;
 
diff --git a/drivers/pinctrl/Kconfig b/drivers/pinctrl/Kconfig
index 31921108e..366473621 100644
--- a/drivers/pinctrl/Kconfig
+++ b/drivers/pinctrl/Kconfig
@@ -196,6 +196,18 @@ config PINCTRL_MCP23S08
 	  This provides a GPIO interface supporting inputs and outputs and a
 	  corresponding interrupt-controller.
 
+
+config PINCTRL_MCP_DN_SOM
+	tristate "STM32G0 I/O expander"
+	depends on I2C
+	select GPIOLIB
+	select GPIOLIB_IRQCHIP
+	select GENERIC_PINCONF
+	help
+		I2C driver for STM32G0 I/O expanders.
+		This provides a GPIO interface supporting inputs and outputs and a
+		corresponding interrupt-controller.
+
 config PINCTRL_OXNAS
 	bool
 	depends on OF
diff --git a/drivers/pinctrl/Makefile b/drivers/pinctrl/Makefile
index 200073bcc..dfc1b13ec 100644
--- a/drivers/pinctrl/Makefile
+++ b/drivers/pinctrl/Makefile
@@ -24,6 +24,9 @@ obj-$(CONFIG_PINCTRL_MAX77620)	+= pinctrl-max77620.o
 obj-$(CONFIG_PINCTRL_MCP23S08_I2C)	+= pinctrl-mcp23s08_i2c.o
 obj-$(CONFIG_PINCTRL_MCP23S08_SPI)	+= pinctrl-mcp23s08_spi.o
 obj-$(CONFIG_PINCTRL_MCP23S08)	+= pinctrl-mcp23s08.o
+
+obj-$(CONFIG_PINCTRL_MCP_DN_SOM)	+= pinctrl-mcp-dn-som.o
+
 obj-$(CONFIG_PINCTRL_MESON)	+= meson/
 obj-$(CONFIG_PINCTRL_OXNAS)	+= pinctrl-oxnas.o
 obj-$(CONFIG_PINCTRL_PALMAS)	+= pinctrl-palmas.o
diff --git a/drivers/pinctrl/pinctrl-mcp-dn-som.c b/drivers/pinctrl/pinctrl-mcp-dn-som.c
new file mode 100644
index 000000000..2c3839b39
--- /dev/null
+++ b/drivers/pinctrl/pinctrl-mcp-dn-som.c
@@ -0,0 +1,417 @@
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+
+#define DRIVER_NAME "expansor-gpio"
+#define I2C_DEVICE_ADDRESS 0x2a
+#define NUM_GPIOS_GROUP_A 16
+#define NUM_GPIOS_GROUP_B 10
+
+#define EXP_WRITE   0x00
+#define EXP_READ    0x01
+
+#define EXP_IO_DIR_A_REG    0x00
+#define EXP_IO_GPIO_A_REG   0x0f
+#define EXP_IO_DIR_B_REG    0x01
+#define EXP_IO_GPIO_B_REG   0x10
+
+static struct i2c_adapter *i2c_adap;
+static struct i2c_client *i2c_client;
+static struct gpio_chip dn_som_chip_group_a, dn_som_chip_group_b;
+
+// Vetor para armazenar o estado dos pinos do expansor
+static u16 gpio_states, gpio_values, gpio_states2, gpio_values2;
+
+/**
+ *  Grupo de Gpio A do expansor DN-SOM
+*/
+
+/**
+ * @brief Function that sets a value in gpio in group A
+*/
+void mcp_dn_som_set_value_group_a(struct gpio_chip *chip, unsigned int gpio, int value)
+{
+	int ret;
+    
+    if (value)
+        gpio_values |= (1 << gpio);
+    else
+        gpio_values &= ~(1 << gpio);
+
+    uint8_t buf [3];
+
+    buf[0] = EXP_IO_GPIO_A_REG;
+    buf[1] = gpio_values >> 8 & 0xFF;
+    buf[2] = gpio_values & 0xFF;
+
+    ret = i2c_smbus_write_i2c_block_data(i2c_client, EXP_WRITE, sizeof(buf), buf);
+
+    if (ret < 0)
+        printk(KERN_ERR "Erro ao escrever no gpio %d \n", gpio);
+}
+
+/**
+ * @brief Function that performs a reading on a gpio in group A
+*/
+static int mcp_dn_som_get_value_group_a(struct gpio_chip *chip, unsigned int gpio)
+{
+
+    int ret, result;
+    uint8_t buf[4];
+    buf[0] = EXP_READ;
+    buf[1] = EXP_IO_GPIO_A_REG;
+
+    ret = i2c_master_send(i2c_client, buf, 4);
+
+    if (ret < 0)
+        printk(KERN_ERR "Erro ao solicitar a leitura - %d\n", ret);
+    
+    ret = i2c_master_recv(i2c_client, &(buf[0]), 4);
+
+    if (ret < 0)
+        printk(KERN_ERR "Retorno ao solicitar a leitura - %d\n", ret);
+
+    gpio_values = ((buf[1] << 8) & 0xff00) | (buf[0] & 0x00ff);
+
+    result = (gpio_values >> gpio) & 0x01;
+
+    return result;
+}
+
+/**
+ * @brief Function that sets as output gpio in group A
+*/
+static int mcp_dn_som_output_state_group_a(struct gpio_chip *chip, unsigned int gpio, int value)
+{
+    int ret;
+    
+    gpio_states |= (1 << gpio);
+    uint8_t buf [3];
+
+    buf[0] = EXP_IO_DIR_A_REG;
+    buf[1] = gpio_states >> 8 & 0xFF;
+    buf[2] = gpio_states & 0xFF;
+
+    ret = i2c_smbus_write_i2c_block_data(i2c_client, EXP_WRITE, sizeof(buf), buf);
+
+    if (ret < 0)
+        printk(KERN_ERR "Erro ao configurar o pino %d como saída\n", gpio);
+
+    mcp_dn_som_set_value_group_a(chip, gpio, value);
+
+    return 0;
+}
+
+/**
+ * @brief Function that sets as input gpio in group A
+*/
+static int mcp_dn_som_input_state_group_a(struct gpio_chip *chip, unsigned int gpio)
+{
+    int ret;
+    uint8_t buf [3];
+    
+    gpio_states &= ~(1 << gpio);
+ 
+    buf[0] = EXP_IO_DIR_A_REG;
+    buf[1] = gpio_states >> 8 & 0xFF;
+    buf[2] = gpio_states & 0xFF;
+
+    ret = i2c_smbus_write_i2c_block_data(i2c_client, EXP_WRITE, sizeof(buf), buf);
+
+    if (ret < 0)
+        printk(KERN_ERR "Erro ao configurar o pino %d como entrada\n", gpio);
+
+    return 0;
+}
+
+/**
+ *  Grupo de Gpio B do expansor DN-SOM
+*/
+
+/**
+ * @brief Function that sets a value in gpio in group B
+*/
+void mcp_dn_som_set_value_group_b(struct gpio_chip *chip, unsigned int gpio, int value)
+{
+	int ret;
+    
+    if (value)
+        gpio_values2 |= (1 << gpio);
+    else
+        gpio_values2 &= ~(1 << gpio);
+
+    uint8_t buf [3];
+
+    buf[0] = EXP_IO_GPIO_B_REG;
+    buf[1] = gpio_values2 >> 8 & 0xFF;
+    buf[2] = gpio_values2 & 0xFF;
+
+    ret = i2c_smbus_write_i2c_block_data(i2c_client, EXP_WRITE, sizeof(buf), buf);
+
+    if (ret < 0)
+        printk(KERN_ERR "Erro ao escrever no gpio %d \n", gpio);
+}
+
+/**
+ * @brief Function that performs a reading on a gpio in group B
+*/
+static int mcp_dn_som_get_value_group_b(struct gpio_chip *chip, unsigned int gpio)
+{
+
+    int ret, result;
+    uint8_t buf[4];
+    buf[0] = EXP_READ;
+    buf[1] = EXP_IO_GPIO_B_REG;
+
+    ret = i2c_master_send(i2c_client, buf, 4);
+    if (ret < 0)
+        printk(KERN_ERR "Erro ao solicitar a leitura - %d do grupo B\n", ret);
+    
+    ret = i2c_master_recv(i2c_client, &(buf[0]), 4);
+    if (ret < 0)
+        printk(KERN_ERR "Retorno ao solicitar a leitura - %d do grupo B\n", ret);
+
+    gpio_values2 = ((buf[1] << 8) & 0xff00) | (buf[0] & 0x00ff);
+
+    result = (gpio_values2 >> gpio) & 0x01;
+
+    return result;
+}
+
+/**
+ * @brief Function that sets as output gpio in group B
+*/
+static int mcp_dn_som_output_state_group_b(struct gpio_chip *chip, unsigned int gpio, int value)
+{
+    int ret;
+    unsigned long flags;
+
+    gpio_states2 |= (1 << gpio);
+    uint8_t buf [3];
+
+    buf[0] = EXP_IO_DIR_B_REG;
+    buf[1] = gpio_states2 >> 8 & 0xFF;
+    buf[2] = gpio_states2 & 0xFF;
+
+    ret = i2c_smbus_write_i2c_block_data(i2c_client, EXP_WRITE, sizeof(buf), buf);
+
+    if (ret < 0)
+        printk(KERN_ERR "Erro ao configurar o pino %d como saída\n", gpio);
+
+    mcp_dn_som_set_value_group_b(chip, gpio, value);
+
+
+    return 0;
+}
+
+/**
+ * @brief Function that sets as input gpio in group B
+*/
+static int mcp_dn_som_input_state_group_b(struct gpio_chip *chip, unsigned int gpio)
+{
+    int ret;
+    uint8_t buf [3];
+    
+    gpio_states2 &= ~(1 << gpio);
+
+    buf[0] = EXP_IO_DIR_B_REG;
+    buf[1] = gpio_states2 >> 8 & 0xFF;
+    buf[2] = gpio_states2 & 0xFF;
+
+    ret = i2c_smbus_write_i2c_block_data(i2c_client, EXP_WRITE, sizeof(buf), buf);
+
+    if (ret < 0)
+        printk(KERN_ERR "Erro ao configurar o pino %d como entrada\n", gpio);
+
+    return 0;
+}
+
+/**
+ * @brief Gpio A group initialization function
+*/
+void mcp_dn_som_init_group_a(struct i2c_client *client)
+{
+    int ret;
+    uint8_t buf[3];
+
+    // Salva o cliente do dispositivo I2C
+    i2c_client = client;
+
+    // Configura o dispositivo para o endereço desejado
+    i2c_client->addr = I2C_DEVICE_ADDRESS;
+    
+    gpio_states = 0x0000;
+    gpio_values = 0xFFFF;
+
+    //Configura como entrada
+    buf[0] = EXP_IO_DIR_A_REG;
+    buf[1] = gpio_states >> 8 & 0xFF;
+    buf[2] = gpio_states & 0xFF;
+
+    ret = i2c_smbus_write_i2c_block_data(i2c_client, EXP_WRITE, sizeof(buf), buf);
+
+    //Configura como nível alto
+    buf[0] = EXP_IO_GPIO_A_REG;
+    buf[1] = gpio_values >> 8 & 0xFF;
+    buf[2] = gpio_values & 0xFF;
+
+    ret = i2c_smbus_write_i2c_block_data(i2c_client, EXP_WRITE, sizeof(buf), buf);
+}
+
+/**
+ * @brief Gpio B group initialization function
+*/
+void mcp_dn_som_init_group_b(struct i2c_client *client)
+{
+    int ret;
+    uint8_t buf[3];
+
+    // Salva o cliente do dispositivo I2C
+    i2c_client = client;
+
+    // Configura o dispositivo para o endereço desejado
+    i2c_client->addr = I2C_DEVICE_ADDRESS;    
+
+    gpio_states2 = 0x0000;
+    gpio_values2 = 0xFFFF;
+
+    //Configura como entrada
+    buf[0] = EXP_IO_DIR_B_REG;
+    buf[1] = gpio_states2 >> 8 & 0xFF;
+    buf[2] = gpio_states2 & 0xFF;
+
+    ret = i2c_smbus_write_i2c_block_data(i2c_client, EXP_WRITE, sizeof(buf), buf);
+
+    //Configura como nível alto
+    buf[0] = EXP_IO_GPIO_B_REG;
+    buf[1] = gpio_values2 >> 8 & 0xFF;
+    buf[2] = gpio_values2 & 0xFF;
+
+    ret = i2c_smbus_write_i2c_block_data(i2c_client, EXP_WRITE, sizeof(buf), buf);
+
+}
+
+
+static int mcp_dn_som_probe(struct i2c_client *client,
+                                 const struct i2c_device_id *id)
+{
+    int ret;
+
+    // Configura a estrutura do gpio_chip
+    dn_som_chip_group_a.label = DRIVER_NAME;
+    dn_som_chip_group_a.base = -1;
+    dn_som_chip_group_a.ngpio = NUM_GPIOS_GROUP_A;
+    dn_som_chip_group_a.parent = NULL;
+    dn_som_chip_group_a.owner = THIS_MODULE;
+    dn_som_chip_group_a.can_sleep = true;
+    dn_som_chip_group_a.direction_input = mcp_dn_som_input_state_group_a;
+    dn_som_chip_group_a.direction_output = mcp_dn_som_output_state_group_a;
+    dn_som_chip_group_a.get = mcp_dn_som_get_value_group_a;
+    dn_som_chip_group_a.set = mcp_dn_som_set_value_group_a;
+    dn_som_chip_group_a.request = NULL;
+    dn_som_chip_group_a.free = NULL;
+
+    // Configura a estrutura do gpio_chip
+    dn_som_chip_group_b.label = DRIVER_NAME;
+    dn_som_chip_group_b.base = -1;
+    dn_som_chip_group_b.ngpio = NUM_GPIOS_GROUP_B;
+    dn_som_chip_group_b.parent = NULL;
+    dn_som_chip_group_b.owner = THIS_MODULE;
+    dn_som_chip_group_b.can_sleep = true;
+    dn_som_chip_group_b.direction_input = mcp_dn_som_input_state_group_b;
+    dn_som_chip_group_b.direction_output = mcp_dn_som_output_state_group_b;
+    dn_som_chip_group_b.get = mcp_dn_som_get_value_group_b;
+    dn_som_chip_group_b.set = mcp_dn_som_set_value_group_b;
+    dn_som_chip_group_b.request = NULL;
+    dn_som_chip_group_b.free = NULL;
+
+    mcp_dn_som_init_group_a(client);
+    mcp_dn_som_init_group_b(client);
+
+    ret = gpiochip_add_data(&dn_som_chip_group_a, NULL);
+
+    if (ret) {
+        printk(KERN_ERR "Erro ao registrar gpio_chip \n");
+        return ret;
+    }
+
+    ret = gpiochip_add_data(&dn_som_chip_group_b, NULL);
+
+    if (ret) {
+        printk(KERN_ERR "Erro ao registrar gpio_chip2 \n");
+        return ret;
+    }
+
+    printk(KERN_INFO "Probe do driver do expansor de GPIO\n");
+
+    return 0;
+}
+
+static int mcp_dn_som_remove(struct i2c_client *client)
+{
+    // Remove o gpio_chip
+    gpiochip_remove(&dn_som_chip_group_a);
+    gpiochip_remove(&dn_som_chip_group_b);
+
+    printk(KERN_INFO "Remoção do driver do expansor de GPIO\n");
+
+    return 0;
+}
+
+
+// IDs do dispositivo I2C suportados pelo driver
+static const struct i2c_device_id mcp_dn_som_id[] = {
+    { "expansor-gpio", (kernel_ulong_t)0x2a },
+    { },
+};
+
+MODULE_DEVICE_TABLE(i2c, mcp_dn_som_id);
+
+// Estrutura que descreve o driver
+static struct i2c_driver mcp_dn_som_driver = {
+    .driver = {
+        .name = DRIVER_NAME,
+    },
+    .id_table = mcp_dn_som_id,
+    .probe = mcp_dn_som_probe,
+    .remove = mcp_dn_som_remove,
+};
+
+// Função de inicialização do módulo do kernel
+static int __init mcp_dn_som_init(void)
+{
+    int ret;
+    // Registra o driver I2C
+    i2c_adap = i2c_get_adapter(0);
+    ret = i2c_add_driver(&mcp_dn_som_driver);
+
+    if (ret) {
+        printk(KERN_ERR "Erro ao registrar driver do expansor de GPIO\n");
+        return ret;
+    }
+
+    printk(KERN_INFO "Iniciando driver do expansor de GPIO\n");
+
+    return 0;
+}
+
+// Função de limpeza do módulo do kernel
+void __exit mcp_dn_som_exit(void)
+{
+    // Remove o driver I2C
+    i2c_del_driver(&mcp_dn_som_driver);
+
+    printk(KERN_INFO "Finalizando driver do expansor de GPIO\n");
+}
+
+// Macros para registrar as funções de inicialização e limpeza do módulo
+module_init(mcp_dn_som_init);
+module_exit(mcp_dn_som_exit);
+
+// Informações sobre o módulo do kernel
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Created by Matheus Assunção, Mateus Pantoja e Rubem Silas");
+MODULE_DESCRIPTION("Driver para expansor de GPIO via I2C");
+MODULE_VERSION("1.1");
\ No newline at end of file
diff --git a/drivers/sound/Kconfig b/drivers/sound/Kconfig
new file mode 100644
index 000000000..7a71853c6
--- /dev/null
+++ b/drivers/sound/Kconfig
@@ -0,0 +1,4 @@
+config SOUND_SPH0645
+    tristate "My I2S Microphone Driver"
+    help
+        This option enables support for My I2S Microphone Driver
diff --git a/drivers/sound/Makefile b/drivers/sound/Makefile
new file mode 100644
index 000000000..b3e00fb61
--- /dev/null
+++ b/drivers/sound/Makefile
@@ -0,0 +1,2 @@
+#SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_SOUND_SPH0645)	+= stm32mp1_sph0645.o
\ No newline at end of file
diff --git a/drivers/sound/stm32mp1_sph0645.c b/drivers/sound/stm32mp1_sph0645.c
new file mode 100644
index 000000000..eadcfc29b
--- /dev/null
+++ b/drivers/sound/stm32mp1_sph0645.c
@@ -0,0 +1,175 @@
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/i2c.h>
+#include <sound/soc.h>
+#include <sound/soc-dai.h>
+
+
+static int stm32mp1_sph0645_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	u32 channels = 2;//params_channels(params);//2
+	u32 rate = params_rate(params);
+	u32 bclk = rate * channels * 32;
+	int ret = 0;
+
+	
+	// set cpu DAI configuration 
+	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret) {
+		dev_err(cpu_dai->dev, "failed to set dai fmt\n");
+		// printk(KERN_ERR "failed to set dai fmt\n");
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_tdm_slot(cpu_dai, 0, 2, 2, 32); //(cpu_dai, 0, 3, 2, 32)
+	if (ret) {
+		dev_err(cpu_dai->dev, "failed to set dai tdm slot\n");
+		// printk(KERN_ERR  "failed to set dai tdm slot\n");
+
+		return ret;
+	}
+	
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, bclk, SND_SOC_CLOCK_OUT);
+	if (ret)
+
+		dev_err(cpu_dai->dev, "failed to set cpu sysclk\n");
+		// printk(KERN_ERR "failed to set cpu sysclk\n");
+
+
+	// printk(KERN_ERR "Params do sph0645\n");
+
+	return ret;	
+	
+}
+
+static struct snd_soc_ops stm32mp1_sph0645_ops = {
+	.hw_params = stm32mp1_sph0645_hw_params,
+}; 
+
+
+static struct snd_soc_dai_link stm32mp1_dai = {
+	.name = "snd-soc-dummy",
+	.stream_name = "stm32mp1-sph0645",
+	.ops = &stm32mp1_sph0645_ops,
+	//.ignore_suspend = 1,
+	.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS,
+	.dpcm_capture = 1,
+	.dpcm_playback = 0,
+};
+
+static struct snd_soc_card snd_soc_card_stm32mp1_3stack = {
+	.name = "stm32mp1-audio-sph0645",
+	.dai_link = &stm32mp1_dai,
+	.num_links = 1,
+	.owner = THIS_MODULE,
+};
+
+static int stm32mp1_sph0645_probe(struct platform_device *pdev)
+{
+	// Configurar a placa de som
+    struct snd_soc_card *card = &snd_soc_card_stm32mp1_3stack;
+	struct device_node *cpu_np, *np;
+	struct platform_device *cpu_pdev;
+	int ret;
+
+	cpu_np = of_parse_phandle(pdev->dev.of_node, "cpu-dai", 0);
+	if (!cpu_np) {
+		dev_err(&pdev->dev, "phandle missing or invalid\n");
+		// printk(KERN_ERR "phandle missing or invalid\n");
+
+		return -EINVAL;
+	}
+
+	dev_err(&pdev->dev, "O nome do no: %s", cpu_np->child->name	);
+
+	cpu_pdev = of_find_device_by_node(cpu_np->child);
+	if (!cpu_pdev) {
+		dev_err(&pdev->dev, "failed to find SAI platform device\n");
+		// printk(KERN_ERR "failed to find SAI platform device\n");
+
+		ret = -EINVAL;
+		goto end;
+	}
+
+	card->dev = &pdev->dev;
+	dev_err(&pdev->dev, "Valor de Card ->dev %s", pdev->name);
+	dev_err(&pdev->dev, "Teste 1");
+
+
+
+	card->dai_link->cpu_dai_name = dev_name(&cpu_pdev->dev);		
+	card->dai_link->cpus->dai_name = dev_name(&cpu_pdev->dev);
+	// dev_err(&pdev->dev, "Valor de Card_dai_link->cpus name %s", card->dai_link->cpus->name);
+
+	card->dai_link->platform_of_node = cpu_np;
+	card->dai_link->platforms->dai_name = cpu_np->name;
+	card->dai_link->platforms->of_node = cpu_np;
+	card->dai_link->platforms->name = cpu_np->full_name;	
+	// dev_err(&pdev->dev, "Valor de Card dai_lin-> platform of node %s", card->dai_link->platforms->name);
+
+	
+	
+	platform_set_drvdata(pdev, card);
+	dev_err(&pdev->dev, "Teste 2");
+
+
+	ret = snd_soc_register_card(card);
+	dev_err(&pdev->dev, "Teste 3, ");
+
+	if (ret)
+		dev_err(&pdev->dev, "Failed to register card: %d\n", ret);
+
+
+end:
+	if (cpu_np)
+		of_node_put(cpu_np);
+
+	return ret;
+
+}
+
+static int stm32mp1_sph0645_remove(struct platform_device *pdev)
+{
+
+
+	struct snd_soc_card *card = &snd_soc_card_stm32mp1_3stack;
+	snd_soc_unregister_card(card);
+	return 0;
+
+}
+
+static const struct of_device_id stm32mp1_sph0645_dt_ids[] = {
+	{ .compatible = "st,stm32mp1-audio-sph0645", },
+	{  },
+};
+MODULE_DEVICE_TABLE(of, stm32mp1_sph0645_dt_ids);
+
+static struct platform_driver stm32mp1_sph0645_driver = {
+	.driver = {
+		.name = "stm32mp1-mic-sph0645",
+		//.pm = &snd_soc_pm_ops,
+		.of_match_table = stm32mp1_sph0645_dt_ids,
+	},
+	.probe = stm32mp1_sph0645_probe,
+	.remove = stm32mp1_sph0645_remove,
+};
+
+module_platform_driver(stm32mp1_sph0645_driver);
+
+/* Module information */
+MODULE_AUTHOR("Created by Matheus Assuncao and Mateus Pantoja");
+MODULE_DESCRIPTION("ALSA SoC STM32mp1 sph0645");
+MODULE_LICENSE("GPL");
\ No newline at end of file
diff --git a/drivers/spi/spidev.c b/drivers/spi/spidev.c
index 1bd73e322..5ecdda2db 100644
--- a/drivers/spi/spidev.c
+++ b/drivers/spi/spidev.c
@@ -682,6 +682,7 @@ static const struct spi_device_id spidev_spi_ids[] = {
 	{ .name = "m53cpld" },
 	{ .name = "spi-petra" },
 	{ .name = "spi-authenta" },
+	{ .name = "spidev" },
 	{},
 };
 MODULE_DEVICE_TABLE(spi, spidev_spi_ids);
@@ -696,6 +697,7 @@ static const struct of_device_id spidev_dt_ids[] = {
 	{ .compatible = "menlo,m53cpld" },
 	{ .compatible = "cisco,spi-petra" },
 	{ .compatible = "micron,spi-authenta" },
+	{ .compatible = "linux,spidev" },
 	{},
 };
 MODULE_DEVICE_TABLE(of, spidev_dt_ids);
diff --git a/drivers/usb/dwc2/core_intr.c b/drivers/usb/dwc2/core_intr.c
index c786560fb..a39c03ec3 100644
--- a/drivers/usb/dwc2/core_intr.c
+++ b/drivers/usb/dwc2/core_intr.c
@@ -568,7 +568,9 @@ static void dwc2_handle_usb_suspend_intr(struct dwc2_hsotg *hsotg)
 			hsotg->lx_state = DWC2_L2;
 
 			/* Call gadget suspend callback */
-			call_gadget(hsotg, suspend);
+			//call_gadget(hsotg, suspend);
+			usb_gadget_set_state(&hsotg->gadget, USB_STATE_SUSPENDED);
+
 		}
 	} else {
 		if (hsotg->op_state == OTG_STATE_A_PERIPHERAL) {
diff --git a/include/sound/soc.h b/include/sound/soc.h
index 8e6dd8a25..825c63f4a 100644
--- a/include/sound/soc.h
+++ b/include/sound/soc.h
@@ -1047,6 +1047,8 @@ struct snd_soc_pcm_runtime {
 	 *	asoc_rtd_to_cpu()
 	 *	asoc_rtd_to_codec()
 	 */
+	//inclui para um teste - by Assuncao
+	struct snd_soc_dai *cpu_dai;
 	struct snd_soc_dai **dais;
 	unsigned int num_codecs;
 	unsigned int num_cpus;
diff --git a/sdcard-update.sh b/sdcard-update.sh
new file mode 100755
index 000000000..d57c129fa
--- /dev/null
+++ b/sdcard-update.sh
@@ -0,0 +1,8 @@
+#! /bin/sh
+
+#JUST A BOOTFS
+sudo cp -r ../build-kernel/install_artifact/boot/* /media/$USER/bootfs/
+sudo cp ../build-kernel/drivers/sound/stm32mp1_sph0645.ko /media/pantoja/rootfs/home/root/
+sync
+umount /media/$USER/*
+sync
diff --git a/tools/spi/include/linux/spi/spi.h b/tools/spi/include/linux/spi/spi.h
new file mode 120000
index 000000000..ece697132
--- /dev/null
+++ b/tools/spi/include/linux/spi/spi.h
@@ -0,0 +1 @@
+/home/matheus/hub/som/Developer-Package/stm32mp1-openstlinux-5.15-yocto-kirkstone-mp1-v22.06.15/sources/arm-ostl-linux-gnueabi/linux-stm32mp-5.15.24-stm32mp1-r1-r0/linux-5.15.24/tools/spi/../../include/uapi/linux/spi/spi.h
\ No newline at end of file
diff --git a/tools/spi/include/linux/spi/spidev.h b/tools/spi/include/linux/spi/spidev.h
new file mode 120000
index 000000000..de81d3e9e
--- /dev/null
+++ b/tools/spi/include/linux/spi/spidev.h
@@ -0,0 +1 @@
+/home/matheus/hub/som/Developer-Package/stm32mp1-openstlinux-5.15-yocto-kirkstone-mp1-v22.06.15/sources/arm-ostl-linux-gnueabi/linux-stm32mp-5.15.24-stm32mp1-r1-r0/linux-5.15.24/tools/spi/../../include/uapi/linux/spi/spidev.h
\ No newline at end of file
